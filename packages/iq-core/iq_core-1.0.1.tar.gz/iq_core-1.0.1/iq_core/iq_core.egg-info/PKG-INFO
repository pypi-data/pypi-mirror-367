Metadata-Version: 2.4
Name: iq-core
Version: 1.0.1
Summary: API wrapper para IQ Option
Author-email: CÃ©lio Junior <profissional.celiojunior@outlook.com>
License-Expression: MIT
Project-URL: Homepage, https://github.com/celiovmjr/iq-core
Project-URL: Source, https://github.com/celiovmjr/iq-core
Project-URL: Issues, https://github.com/celiovmjr/iq-core/issues
Classifier: Development Status :: 5 - Production/Stable
Classifier: Intended Audience :: Developers
Classifier: Programming Language :: Python :: 3
Classifier: Programming Language :: Python :: 3.10
Classifier: Programming Language :: Python :: 3.11
Classifier: Programming Language :: Python :: 3.12
Classifier: Programming Language :: Python :: 3.13
Classifier: Operating System :: OS Independent
Requires-Python: >=3.10
Description-Content-Type: text/markdown
Requires-Dist: aiohttp>=3.12.0
Requires-Dist: websockets>=15.0.0
Requires-Dist: cryptography>=45.0.0

# ğŸš€ IQ Option Trading System

[![Python 3.11+](https://img.shields.io/badge/python-3.11+-blue.svg)](https://www.python.org/downloads/)
[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)
[![Code Style: Black](https://img.shields.io/badge/code%20style-black-000000.svg)](https://github.com/psf/black)

> ğŸ‡§ğŸ‡· Sistema profissional de trading para IQ Option com arquitetura orientada ao domÃ­nio (DDD)  
> ğŸ‡ºğŸ‡¸ Professional IQ Option trading system with domain-driven architecture (DDD)

## ğŸ“‹ Ãndice / Table of Contents

- [ğŸŒŸ CaracterÃ­sticas](#-caracterÃ­sticas--features)
- [ğŸ”§ InstalaÃ§Ã£o](#-instalaÃ§Ã£o--installation)
- [ğŸš€ InÃ­cio RÃ¡pido](#-inÃ­cio-rÃ¡pido--quick-start)
- [ğŸ“š DocumentaÃ§Ã£o da API](#-documentaÃ§Ã£o-da-api--api-documentation)
- [ğŸ’¡ Exemplos de Uso](#-exemplos-de-uso--usage-examples)
- [ğŸ—ï¸ Arquitetura](#ï¸-arquitetura--architecture)
- [âš™ï¸ ConfiguraÃ§Ã£o](#ï¸-configuraÃ§Ã£o--configuration)
- [ğŸ§ª Testes](#-testes--testing)
- [ğŸ¤ ContribuiÃ§Ã£o](#-contribuiÃ§Ã£o--contributing)
- [ğŸ“„ LicenÃ§a](#-licenÃ§a--license)

## ğŸŒŸ CaracterÃ­sticas / Features

### ğŸ‡§ğŸ‡· PortuguÃªs
- âœ… **AutenticaÃ§Ã£o Segura**: Sistema de tokens com cache automÃ¡tico
- âœ… **Trading Automatizado**: Suporte para Binary, Digital e Forex
- âœ… **AnÃ¡lise TÃ©cnica**: IntegraÃ§Ã£o com TradingView e IA
- âœ… **Gerenciamento de Risco**: Stop-loss e stop-win automÃ¡ticos
- âœ… **Streaming em Tempo Real**: Candles, humor do trader e resultados
- âœ… **Arquitetura Limpa**: DDD com separaÃ§Ã£o clara de responsabilidades
- âœ… **Async/Await**: Performance otimizada com programaÃ§Ã£o assÃ­ncrona
- âœ… **Type Safety**: Totalmente tipado com Python 3.11+

### ğŸ‡ºğŸ‡¸ English
- âœ… **Secure Authentication**: Token system with automatic caching
- âœ… **Automated Trading**: Support for Binary, Digital and Forex
- âœ… **Technical Analysis**: TradingView and AI integration
- âœ… **Risk Management**: Automatic stop-loss and stop-win
- âœ… **Real-time Streaming**: Candles, trader mood and results
- âœ… **Clean Architecture**: DDD with clear separation of concerns
- âœ… **Async/Await**: Optimized performance with asynchronous programming
- âœ… **Type Safety**: Fully typed with Python 3.11+

## ğŸ”§ InstalaÃ§Ã£o / Installation

### Requisitos / Requirements
- Python 3.11 ou superior / Python 3.11 or higher
- Conta IQ Option / IQ Option account

### InstalaÃ§Ã£o via pip
```bash
pip install iq-core
```

### InstalaÃ§Ã£o para desenvolvimento / Development installation
```bash
git clone https://github.com/celiovmjr/iq-core.git
cd iq-core
pip install -e ".[dev]"
```

### DependÃªncias / Dependencies
```bash
pip install -r requirements.txt
```

## ğŸš€ InÃ­cio RÃ¡pido / Quick Start

### 1. ConfiguraÃ§Ã£o BÃ¡sica / Basic Setup

```python
import asyncio
from iq_core import (
    AuthService,
    AccountType,
    InstrumentService,
    BinaryTradeService,
    Signal,
    SignalType,
    Direction
)

async def main():
    # ğŸ‡§ğŸ‡· AutenticaÃ§Ã£o / ğŸ‡ºğŸ‡¸ Authentication
    async with AuthService().context() as auth:
        ws, profile = await auth.login("seu_email@email.com", "sua_senha")
        
        # ğŸ‡§ğŸ‡· Trocar para conta demo / ğŸ‡ºğŸ‡¸ Switch to practice account
        await profile.account.switch_active_account(AccountType.PRACTICE)
        
        # ğŸ‡§ğŸ‡· Buscar instrumentos / ğŸ‡ºğŸ‡¸ Fetch instruments
        instrument_service = InstrumentService(ws)
        instruments = await instrument_service.fetch(limit=5, groups=["forex"])
        
        print(f"ğŸ“Š Instrumentos disponÃ­veis: {len(instruments)}")
        for instrument in instruments:
            print(f"  â€¢ {instrument.name} - {instrument.market}")

if __name__ == "__main__":
    asyncio.run(main())
```

### 2. Trading Simples / Simple Trading

```python
import asyncio
from iq_core import *

async def simple_trade():
    async with AuthService().context() as auth:
        ws, profile = await auth.login("email", "password")
        await profile.account.switch_active_account(AccountType.PRACTICE)
        
        # ğŸ‡§ğŸ‡· Configurar serviÃ§os / ğŸ‡ºğŸ‡¸ Setup services
        instrument_service = InstrumentService(ws)
        binary_service = BinaryTradeService(ws)
        
        # ğŸ‡§ğŸ‡· Buscar instrumento / ğŸ‡ºğŸ‡¸ Get instrument
        instrument = await instrument_service.fetch("EURUSD")
        
        # ğŸ‡§ğŸ‡· Criar sinal / ğŸ‡ºğŸ‡¸ Create signal
        signal = Signal(
            instrument=instrument,
            account_id=profile.balance_id,
            direction=Direction.CALL,
            amount=10.0,
            expiration=60,  # 1 minuto
            type=SignalType.BINARY
        )
        
        # ğŸ‡§ğŸ‡· Abrir trade / ğŸ‡ºğŸ‡¸ Open trade
        trade_id = await binary_service.open_trade(signal)
        print(f"ğŸ¯ Trade aberto: {trade_id}")
        
        # ğŸ‡§ğŸ‡· Monitorar resultado / ğŸ‡ºğŸ‡¸ Monitor result
        while True:
            status, result = await binary_service.trade_status(trade_id)
            if status and result:
                print(f"ğŸ“ˆ Resultado: {result.result} | Lucro: {result.profit}")
                break
            await asyncio.sleep(1)

asyncio.run(simple_trade())
```

## ğŸ“š DocumentaÃ§Ã£o da API / API Documentation

### ğŸ” AutenticaÃ§Ã£o / Authentication

#### AuthService
```python
from iq_core import AuthService

# ğŸ‡§ğŸ‡· InicializaÃ§Ã£o / ğŸ‡ºğŸ‡¸ Initialization
auth = AuthService()

# ğŸ‡§ğŸ‡· Login / ğŸ‡ºğŸ‡¸ Login
ws, profile = await auth.login("email", "password")

# ğŸ‡§ğŸ‡· Verificar autenticaÃ§Ã£o / ğŸ‡ºğŸ‡¸ Check authentication
if auth.is_authenticated:
    print("âœ… Autenticado com sucesso")

# ğŸ‡§ğŸ‡· Logout / ğŸ‡ºğŸ‡¸ Logout
await auth.logout()

# ğŸ‡§ğŸ‡· Context manager (recomendado) / ğŸ‡ºğŸ‡¸ Context manager (recommended)
async with AuthService().context() as auth:
    ws, profile = await auth.login("email", "password")
    # Logout automÃ¡tico ao sair do contexto
```

### ğŸ“Š Instrumentos / Instruments

#### InstrumentService
```python
from iq_core import InstrumentService

service = InstrumentService(ws)

# ğŸ‡§ğŸ‡· Buscar todos os instrumentos / ğŸ‡ºğŸ‡¸ Fetch all instruments
instruments = await service.fetch()

# ğŸ‡§ğŸ‡· Filtrar por grupo / ğŸ‡ºğŸ‡¸ Filter by group
forex_instruments = await service.fetch(groups=["forex"])

# ğŸ‡§ğŸ‡· Buscar instrumento especÃ­fico / ğŸ‡ºğŸ‡¸ Get specific instrument
eurusd = await service.fetch("EURUSD")

# ğŸ‡§ğŸ‡· Apenas instrumentos abertos / ğŸ‡ºğŸ‡¸ Only open instruments
open_instruments = await service.fetch(only_open=True)

# ğŸ‡§ğŸ‡· Limitar resultados / ğŸ‡ºğŸ‡¸ Limit results
limited = await service.fetch(limit=10, offset=5)
```

### ğŸ’¹ Trading Services

#### BinaryTradeService
```python
from iq_core import BinaryTradeService, Signal, SignalType, Direction

service = BinaryTradeService(ws)

# ğŸ‡§ğŸ‡· Criar sinal / ğŸ‡ºğŸ‡¸ Create signal
signal = Signal(
    instrument=instrument,
    account_id=profile.balance_id,
    direction=Direction.CALL,
    amount=10.0,
    expiration=60,
    type=SignalType.BINARY
)

# ğŸ‡§ğŸ‡· Abrir trade / ğŸ‡ºğŸ‡¸ Open trade
trade_id = await service.open_trade(signal)

# ğŸ‡§ğŸ‡· Verificar status / ğŸ‡ºğŸ‡¸ Check status
is_closed, result = await service.trade_status(trade_id)
```

#### TradingManagerService
```python
from iq_core import TradingManagerService

# ğŸ‡§ğŸ‡· ConfiguraÃ§Ã£o / ğŸ‡ºğŸ‡¸ Configuration
manager = TradingManagerService(
    start_balance=1000.0,
    stop_win_percent=20,    # 20% de lucro
    stop_loss_percent=10,   # 10% de perda
    services={"binary": binary_service},
    max_open_trades=5
)

# ğŸ‡§ğŸ‡· Callback para trades finalizados / ğŸ‡ºğŸ‡¸ Callback for finished trades
async def on_trade_finished(result, manager):
    print(f"Trade finalizado: {result.result}")
    print(f"Saldo atual: {manager.balance}")

manager.register(on_trade_finished)

# ğŸ‡§ğŸ‡· Executar trade / ğŸ‡ºğŸ‡¸ Execute trade
await manager.execute(signal)

# ğŸ‡§ğŸ‡· Verificar limites / ğŸ‡ºğŸ‡¸ Check limits
if manager.can_trade():
    print("âœ… Pode operar")
else:
    print("âŒ Limite atingido")

# ğŸ‡§ğŸ‡· Resumo / ğŸ‡ºğŸ‡¸ Summary
print(manager.summary())
```

### ğŸ“ˆ AnÃ¡lise de Mercado / Market Analysis

#### CandleService
```python
from iq_core import CandleService
from datetime import datetime

service = CandleService(ws)

# ğŸ‡§ğŸ‡· Candles histÃ³ricos / ğŸ‡ºğŸ‡¸ Historical candles
candles = await service.get_candles(
    active_id=1,        # EURUSD
    quantity=50,        # 50 candles
    size=300,          # 5 minutos
    from_time=datetime.now()
)

# ğŸ‡§ğŸ‡· Stream de candles em tempo real / ğŸ‡ºğŸ‡¸ Real-time candle stream
async for candle in service.stream(active_id=1, size=60):
    print(f"ğŸ“Š Novo candle: O:{candle.open} C:{candle.close}")
```

#### TraderMoodService
```python
from iq_core import TraderMoodService

service = TraderMoodService(ws)

# ğŸ‡§ğŸ‡· Stream de humor do trader / ğŸ‡ºğŸ‡¸ Trader mood stream
async for mood in service.subscribe(instrument_id=1):
    print(f"ğŸ˜Š Humor: {mood}%")
    
    if mood > 80:
        print("ğŸ”´ Muito otimista - considere PUT")
    elif mood < 20:
        print("ğŸŸ¢ Muito pessimista - considere CALL")
```

#### PortfolioAnalysisService
```python
from iq_core import PortfolioAnalysisService

service = PortfolioAnalysisService(
    api_key="sua_api_key_gemini",
    system_instruction="Analyze trading opportunities"
)

# ğŸ‡§ğŸ‡· AnÃ¡lise de portfÃ³lio / ğŸ‡ºğŸ‡¸ Portfolio analysis
analysis = service.generate(technical_report)
print(f"DireÃ§Ã£o recomendada: {analysis['direction']}")
print(f"Valor sugerido: {analysis['value']}")
```

## ğŸ’¡ Exemplos de Uso / Usage Examples

### ğŸ¯ Exemplo 1: Bot de Trading AutomÃ¡tico

```python
import asyncio
from iq_core import *

class TradingBot:
    def __init__(self, email: str, password: str):
        self.email = email
        self.password = password
        self.is_running = False
    
    async def start(self):
        """ğŸ‡§ğŸ‡· Iniciar bot / ğŸ‡ºğŸ‡¸ Start bot"""
        async with AuthService().context() as auth:
            ws, profile = await auth.login(self.email, self.password)
            await profile.account.switch_active_account(AccountType.PRACTICE)
            
            # ğŸ‡§ğŸ‡· Configurar serviÃ§os / ğŸ‡ºğŸ‡¸ Setup services
            instrument_service = InstrumentService(ws)
            binary_service = BinaryTradeService(ws)
            mood_service = TraderMoodService(ws)
            
            # ğŸ‡§ğŸ‡· Configurar gerenciador / ğŸ‡ºğŸ‡¸ Setup manager
            manager = TradingManagerService(
                start_balance=profile.balance,
                stop_win_percent=15,
                stop_loss_percent=10,
                services={"binary": binary_service}
            )
            
            manager.register(self.on_trade_finished)
            
            # ğŸ‡§ğŸ‡· Buscar instrumentos / ğŸ‡ºğŸ‡¸ Get instruments
            instruments = await instrument_service.fetch(
                limit=5, 
                groups=["forex"], 
                only_open=True
            )
            
            # ğŸ‡§ğŸ‡· Iniciar monitoramento / ğŸ‡ºğŸ‡¸ Start monitoring
            self.is_running = True
            tasks = []
            
            for instrument in instruments:
                task = asyncio.create_task(
                    self.monitor_instrument(instrument, mood_service, manager)
                )
                tasks.append(task)
            
            await asyncio.gather(*tasks)
    
    async def monitor_instrument(self, instrument, mood_service, manager):
        """ğŸ‡§ğŸ‡· Monitorar instrumento / ğŸ‡ºğŸ‡¸ Monitor instrument"""
        async for mood in mood_service.subscribe(instrument.id):
            if not self.is_running:
                break
                
            if not manager.can_trade():
                print("âš ï¸ Limite de trading atingido")
                break
            
            # ğŸ‡§ğŸ‡· LÃ³gica de trading / ğŸ‡ºğŸ‡¸ Trading logic
            direction = None
            if mood > 85:
                direction = Direction.PUT
            elif mood < 15:
                direction = Direction.CALL
            
            if direction:
                signal = Signal(
                    instrument=instrument,
                    account_id=manager._start_balance,  # Use appropriate account ID
                    direction=direction,
                    amount=10.0,
                    expiration=60,
                    type=SignalType.BINARY
                )
                
                await manager.execute(signal)
                print(f"ğŸ¯ Trade executado: {instrument.name} {direction}")
    
    async def on_trade_finished(self, result, manager):
        """ğŸ‡§ğŸ‡· Callback para trades finalizados / ğŸ‡ºğŸ‡¸ Finished trades callback"""
        status = "âœ… WIN" if result.is_win else "âŒ LOSS"
        print(f"{status} | {result.instrument.name} | Lucro: {result.profit}")
        print(f"ğŸ’° Saldo atual: {manager.balance}")
        
        # ğŸ‡§ğŸ‡· Parar se atingir limites / ğŸ‡ºğŸ‡¸ Stop if limits reached
        if manager.is_limit_reached():
            print("ğŸ›‘ Limite atingido - parando bot")
            self.is_running = False

# ğŸ‡§ğŸ‡· Uso / ğŸ‡ºğŸ‡¸ Usage
bot = TradingBot("seu_email@email.com", "sua_senha")
asyncio.run(bot.start())
```

### ğŸ“Š Exemplo 2: AnÃ¡lise de Candles

```python
import asyncio
from datetime import datetime, timedelta
from iq_core import *

async def analyze_candles():
    """ğŸ‡§ğŸ‡· Analisar padrÃµes de candles / ğŸ‡ºğŸ‡¸ Analyze candle patterns"""
    async with AuthService().context() as auth:
        ws, profile = await auth.login("email", "password")
        
        candle_service = CandleService(ws)
        instrument_service = InstrumentService(ws)
        
        # ğŸ‡§ğŸ‡· Buscar EURUSD / ğŸ‡ºğŸ‡¸ Get EURUSD
        eurusd = await instrument_service.fetch("EURUSD")
        
        # ğŸ‡§ğŸ‡· Candles histÃ³ricos / ğŸ‡ºğŸ‡¸ Historical candles
        candles = await candle_service.get_candles(
            active_id=eurusd.id,
            quantity=100,
            size=300,  # 5 minutos
            from_time=datetime.now() - timedelta(hours=8)
        )
        
        # ğŸ‡§ğŸ‡· AnÃ¡lise simples / ğŸ‡ºğŸ‡¸ Simple analysis
        print(f"ğŸ“Š Analisando {len(candles)} candles do {eurusd.name}")
        
        green_candles = sum(1 for c in candles if c.close > c.open)
        red_candles = len(candles) - green_candles
        
        print(f"ğŸŸ¢ Candles verdes: {green_candles}")
        print(f"ğŸ”´ Candles vermelhos: {red_candles}")
        
        # ğŸ‡§ğŸ‡· TendÃªncia / ğŸ‡ºğŸ‡¸ Trend
        if green_candles > red_candles:
            print("ğŸ“ˆ TendÃªncia de alta")
        else:
            print("ğŸ“‰ TendÃªncia de baixa")
        
        # ğŸ‡§ğŸ‡· Ãšltimos 5 candles / ğŸ‡ºğŸ‡¸ Last 5 candles
        recent = candles[-5:]
        print("\nğŸ• Ãšltimos 5 candles:")
        for i, candle in enumerate(recent, 1):
            trend = "ğŸŸ¢" if candle.close > candle.open else "ğŸ”´"
            print(f"  {i}. {trend} O:{candle.open:.5f} C:{candle.close:.5f}")

asyncio.run(analyze_candles())
```

### ğŸ¨ Exemplo 3: Dashboard em Tempo Real

```python
import asyncio
from datetime import datetime
from iq_core import *

class TradingDashboard:
    def __init__(self):
        self.instruments = {}
        self.moods = {}
        self.candles = {}
    
    async def start(self, email: str, password: str):
        """ğŸ‡§ğŸ‡· Iniciar dashboard / ğŸ‡ºğŸ‡¸ Start dashboard"""
        async with AuthService().context() as auth:
            ws, profile = await auth.login(email, password)
            
            # ğŸ‡§ğŸ‡· ServiÃ§os / ğŸ‡ºğŸ‡¸ Services
            instrument_service = InstrumentService(ws)
            mood_service = TraderMoodService(ws)
            candle_service = CandleService(ws)
            
            # ğŸ‡§ğŸ‡· Buscar instrumentos principais / ğŸ‡ºğŸ‡¸ Get main instruments
            instruments = await instrument_service.fetch(
                groups=["forex"], 
                limit=3, 
                only_open=True
            )
            
            print("ğŸš€ Dashboard iniciado!")
            print("=" * 50)
            
            # ğŸ‡§ğŸ‡· Iniciar streams / ğŸ‡ºğŸ‡¸ Start streams
            tasks = []
            for instrument in instruments:
                # Mood stream
                tasks.append(
                    asyncio.create_task(
                        self.stream_mood(mood_service, instrument)
                    )
                )
                # Candle stream
                tasks.append(
                    asyncio.create_task(
                        self.stream_candles(candle_service, instrument)
                    )
                )
            
            # ğŸ‡§ğŸ‡· Display task / ğŸ‡ºğŸ‡¸ Display task
            tasks.append(asyncio.create_task(self.display_dashboard()))
            
            await asyncio.gather(*tasks)
    
    async def stream_mood(self, service, instrument):
        """ğŸ‡§ğŸ‡· Stream de humor / ğŸ‡ºğŸ‡¸ Mood stream"""
        async for mood in service.subscribe(instrument.id):
            self.moods[instrument.name] = mood
    
    async def stream_candles(self, service, instrument):
        """ğŸ‡§ğŸ‡· Stream de candles / ğŸ‡ºğŸ‡¸ Candle stream"""
        async for candle in service.stream(instrument.id, 60):
            self.candles[instrument.name] = candle
    
    async def display_dashboard(self):
        """ğŸ‡§ğŸ‡· Exibir dashboard / ğŸ‡ºğŸ‡¸ Display dashboard"""
        while True:
            # ğŸ‡§ğŸ‡· Limpar tela / ğŸ‡ºğŸ‡¸ Clear screen
            print("\033[2J\033[H")
            
            print("ğŸ“Š TRADING DASHBOARD")
            print("=" * 60)
            print(f"ğŸ• {datetime.now().strftime('%H:%M:%S')}")
            print()
            
            # ğŸ‡§ğŸ‡· Exibir dados / ğŸ‡ºğŸ‡¸ Display data
            for name in self.moods.keys():
                mood = self.moods.get(name, 0)
                candle = self.candles.get(name)
                
                mood_emoji = self.get_mood_emoji(mood)
                trend_emoji = "ğŸ“ˆ" if candle and candle.close > candle.open else "ğŸ“‰"
                
                print(f"{name:10} | {mood_emoji} {mood:3d}% | {trend_emoji}")
                
                if candle:
                    print(f"           | O:{candle.open:.5f} C:{candle.close:.5f}")
                print()
            
            await asyncio.sleep(1)
    
    def get_mood_emoji(self, mood: int) -> str:
        """ğŸ‡§ğŸ‡· Emoji baseado no humor / ğŸ‡ºğŸ‡¸ Emoji based on mood"""
        if mood > 80:
            return "ğŸ”´"  # Muito otimista
        elif mood > 60:
            return "ğŸŸ¡"  # Otimista
        elif mood > 40:
            return "âšª"  # Neutro
        elif mood > 20:
            return "ğŸŸ¡"  # Pessimista
        else:
            return "ğŸŸ¢"  # Muito pessimista

# ğŸ‡§ğŸ‡· Uso / ğŸ‡ºğŸ‡¸ Usage
dashboard = TradingDashboard()
asyncio.run(dashboard.start("seu_email@email.com", "sua_senha"))
```

## ğŸ—ï¸ Arquitetura / Architecture

### ğŸ“ Estrutura do Projeto / Project Structure

```
iq-core/
â”œâ”€â”€ ğŸ“ iq_core/                 # ğŸ‡§ğŸ‡· Pacote principal / ğŸ‡ºğŸ‡¸ Main package
â”‚   â”œâ”€â”€ ğŸ“ entities/             # ğŸ‡§ğŸ‡· Entidades de domÃ­nio / ğŸ‡ºğŸ‡¸ Domain entities
â”‚   â”‚   â”œâ”€â”€ account.py           # ğŸ‡§ğŸ‡· Conta do usuÃ¡rio / ğŸ‡ºğŸ‡¸ User account
â”‚   â”‚   â”œâ”€â”€ instrument.py        # ğŸ‡§ğŸ‡· Instrumentos financeiros / ğŸ‡ºğŸ‡¸ Financial instruments
â”‚   â”‚   â”œâ”€â”€ signal.py            # ğŸ‡§ğŸ‡· Sinais de trading / ğŸ‡ºğŸ‡¸ Trading signals
â”‚   â”‚   â”œâ”€â”€ trade_result.py      # ğŸ‡§ğŸ‡· Resultados de trades / ğŸ‡ºğŸ‡¸ Trade results
â”‚   â”‚   â””â”€â”€ ...
â”‚   â”œâ”€â”€ ğŸ“ services/             # ğŸ‡§ğŸ‡· ServiÃ§os de aplicaÃ§Ã£o / ğŸ‡ºğŸ‡¸ Application services
â”‚   â”‚   â”œâ”€â”€ auth_service.py      # ğŸ‡§ğŸ‡· AutenticaÃ§Ã£o / ğŸ‡ºğŸ‡¸ Authentication
â”‚   â”‚   â”œâ”€â”€ trading_manager_service.py  # ğŸ‡§ğŸ‡· Gerenciamento de trades / ğŸ‡ºğŸ‡¸ Trade management
â”‚   â”‚   â”œâ”€â”€ instrument_service.py       # ğŸ‡§ğŸ‡· ServiÃ§o de instrumentos / ğŸ‡ºğŸ‡¸ Instrument service
â”‚   â”‚   â””â”€â”€ ...
â”‚   â”œâ”€â”€ ğŸ“ exceptions/           # ğŸ‡§ğŸ‡· ExceÃ§Ãµes customizadas / ğŸ‡ºğŸ‡¸ Custom exceptions
â”‚   â”œâ”€â”€ ğŸ“ websocket/            # ğŸ‡§ğŸ‡· Cliente WebSocket / ğŸ‡ºğŸ‡¸ WebSocket client
â”‚   â””â”€â”€ settings.py              # ğŸ‡§ğŸ‡· ConfiguraÃ§Ãµes / ğŸ‡ºğŸ‡¸ Settings
â”œâ”€â”€ ğŸ“ tests/                    # ğŸ‡§ğŸ‡· Testes / ğŸ‡ºğŸ‡¸ Tests
â”œâ”€â”€ ğŸ“ examples/                 # ğŸ‡§ğŸ‡· Exemplos / ğŸ‡ºğŸ‡¸ Examples
â”œâ”€â”€ requirements.txt             # ğŸ‡§ğŸ‡· DependÃªncias / ğŸ‡ºğŸ‡¸ Dependencies
â””â”€â”€ README.md                    # ğŸ‡§ğŸ‡· DocumentaÃ§Ã£o / ğŸ‡ºğŸ‡¸ Documentation
```

### ğŸ¯ PrincÃ­pios de Design / Design Principles

#### ğŸ‡§ğŸ‡· Domain-Driven Design (DDD)
- **Entidades**: Representam conceitos de negÃ³cio (Account, Instrument, Signal)
- **ServiÃ§os**: Encapsulam lÃ³gica de negÃ³cio complexa
- **RepositÃ³rios**: AbstraÃ§Ã£o para acesso a dados
- **Value Objects**: Objetos imutÃ¡veis (TradeResult, Candle)

#### ğŸ‡ºğŸ‡¸ Domain-Driven Design (DDD)
- **Entities**: Represent business concepts (Account, Instrument, Signal)
- **Services**: Encapsulate complex business logic
- **Repositories**: Data access abstraction
- **Value Objects**: Immutable objects (TradeResult, Candle)

### ğŸ”„ Fluxo de Dados / Data Flow

```mermaid
graph TD
    A[ğŸ” AuthService] --> B[ğŸ“¡ WebSocket Client]
    B --> C[ğŸ“Š InstrumentService]
    B --> D[ğŸ’¹ TradingServices]
    B --> E[ğŸ“ˆ MarketDataServices]
    
    C --> F[ğŸ¯ TradingManagerService]
    D --> F
    E --> F
    
    F --> G[ğŸ“‹ TradeResult]
    G --> H[ğŸ“Š Portfolio Analysis]
```

## ğŸ›¡ï¸ Tratamento de Erros / Error Handling

### ğŸš¨ ExceÃ§Ãµes Customizadas / Custom Exceptions

```python
from iq_core.exceptions import (
    IQOptionError,           # ğŸ‡§ğŸ‡· Erro base / ğŸ‡ºğŸ‡¸ Base error
    AuthenticationError,     # ğŸ‡§ğŸ‡· Erro de autenticaÃ§Ã£o / ğŸ‡ºğŸ‡¸ Authentication error
    TradingError,           # ğŸ‡§ğŸ‡· Erro de trading / ğŸ‡ºğŸ‡¸ Trading error
    NetworkUnavailableError, # ğŸ‡§ğŸ‡· Erro de rede / ğŸ‡ºğŸ‡¸ Network error
    ValidationError         # ğŸ‡§ğŸ‡· Erro de validaÃ§Ã£o / ğŸ‡ºğŸ‡¸ Validation error
)

try:
    ws, profile = await auth.login("email", "password")
except AuthenticationError as e:
    print(f"âŒ Erro de autenticaÃ§Ã£o: {e}")
except NetworkUnavailableError as e:
    print(f"ğŸŒ Erro de rede: {e}")
except IQOptionError as e:
    print(f"âš ï¸ Erro geral: {e}")
```

### ğŸ”„ Retry e ReconexÃ£o / Retry and Reconnection

```python
import asyncio
from iq_core import AuthService
from iq_core.exceptions import NetworkUnavailableError

async def robust_login(email: str, password: str, max_retries: int = 3):
    """ğŸ‡§ğŸ‡· Login com retry automÃ¡tico / ğŸ‡ºğŸ‡¸ Login with automatic retry"""
    for attempt in range(max_retries):
        try:
            async with AuthService().context() as auth:
                return await auth.login(email, password)
        except NetworkUnavailableError as e:
            if attempt == max_retries - 1:
                raise
            
            wait_time = 2 ** attempt  # Backoff exponencial
            print(f"ğŸ”„ Tentativa {attempt + 1} falhou. Tentando novamente em {wait_time}s...")
            await asyncio.sleep(wait_time)
```

## ğŸ“Š Monitoramento e Logs / Monitoring and Logging

### ğŸ“ ConfiguraÃ§Ã£o de Logs / Logging Configuration

```python
import logging
from iq_core import IQOptionSettings

# ğŸ‡§ğŸ‡· ConfiguraÃ§Ã£o bÃ¡sica / ğŸ‡ºğŸ‡¸ Basic configuration
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s | %(name)s | %(levelname)s | %(message)s',
    handlers=[
        logging.FileHandler('trading.log'),
        logging.StreamHandler()
    ]
)

# ğŸ‡§ğŸ‡· Logger especÃ­fico / ğŸ‡ºğŸ‡¸ Specific logger
logger = logging.getLogger('iq_core.trading')

# ğŸ‡§ğŸ‡· ConfiguraÃ§Ã£o avanÃ§ada / ğŸ‡ºğŸ‡¸ Advanced configuration
settings = IQOptionSettings(
    log_level="DEBUG",
    log_websocket_messages=True
)
```

### ğŸ“ˆ MÃ©tricas de Performance / Performance Metrics

```python
import time
from iq_core.anotations import measure_time

@measure_time
async def monitored_function():
    """ğŸ‡§ğŸ‡· FunÃ§Ã£o com mediÃ§Ã£o de tempo / ğŸ‡ºğŸ‡¸ Function with time measurement"""
    # Sua lÃ³gica aqui
    pass

# ğŸ‡§ğŸ‡· MÃ©tricas customizadas / ğŸ‡ºğŸ‡¸ Custom metrics
class TradingMetrics:
    def __init__(self):
        self.trades_count = 0
        self.wins = 0
        self.losses = 0
        self.total_profit = 0.0
    
    def record_trade(self, result):
        self.trades_count += 1
        if result.is_win:
            self.wins += 1
        else:
            self.losses += 1
        self.total_profit += result.profit
    
    @property
    def win_rate(self) -> float:
        return (self.wins / self.trades_count * 100) if self.trades_count > 0 else 0.0
    
    def summary(self) -> str:
        return f"""
ğŸ“Š Trading Metrics
â”œâ”€â”€ Total Trades: {self.trades_count}
â”œâ”€â”€ Wins: {self.wins} ({self.win_rate:.1f}%)
â”œâ”€â”€ Losses: {self.losses}
â””â”€â”€ Total Profit: ${self.total_profit:.2f}
        """
```

## ğŸ”’ SeguranÃ§a / Security

### ğŸ›¡ï¸ Boas PrÃ¡ticas / Best Practices

```python
import os
from dotenv import load_dotenv

# ğŸ‡§ğŸ‡· Carregar variÃ¡veis de ambiente / ğŸ‡ºğŸ‡¸ Load environment variables
load_dotenv()

# âœ… ğŸ‡§ğŸ‡· CORRETO: Usar variÃ¡veis de ambiente / ğŸ‡ºğŸ‡¸ CORRECT: Use environment variables
email = os.getenv("IQ_EMAIL")
password = os.getenv("IQ_PASSWORD")

# âŒ ğŸ‡§ğŸ‡· INCORRETO: Hardcoded no cÃ³digo / ğŸ‡ºğŸ‡¸ INCORRECT: Hardcoded in code
# email = "meu_email@email.com"  # Nunca faÃ§a isso!
# password = "minha_senha"       # Never do this!

# ğŸ‡§ğŸ‡· ValidaÃ§Ã£o de credenciais / ğŸ‡ºğŸ‡¸ Credential validation
if not email or not password:
    raise ValueError("Email and password must be provided via environment variables")

# ğŸ‡§ğŸ‡· Timeout de sessÃ£o / ğŸ‡ºğŸ‡¸ Session timeout
from iq_core import IQOptionSettings

settings = IQOptionSettings(
    connection_timeout=30,      # 30 segundos
    websocket_timeout=60,       # 1 minuto
    max_reconnect_attempts=3    # MÃ¡ximo 3 tentativas
)
```

### ğŸ” Gerenciamento de Tokens / Token Management

```python
from iq_core import TokenManager

# ğŸ‡§ğŸ‡· Token manager customizado / ğŸ‡ºğŸ‡¸ Custom token manager
token_manager = TokenManager()

# ğŸ‡§ğŸ‡· Cache de token / ğŸ‡ºğŸ‡¸ Token caching
auth = AuthService(token_manager=token_manager)

# ğŸ‡§ğŸ‡· O token serÃ¡ automaticamente cacheado e reutilizado
# ğŸ‡ºğŸ‡¸ Token will be automatically cached and reused
ws, profile = await auth.login(email, password)
```

## ğŸš€ Deploy e ProduÃ§Ã£o / Deploy and Production

### ğŸ³ Docker

```dockerfile
# Dockerfile
FROM python:3.11-slim

WORKDIR /app

# ğŸ‡§ğŸ‡· Instalar dependÃªncias / ğŸ‡ºğŸ‡¸ Install dependencies
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# ğŸ‡§ğŸ‡· Copiar cÃ³digo / ğŸ‡ºğŸ‡¸ Copy code
COPY . .

# ğŸ‡§ğŸ‡· VariÃ¡veis de ambiente / ğŸ‡ºğŸ‡¸ Environment variables
ENV PYTHONPATH=/app
ENV IQ_LOG_LEVEL=INFO

# ğŸ‡§ğŸ‡· Comando padrÃ£o / ğŸ‡ºğŸ‡¸ Default command
CMD ["python", "main.py"]
```

```yaml
# docker-compose.yml
version: '3.8'

services:
  trading-bot:
    build: .
    environment:
      - IQ_EMAIL=${IQ_EMAIL}
      - IQ_PASSWORD=${IQ_PASSWORD}
      - IQ_LOG_LEVEL=INFO
    volumes:
      - ./logs:/app/logs
    restart: unless-stopped
```

### â˜ï¸ Deploy na Nuvem / Cloud Deploy

```python
# main.py - AplicaÃ§Ã£o para produÃ§Ã£o
import asyncio
import logging
import signal
import sys
from iq_core import *

class ProductionTradingBot:
    def __init__(self):
        self.is_running = False
        self.setup_logging()
        self.setup_signal_handlers()
    
    def setup_logging(self):
        """ğŸ‡§ğŸ‡· Configurar logs para produÃ§Ã£o / ğŸ‡ºğŸ‡¸ Setup production logging"""
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s | %(name)s | %(levelname)s | %(message)s',
            handlers=[
                logging.FileHandler('/app/logs/trading.log'),
                logging.StreamHandler(sys.stdout)
            ]
        )
    
    def setup_signal_handlers(self):
        """ğŸ‡§ğŸ‡· Configurar handlers de sinal / ğŸ‡ºğŸ‡¸ Setup signal handlers"""
        signal.signal(signal.SIGINT, self.signal_handler)
        signal.signal(signal.SIGTERM, self.signal_handler)
    
    def signal_handler(self, signum, frame):
        """ğŸ‡§ğŸ‡· Handler para parada graceful / ğŸ‡ºğŸ‡¸ Graceful shutdown handler"""
        logging.info(f"Received signal {signum}. Shutting down gracefully...")
        self.is_running = False
    
    async def run(self):
        """ğŸ‡§ğŸ‡· Executar bot em produÃ§Ã£o / ğŸ‡ºğŸ‡¸ Run bot in production"""
        try:
            self.is_running = True
            # Sua lÃ³gica de trading aqui
            while self.is_running:
                await asyncio.sleep(1)
        except Exception as e:
            logging.error(f"Unexpected error: {e}")
            raise
        finally:
            logging.info("Bot stopped")

if __name__ == "__main__":
    bot = ProductionTradingBot()
    asyncio.run(bot.run())
```

## ğŸ¤ ContribuiÃ§Ã£o / Contributing

### ğŸ› ï¸ ConfiguraÃ§Ã£o de Desenvolvimento / Development Setup

```bash
# ğŸ‡§ğŸ‡· Clonar repositÃ³rio / ğŸ‡ºğŸ‡¸ Clone repository
git clone https://github.com/celiovmjr/iq-core.git
cd iq-core

# ğŸ‡§ğŸ‡· Criar ambiente virtual / ğŸ‡ºğŸ‡¸ Create virtual environment
python -m venv venv
source venv/bin/activate  # Linux/Mac
# venv\Scripts\activate   # Windows

# ğŸ‡§ğŸ‡· Instalar dependÃªncias de desenvolvimento / ğŸ‡ºğŸ‡¸ Install dev dependencies
pip install -e ".[dev]"

# ğŸ‡§ğŸ‡· Configurar pre-commit hooks / ğŸ‡ºğŸ‡¸ Setup pre-commit hooks
pre-commit install
```

### ğŸ“ PadrÃµes de CÃ³digo / Code Standards

```bash
# ğŸ‡§ğŸ‡· FormataÃ§Ã£o / ğŸ‡ºğŸ‡¸ Formatting
black iq_core/
isort iq_core/

# ğŸ‡§ğŸ‡· Linting / ğŸ‡ºğŸ‡¸ Linting
ruff check iq_core/
mypy iq_core/

# ğŸ‡§ğŸ‡· Testes / ğŸ‡ºğŸ‡¸ Tests
pytest --cov=iq_core
```

### ğŸ”„ Fluxo de ContribuiÃ§Ã£o / Contribution Flow

1. ğŸ´ **Fork** o repositÃ³rio / Fork the repository
2. ğŸŒ¿ **Criar branch** para sua feature / Create branch for your feature
3. âœ¨ **Implementar** mudanÃ§as / Implement changes
4. âœ… **Adicionar testes** / Add tests
5. ğŸ“ **Atualizar documentaÃ§Ã£o** / Update documentation
6. ğŸ” **Executar testes** / Run tests
7. ğŸ“¤ **Criar Pull Request** / Create Pull Request

## ğŸ“š Recursos Adicionais / Additional Resources

### ğŸ“– DocumentaÃ§Ã£o / Documentation
- [ğŸ‡§ğŸ‡· DocumentaÃ§Ã£o da API IQ Option](https://iq_core.com/api)
- [ğŸ‡ºğŸ‡¸ IQ Option API Documentation](https://iq_core.com/api)
- [ğŸ Python AsyncIO Guide](https://docs.python.org/3/library/asyncio.html)
- [ğŸ“Š TradingView API](https://www.tradingview.com/rest-api-spec/)

### ğŸ“ Tutoriais / Tutorials
- [ğŸ‡§ğŸ‡· Como criar um bot de trading](./docs/tutorial-bot.md)
- [ğŸ‡ºğŸ‡¸ How to create a trading bot](./docs/tutorial-bot-en.md)
- [ğŸ“ˆ AnÃ¡lise tÃ©cnica com Python](./docs/technical-analysis.md)
- [ğŸ¤– IntegraÃ§Ã£o com IA](./docs/ai-integration.md)

### ğŸ› ï¸ Ferramentas / Tools
- [ğŸ“Š TradingView](https://tradingview.com) - AnÃ¡lise tÃ©cnica
- [ğŸ¤– Google Gemini](https://ai.google.dev) - IA para anÃ¡lise
- [ğŸ“ˆ TA-Lib](https://ta-lib.org) - Indicadores tÃ©cnicos
- [ğŸ“Š Pandas](https://pandas.pydata.org) - AnÃ¡lise de dados

## â“ FAQ - Perguntas Frequentes / Frequently Asked Questions

### ğŸ‡§ğŸ‡· PortuguÃªs

**Q: Ã‰ seguro usar este sistema?**
A: Sim, o sistema usa prÃ¡ticas de seguranÃ§a modernas, incluindo autenticaÃ§Ã£o por token e nÃ£o armazena credenciais em texto plano.

**Q: Posso usar em conta real?**
A: Sim, mas recomendamos testar extensivamente em conta demo primeiro.

**Q: Qual a taxa de sucesso?**
A: A taxa de sucesso depende da sua estratÃ©gia. O sistema fornece ferramentas, mas nÃ£o garante lucros.

**Q: Como reportar bugs?**
A: Abra uma issue no GitHub com detalhes do problema e logs relevantes.

### ğŸ‡ºğŸ‡¸ English

**Q: Is this system safe to use?**
A: Yes, the system uses modern security practices, including token authentication and doesn't store credentials in plain text.

**Q: Can I use it with a real account?**
A: Yes, but we recommend extensive testing with a demo account first.

**Q: What's the success rate?**
A: Success rate depends on your strategy. The system provides tools but doesn't guarantee profits.

**Q: How to report bugs?**
A: Open a GitHub issue with problem details and relevant logs.

## ğŸ“„ LicenÃ§a / License

```
MIT License

Copyright (c) 2024 IQ Option Trading System

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
```

---

## ğŸ™ Agradecimentos / Acknowledgments

- ğŸ¢ **IQ Option** - Pela plataforma de trading
- ğŸ **Python Community** - Pelas excelentes bibliotecas
- ğŸ“Š **TradingView** - Pela API de anÃ¡lise tÃ©cnica
- ğŸ¤– **Google** - Pela API Gemini
- ğŸ‘¥ **Contributors** - Por todas as contribuiÃ§Ãµes

---

<div align="center">

### ğŸš€ Pronto para comeÃ§ar? / Ready to start?

```bash
pip install iq-core
```

**â­ Se este projeto foi Ãºtil, considere dar uma estrela no GitHub!**  
**â­ If this project was helpful, consider giving it a star on GitHub!**

[ğŸ“š DocumentaÃ§Ã£o](./docs/) | [ğŸ› Issues](./issues) | [ğŸ’¬ DiscussÃµes](./discussions)

</div>
