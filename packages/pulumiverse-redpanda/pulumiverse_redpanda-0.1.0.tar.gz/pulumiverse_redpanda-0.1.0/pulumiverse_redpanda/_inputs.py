# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities

__all__ = [
    'ClusterAwsPrivateLinkArgs',
    'ClusterAwsPrivateLinkArgsDict',
    'ClusterAwsPrivateLinkStatusArgs',
    'ClusterAwsPrivateLinkStatusArgsDict',
    'ClusterAwsPrivateLinkStatusVpcEndpointConnectionArgs',
    'ClusterAwsPrivateLinkStatusVpcEndpointConnectionArgsDict',
    'ClusterAwsPrivateLinkStatusVpcEndpointConnectionDnsEntryArgs',
    'ClusterAwsPrivateLinkStatusVpcEndpointConnectionDnsEntryArgsDict',
    'ClusterAzurePrivateLinkArgs',
    'ClusterAzurePrivateLinkArgsDict',
    'ClusterAzurePrivateLinkStatusArgs',
    'ClusterAzurePrivateLinkStatusArgsDict',
    'ClusterAzurePrivateLinkStatusPrivateEndpointConnectionArgs',
    'ClusterAzurePrivateLinkStatusPrivateEndpointConnectionArgsDict',
    'ClusterCustomerManagedResourcesArgs',
    'ClusterCustomerManagedResourcesArgsDict',
    'ClusterCustomerManagedResourcesAwsArgs',
    'ClusterCustomerManagedResourcesAwsArgsDict',
    'ClusterCustomerManagedResourcesAwsAgentInstanceProfileArgs',
    'ClusterCustomerManagedResourcesAwsAgentInstanceProfileArgsDict',
    'ClusterCustomerManagedResourcesAwsCloudStorageBucketArgs',
    'ClusterCustomerManagedResourcesAwsCloudStorageBucketArgsDict',
    'ClusterCustomerManagedResourcesAwsClusterSecurityGroupArgs',
    'ClusterCustomerManagedResourcesAwsClusterSecurityGroupArgsDict',
    'ClusterCustomerManagedResourcesAwsConnectorsNodeGroupInstanceProfileArgs',
    'ClusterCustomerManagedResourcesAwsConnectorsNodeGroupInstanceProfileArgsDict',
    'ClusterCustomerManagedResourcesAwsConnectorsSecurityGroupArgs',
    'ClusterCustomerManagedResourcesAwsConnectorsSecurityGroupArgsDict',
    'ClusterCustomerManagedResourcesAwsK8sClusterRoleArgs',
    'ClusterCustomerManagedResourcesAwsK8sClusterRoleArgsDict',
    'ClusterCustomerManagedResourcesAwsNodeSecurityGroupArgs',
    'ClusterCustomerManagedResourcesAwsNodeSecurityGroupArgsDict',
    'ClusterCustomerManagedResourcesAwsPermissionsBoundaryPolicyArgs',
    'ClusterCustomerManagedResourcesAwsPermissionsBoundaryPolicyArgsDict',
    'ClusterCustomerManagedResourcesAwsRedpandaAgentSecurityGroupArgs',
    'ClusterCustomerManagedResourcesAwsRedpandaAgentSecurityGroupArgsDict',
    'ClusterCustomerManagedResourcesAwsRedpandaNodeGroupInstanceProfileArgs',
    'ClusterCustomerManagedResourcesAwsRedpandaNodeGroupInstanceProfileArgsDict',
    'ClusterCustomerManagedResourcesAwsRedpandaNodeGroupSecurityGroupArgs',
    'ClusterCustomerManagedResourcesAwsRedpandaNodeGroupSecurityGroupArgsDict',
    'ClusterCustomerManagedResourcesAwsUtilityNodeGroupInstanceProfileArgs',
    'ClusterCustomerManagedResourcesAwsUtilityNodeGroupInstanceProfileArgsDict',
    'ClusterCustomerManagedResourcesAwsUtilitySecurityGroupArgs',
    'ClusterCustomerManagedResourcesAwsUtilitySecurityGroupArgsDict',
    'ClusterCustomerManagedResourcesGcpArgs',
    'ClusterCustomerManagedResourcesGcpArgsDict',
    'ClusterCustomerManagedResourcesGcpAgentServiceAccountArgs',
    'ClusterCustomerManagedResourcesGcpAgentServiceAccountArgsDict',
    'ClusterCustomerManagedResourcesGcpConnectorServiceAccountArgs',
    'ClusterCustomerManagedResourcesGcpConnectorServiceAccountArgsDict',
    'ClusterCustomerManagedResourcesGcpConsoleServiceAccountArgs',
    'ClusterCustomerManagedResourcesGcpConsoleServiceAccountArgsDict',
    'ClusterCustomerManagedResourcesGcpGkeServiceAccountArgs',
    'ClusterCustomerManagedResourcesGcpGkeServiceAccountArgsDict',
    'ClusterCustomerManagedResourcesGcpRedpandaClusterServiceAccountArgs',
    'ClusterCustomerManagedResourcesGcpRedpandaClusterServiceAccountArgsDict',
    'ClusterCustomerManagedResourcesGcpSubnetArgs',
    'ClusterCustomerManagedResourcesGcpSubnetArgsDict',
    'ClusterCustomerManagedResourcesGcpSubnetSecondaryIpv4RangePodsArgs',
    'ClusterCustomerManagedResourcesGcpSubnetSecondaryIpv4RangePodsArgsDict',
    'ClusterCustomerManagedResourcesGcpSubnetSecondaryIpv4RangeServicesArgs',
    'ClusterCustomerManagedResourcesGcpSubnetSecondaryIpv4RangeServicesArgsDict',
    'ClusterCustomerManagedResourcesGcpTieredStorageBucketArgs',
    'ClusterCustomerManagedResourcesGcpTieredStorageBucketArgsDict',
    'ClusterGcpPrivateServiceConnectArgs',
    'ClusterGcpPrivateServiceConnectArgsDict',
    'ClusterGcpPrivateServiceConnectConsumerAcceptListArgs',
    'ClusterGcpPrivateServiceConnectConsumerAcceptListArgsDict',
    'ClusterGcpPrivateServiceConnectStatusArgs',
    'ClusterGcpPrivateServiceConnectStatusArgsDict',
    'ClusterGcpPrivateServiceConnectStatusConnectedEndpointArgs',
    'ClusterGcpPrivateServiceConnectStatusConnectedEndpointArgsDict',
    'ClusterHttpProxyArgs',
    'ClusterHttpProxyArgsDict',
    'ClusterHttpProxyMtlsArgs',
    'ClusterHttpProxyMtlsArgsDict',
    'ClusterKafkaApiArgs',
    'ClusterKafkaApiArgsDict',
    'ClusterKafkaApiMtlsArgs',
    'ClusterKafkaApiMtlsArgsDict',
    'ClusterKafkaConnectArgs',
    'ClusterKafkaConnectArgsDict',
    'ClusterMaintenanceWindowConfigArgs',
    'ClusterMaintenanceWindowConfigArgsDict',
    'ClusterMaintenanceWindowConfigDayHourArgs',
    'ClusterMaintenanceWindowConfigDayHourArgsDict',
    'ClusterPrometheusArgs',
    'ClusterPrometheusArgsDict',
    'ClusterRedpandaConsoleArgs',
    'ClusterRedpandaConsoleArgsDict',
    'ClusterSchemaRegistryArgs',
    'ClusterSchemaRegistryArgsDict',
    'ClusterSchemaRegistryMtlsArgs',
    'ClusterSchemaRegistryMtlsArgsDict',
    'ClusterStateDescriptionArgs',
    'ClusterStateDescriptionArgsDict',
    'NetworkCustomerManagedResourcesArgs',
    'NetworkCustomerManagedResourcesArgsDict',
    'NetworkCustomerManagedResourcesAwsArgs',
    'NetworkCustomerManagedResourcesAwsArgsDict',
    'NetworkCustomerManagedResourcesAwsDynamodbTableArgs',
    'NetworkCustomerManagedResourcesAwsDynamodbTableArgsDict',
    'NetworkCustomerManagedResourcesAwsManagementBucketArgs',
    'NetworkCustomerManagedResourcesAwsManagementBucketArgsDict',
    'NetworkCustomerManagedResourcesAwsPrivateSubnetsArgs',
    'NetworkCustomerManagedResourcesAwsPrivateSubnetsArgsDict',
    'NetworkCustomerManagedResourcesAwsVpcArgs',
    'NetworkCustomerManagedResourcesAwsVpcArgsDict',
    'NetworkCustomerManagedResourcesGcpArgs',
    'NetworkCustomerManagedResourcesGcpArgsDict',
    'NetworkCustomerManagedResourcesGcpManagementBucketArgs',
    'NetworkCustomerManagedResourcesGcpManagementBucketArgsDict',
]

MYPY = False

if not MYPY:
    class ClusterAwsPrivateLinkArgsDict(TypedDict):
        allowed_principals: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        The ARN of the principals that can access the Redpanda AWS PrivateLink Endpoint Service. To grant permissions to all principals, use an asterisk (*).
        """
        connect_console: pulumi.Input[_builtins.bool]
        """
        Whether Console is connected via PrivateLink.
        """
        enabled: pulumi.Input[_builtins.bool]
        """
        Whether AWS PrivateLink is enabled.
        """
        status: NotRequired[pulumi.Input['ClusterAwsPrivateLinkStatusArgsDict']]
        """
        Current status of the PrivateLink configuration.
        """
elif False:
    ClusterAwsPrivateLinkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterAwsPrivateLinkArgs:
    def __init__(__self__, *,
                 allowed_principals: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 connect_console: pulumi.Input[_builtins.bool],
                 enabled: pulumi.Input[_builtins.bool],
                 status: Optional[pulumi.Input['ClusterAwsPrivateLinkStatusArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] allowed_principals: The ARN of the principals that can access the Redpanda AWS PrivateLink Endpoint Service. To grant permissions to all principals, use an asterisk (*).
        :param pulumi.Input[_builtins.bool] connect_console: Whether Console is connected via PrivateLink.
        :param pulumi.Input[_builtins.bool] enabled: Whether AWS PrivateLink is enabled.
        :param pulumi.Input['ClusterAwsPrivateLinkStatusArgs'] status: Current status of the PrivateLink configuration.
        """
        pulumi.set(__self__, "allowed_principals", allowed_principals)
        pulumi.set(__self__, "connect_console", connect_console)
        pulumi.set(__self__, "enabled", enabled)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter(name="allowedPrincipals")
    def allowed_principals(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        The ARN of the principals that can access the Redpanda AWS PrivateLink Endpoint Service. To grant permissions to all principals, use an asterisk (*).
        """
        return pulumi.get(self, "allowed_principals")

    @allowed_principals.setter
    def allowed_principals(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "allowed_principals", value)

    @_builtins.property
    @pulumi.getter(name="connectConsole")
    def connect_console(self) -> pulumi.Input[_builtins.bool]:
        """
        Whether Console is connected via PrivateLink.
        """
        return pulumi.get(self, "connect_console")

    @connect_console.setter
    def connect_console(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "connect_console", value)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        """
        Whether AWS PrivateLink is enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input['ClusterAwsPrivateLinkStatusArgs']]:
        """
        Current status of the PrivateLink configuration.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input['ClusterAwsPrivateLinkStatusArgs']]):
        pulumi.set(self, "status", value)


if not MYPY:
    class ClusterAwsPrivateLinkStatusArgsDict(TypedDict):
        console_port: NotRequired[pulumi.Input[_builtins.int]]
        """
        Port for Redpanda Console.
        """
        created_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        When the PrivateLink service was created.
        """
        deleted_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        When the PrivateLink service was deleted.
        """
        kafka_api_node_base_port: NotRequired[pulumi.Input[_builtins.int]]
        """
        Base port for Kafka API nodes.
        """
        kafka_api_seed_port: NotRequired[pulumi.Input[_builtins.int]]
        """
        Port for Kafka API seed brokers.
        """
        redpanda_proxy_node_base_port: NotRequired[pulumi.Input[_builtins.int]]
        """
        Base port for HTTP proxy nodes.
        """
        redpanda_proxy_seed_port: NotRequired[pulumi.Input[_builtins.int]]
        """
        Port for HTTP proxy.
        """
        schema_registry_seed_port: NotRequired[pulumi.Input[_builtins.int]]
        """
        Port for Schema Registry.
        """
        service_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The PrivateLink service ID.
        """
        service_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The PrivateLink service name.
        """
        service_state: NotRequired[pulumi.Input[_builtins.str]]
        """
        Current state of the PrivateLink service.
        """
        vpc_endpoint_connections: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterAwsPrivateLinkStatusVpcEndpointConnectionArgsDict']]]]
        """
        List of VPC endpoint connections.
        """
elif False:
    ClusterAwsPrivateLinkStatusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterAwsPrivateLinkStatusArgs:
    def __init__(__self__, *,
                 console_port: Optional[pulumi.Input[_builtins.int]] = None,
                 created_at: Optional[pulumi.Input[_builtins.str]] = None,
                 deleted_at: Optional[pulumi.Input[_builtins.str]] = None,
                 kafka_api_node_base_port: Optional[pulumi.Input[_builtins.int]] = None,
                 kafka_api_seed_port: Optional[pulumi.Input[_builtins.int]] = None,
                 redpanda_proxy_node_base_port: Optional[pulumi.Input[_builtins.int]] = None,
                 redpanda_proxy_seed_port: Optional[pulumi.Input[_builtins.int]] = None,
                 schema_registry_seed_port: Optional[pulumi.Input[_builtins.int]] = None,
                 service_id: Optional[pulumi.Input[_builtins.str]] = None,
                 service_name: Optional[pulumi.Input[_builtins.str]] = None,
                 service_state: Optional[pulumi.Input[_builtins.str]] = None,
                 vpc_endpoint_connections: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterAwsPrivateLinkStatusVpcEndpointConnectionArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.int] console_port: Port for Redpanda Console.
        :param pulumi.Input[_builtins.str] created_at: When the PrivateLink service was created.
        :param pulumi.Input[_builtins.str] deleted_at: When the PrivateLink service was deleted.
        :param pulumi.Input[_builtins.int] kafka_api_node_base_port: Base port for Kafka API nodes.
        :param pulumi.Input[_builtins.int] kafka_api_seed_port: Port for Kafka API seed brokers.
        :param pulumi.Input[_builtins.int] redpanda_proxy_node_base_port: Base port for HTTP proxy nodes.
        :param pulumi.Input[_builtins.int] redpanda_proxy_seed_port: Port for HTTP proxy.
        :param pulumi.Input[_builtins.int] schema_registry_seed_port: Port for Schema Registry.
        :param pulumi.Input[_builtins.str] service_id: The PrivateLink service ID.
        :param pulumi.Input[_builtins.str] service_name: The PrivateLink service name.
        :param pulumi.Input[_builtins.str] service_state: Current state of the PrivateLink service.
        :param pulumi.Input[Sequence[pulumi.Input['ClusterAwsPrivateLinkStatusVpcEndpointConnectionArgs']]] vpc_endpoint_connections: List of VPC endpoint connections.
        """
        if console_port is not None:
            pulumi.set(__self__, "console_port", console_port)
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if deleted_at is not None:
            pulumi.set(__self__, "deleted_at", deleted_at)
        if kafka_api_node_base_port is not None:
            pulumi.set(__self__, "kafka_api_node_base_port", kafka_api_node_base_port)
        if kafka_api_seed_port is not None:
            pulumi.set(__self__, "kafka_api_seed_port", kafka_api_seed_port)
        if redpanda_proxy_node_base_port is not None:
            pulumi.set(__self__, "redpanda_proxy_node_base_port", redpanda_proxy_node_base_port)
        if redpanda_proxy_seed_port is not None:
            pulumi.set(__self__, "redpanda_proxy_seed_port", redpanda_proxy_seed_port)
        if schema_registry_seed_port is not None:
            pulumi.set(__self__, "schema_registry_seed_port", schema_registry_seed_port)
        if service_id is not None:
            pulumi.set(__self__, "service_id", service_id)
        if service_name is not None:
            pulumi.set(__self__, "service_name", service_name)
        if service_state is not None:
            pulumi.set(__self__, "service_state", service_state)
        if vpc_endpoint_connections is not None:
            pulumi.set(__self__, "vpc_endpoint_connections", vpc_endpoint_connections)

    @_builtins.property
    @pulumi.getter(name="consolePort")
    def console_port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Port for Redpanda Console.
        """
        return pulumi.get(self, "console_port")

    @console_port.setter
    def console_port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "console_port", value)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        When the PrivateLink service was created.
        """
        return pulumi.get(self, "created_at")

    @created_at.setter
    def created_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_at", value)

    @_builtins.property
    @pulumi.getter(name="deletedAt")
    def deleted_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        When the PrivateLink service was deleted.
        """
        return pulumi.get(self, "deleted_at")

    @deleted_at.setter
    def deleted_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "deleted_at", value)

    @_builtins.property
    @pulumi.getter(name="kafkaApiNodeBasePort")
    def kafka_api_node_base_port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Base port for Kafka API nodes.
        """
        return pulumi.get(self, "kafka_api_node_base_port")

    @kafka_api_node_base_port.setter
    def kafka_api_node_base_port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "kafka_api_node_base_port", value)

    @_builtins.property
    @pulumi.getter(name="kafkaApiSeedPort")
    def kafka_api_seed_port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Port for Kafka API seed brokers.
        """
        return pulumi.get(self, "kafka_api_seed_port")

    @kafka_api_seed_port.setter
    def kafka_api_seed_port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "kafka_api_seed_port", value)

    @_builtins.property
    @pulumi.getter(name="redpandaProxyNodeBasePort")
    def redpanda_proxy_node_base_port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Base port for HTTP proxy nodes.
        """
        return pulumi.get(self, "redpanda_proxy_node_base_port")

    @redpanda_proxy_node_base_port.setter
    def redpanda_proxy_node_base_port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "redpanda_proxy_node_base_port", value)

    @_builtins.property
    @pulumi.getter(name="redpandaProxySeedPort")
    def redpanda_proxy_seed_port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Port for HTTP proxy.
        """
        return pulumi.get(self, "redpanda_proxy_seed_port")

    @redpanda_proxy_seed_port.setter
    def redpanda_proxy_seed_port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "redpanda_proxy_seed_port", value)

    @_builtins.property
    @pulumi.getter(name="schemaRegistrySeedPort")
    def schema_registry_seed_port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Port for Schema Registry.
        """
        return pulumi.get(self, "schema_registry_seed_port")

    @schema_registry_seed_port.setter
    def schema_registry_seed_port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "schema_registry_seed_port", value)

    @_builtins.property
    @pulumi.getter(name="serviceId")
    def service_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The PrivateLink service ID.
        """
        return pulumi.get(self, "service_id")

    @service_id.setter
    def service_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "service_id", value)

    @_builtins.property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The PrivateLink service name.
        """
        return pulumi.get(self, "service_name")

    @service_name.setter
    def service_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "service_name", value)

    @_builtins.property
    @pulumi.getter(name="serviceState")
    def service_state(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Current state of the PrivateLink service.
        """
        return pulumi.get(self, "service_state")

    @service_state.setter
    def service_state(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "service_state", value)

    @_builtins.property
    @pulumi.getter(name="vpcEndpointConnections")
    def vpc_endpoint_connections(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterAwsPrivateLinkStatusVpcEndpointConnectionArgs']]]]:
        """
        List of VPC endpoint connections.
        """
        return pulumi.get(self, "vpc_endpoint_connections")

    @vpc_endpoint_connections.setter
    def vpc_endpoint_connections(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterAwsPrivateLinkStatusVpcEndpointConnectionArgs']]]]):
        pulumi.set(self, "vpc_endpoint_connections", value)


if not MYPY:
    class ClusterAwsPrivateLinkStatusVpcEndpointConnectionArgsDict(TypedDict):
        connection_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The connection ID.
        """
        created_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        When the endpoint connection was created.
        """
        dns_entries: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterAwsPrivateLinkStatusVpcEndpointConnectionDnsEntryArgsDict']]]]
        """
        DNS entries for the endpoint.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The endpoint connection ID.
        """
        load_balancer_arns: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        ARNs of associated load balancers.
        """
        owner: NotRequired[pulumi.Input[_builtins.str]]
        """
        Owner of the endpoint connection.
        """
        state: NotRequired[pulumi.Input[_builtins.str]]
        """
        State of the endpoint connection.
        """
elif False:
    ClusterAwsPrivateLinkStatusVpcEndpointConnectionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterAwsPrivateLinkStatusVpcEndpointConnectionArgs:
    def __init__(__self__, *,
                 connection_id: Optional[pulumi.Input[_builtins.str]] = None,
                 created_at: Optional[pulumi.Input[_builtins.str]] = None,
                 dns_entries: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterAwsPrivateLinkStatusVpcEndpointConnectionDnsEntryArgs']]]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 load_balancer_arns: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 owner: Optional[pulumi.Input[_builtins.str]] = None,
                 state: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] connection_id: The connection ID.
        :param pulumi.Input[_builtins.str] created_at: When the endpoint connection was created.
        :param pulumi.Input[Sequence[pulumi.Input['ClusterAwsPrivateLinkStatusVpcEndpointConnectionDnsEntryArgs']]] dns_entries: DNS entries for the endpoint.
        :param pulumi.Input[_builtins.str] id: The endpoint connection ID.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] load_balancer_arns: ARNs of associated load balancers.
        :param pulumi.Input[_builtins.str] owner: Owner of the endpoint connection.
        :param pulumi.Input[_builtins.str] state: State of the endpoint connection.
        """
        if connection_id is not None:
            pulumi.set(__self__, "connection_id", connection_id)
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if dns_entries is not None:
            pulumi.set(__self__, "dns_entries", dns_entries)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if load_balancer_arns is not None:
            pulumi.set(__self__, "load_balancer_arns", load_balancer_arns)
        if owner is not None:
            pulumi.set(__self__, "owner", owner)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter(name="connectionId")
    def connection_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The connection ID.
        """
        return pulumi.get(self, "connection_id")

    @connection_id.setter
    def connection_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "connection_id", value)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        When the endpoint connection was created.
        """
        return pulumi.get(self, "created_at")

    @created_at.setter
    def created_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_at", value)

    @_builtins.property
    @pulumi.getter(name="dnsEntries")
    def dns_entries(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterAwsPrivateLinkStatusVpcEndpointConnectionDnsEntryArgs']]]]:
        """
        DNS entries for the endpoint.
        """
        return pulumi.get(self, "dns_entries")

    @dns_entries.setter
    def dns_entries(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterAwsPrivateLinkStatusVpcEndpointConnectionDnsEntryArgs']]]]):
        pulumi.set(self, "dns_entries", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The endpoint connection ID.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="loadBalancerArns")
    def load_balancer_arns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        ARNs of associated load balancers.
        """
        return pulumi.get(self, "load_balancer_arns")

    @load_balancer_arns.setter
    def load_balancer_arns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "load_balancer_arns", value)

    @_builtins.property
    @pulumi.getter
    def owner(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Owner of the endpoint connection.
        """
        return pulumi.get(self, "owner")

    @owner.setter
    def owner(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "owner", value)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        State of the endpoint connection.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "state", value)


if not MYPY:
    class ClusterAwsPrivateLinkStatusVpcEndpointConnectionDnsEntryArgsDict(TypedDict):
        dns_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The DNS name.
        """
        hosted_zone_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The hosted zone ID.
        """
elif False:
    ClusterAwsPrivateLinkStatusVpcEndpointConnectionDnsEntryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterAwsPrivateLinkStatusVpcEndpointConnectionDnsEntryArgs:
    def __init__(__self__, *,
                 dns_name: Optional[pulumi.Input[_builtins.str]] = None,
                 hosted_zone_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] dns_name: The DNS name.
        :param pulumi.Input[_builtins.str] hosted_zone_id: The hosted zone ID.
        """
        if dns_name is not None:
            pulumi.set(__self__, "dns_name", dns_name)
        if hosted_zone_id is not None:
            pulumi.set(__self__, "hosted_zone_id", hosted_zone_id)

    @_builtins.property
    @pulumi.getter(name="dnsName")
    def dns_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The DNS name.
        """
        return pulumi.get(self, "dns_name")

    @dns_name.setter
    def dns_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dns_name", value)

    @_builtins.property
    @pulumi.getter(name="hostedZoneId")
    def hosted_zone_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The hosted zone ID.
        """
        return pulumi.get(self, "hosted_zone_id")

    @hosted_zone_id.setter
    def hosted_zone_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "hosted_zone_id", value)


if not MYPY:
    class ClusterAzurePrivateLinkArgsDict(TypedDict):
        allowed_subscriptions: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        The subscriptions that can access the Redpanda Azure PrivateLink Endpoint Service. To grant permissions to all principals, use an asterisk (*).
        """
        connect_console: pulumi.Input[_builtins.bool]
        """
        Whether Console is connected in Redpanda Azure Private Link Service.
        """
        enabled: pulumi.Input[_builtins.bool]
        """
        Whether Redpanda Azure Private Link Endpoint Service is enabled.
        """
        status: NotRequired[pulumi.Input['ClusterAzurePrivateLinkStatusArgsDict']]
        """
        Current status of the Private Link configuration.
        """
elif False:
    ClusterAzurePrivateLinkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterAzurePrivateLinkArgs:
    def __init__(__self__, *,
                 allowed_subscriptions: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 connect_console: pulumi.Input[_builtins.bool],
                 enabled: pulumi.Input[_builtins.bool],
                 status: Optional[pulumi.Input['ClusterAzurePrivateLinkStatusArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] allowed_subscriptions: The subscriptions that can access the Redpanda Azure PrivateLink Endpoint Service. To grant permissions to all principals, use an asterisk (*).
        :param pulumi.Input[_builtins.bool] connect_console: Whether Console is connected in Redpanda Azure Private Link Service.
        :param pulumi.Input[_builtins.bool] enabled: Whether Redpanda Azure Private Link Endpoint Service is enabled.
        :param pulumi.Input['ClusterAzurePrivateLinkStatusArgs'] status: Current status of the Private Link configuration.
        """
        pulumi.set(__self__, "allowed_subscriptions", allowed_subscriptions)
        pulumi.set(__self__, "connect_console", connect_console)
        pulumi.set(__self__, "enabled", enabled)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter(name="allowedSubscriptions")
    def allowed_subscriptions(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        The subscriptions that can access the Redpanda Azure PrivateLink Endpoint Service. To grant permissions to all principals, use an asterisk (*).
        """
        return pulumi.get(self, "allowed_subscriptions")

    @allowed_subscriptions.setter
    def allowed_subscriptions(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "allowed_subscriptions", value)

    @_builtins.property
    @pulumi.getter(name="connectConsole")
    def connect_console(self) -> pulumi.Input[_builtins.bool]:
        """
        Whether Console is connected in Redpanda Azure Private Link Service.
        """
        return pulumi.get(self, "connect_console")

    @connect_console.setter
    def connect_console(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "connect_console", value)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        """
        Whether Redpanda Azure Private Link Endpoint Service is enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input['ClusterAzurePrivateLinkStatusArgs']]:
        """
        Current status of the Private Link configuration.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input['ClusterAzurePrivateLinkStatusArgs']]):
        pulumi.set(self, "status", value)


if not MYPY:
    class ClusterAzurePrivateLinkStatusArgsDict(TypedDict):
        approved_subscriptions: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of approved Azure subscription IDs.
        """
        console_port: NotRequired[pulumi.Input[_builtins.int]]
        """
        Port for Redpanda Console.
        """
        created_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        When the Private Link service was created.
        """
        deleted_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        When the Private Link service was deleted.
        """
        dns_a_record: NotRequired[pulumi.Input[_builtins.str]]
        """
        DNS A record for the service.
        """
        kafka_api_node_base_port: NotRequired[pulumi.Input[_builtins.int]]
        """
        Base port for Kafka API nodes.
        """
        kafka_api_seed_port: NotRequired[pulumi.Input[_builtins.int]]
        """
        Port for Kafka API seed brokers.
        """
        private_endpoint_connections: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterAzurePrivateLinkStatusPrivateEndpointConnectionArgsDict']]]]
        """
        List of private endpoint connections.
        """
        redpanda_proxy_node_base_port: NotRequired[pulumi.Input[_builtins.int]]
        """
        Base port for HTTP proxy nodes.
        """
        redpanda_proxy_seed_port: NotRequired[pulumi.Input[_builtins.int]]
        """
        Port for HTTP proxy.
        """
        schema_registry_seed_port: NotRequired[pulumi.Input[_builtins.int]]
        """
        Port for Schema Registry.
        """
        service_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Private Link service ID.
        """
        service_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Private Link service name.
        """
elif False:
    ClusterAzurePrivateLinkStatusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterAzurePrivateLinkStatusArgs:
    def __init__(__self__, *,
                 approved_subscriptions: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 console_port: Optional[pulumi.Input[_builtins.int]] = None,
                 created_at: Optional[pulumi.Input[_builtins.str]] = None,
                 deleted_at: Optional[pulumi.Input[_builtins.str]] = None,
                 dns_a_record: Optional[pulumi.Input[_builtins.str]] = None,
                 kafka_api_node_base_port: Optional[pulumi.Input[_builtins.int]] = None,
                 kafka_api_seed_port: Optional[pulumi.Input[_builtins.int]] = None,
                 private_endpoint_connections: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterAzurePrivateLinkStatusPrivateEndpointConnectionArgs']]]] = None,
                 redpanda_proxy_node_base_port: Optional[pulumi.Input[_builtins.int]] = None,
                 redpanda_proxy_seed_port: Optional[pulumi.Input[_builtins.int]] = None,
                 schema_registry_seed_port: Optional[pulumi.Input[_builtins.int]] = None,
                 service_id: Optional[pulumi.Input[_builtins.str]] = None,
                 service_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] approved_subscriptions: List of approved Azure subscription IDs.
        :param pulumi.Input[_builtins.int] console_port: Port for Redpanda Console.
        :param pulumi.Input[_builtins.str] created_at: When the Private Link service was created.
        :param pulumi.Input[_builtins.str] deleted_at: When the Private Link service was deleted.
        :param pulumi.Input[_builtins.str] dns_a_record: DNS A record for the service.
        :param pulumi.Input[_builtins.int] kafka_api_node_base_port: Base port for Kafka API nodes.
        :param pulumi.Input[_builtins.int] kafka_api_seed_port: Port for Kafka API seed brokers.
        :param pulumi.Input[Sequence[pulumi.Input['ClusterAzurePrivateLinkStatusPrivateEndpointConnectionArgs']]] private_endpoint_connections: List of private endpoint connections.
        :param pulumi.Input[_builtins.int] redpanda_proxy_node_base_port: Base port for HTTP proxy nodes.
        :param pulumi.Input[_builtins.int] redpanda_proxy_seed_port: Port for HTTP proxy.
        :param pulumi.Input[_builtins.int] schema_registry_seed_port: Port for Schema Registry.
        :param pulumi.Input[_builtins.str] service_id: The Private Link service ID.
        :param pulumi.Input[_builtins.str] service_name: The Private Link service name.
        """
        if approved_subscriptions is not None:
            pulumi.set(__self__, "approved_subscriptions", approved_subscriptions)
        if console_port is not None:
            pulumi.set(__self__, "console_port", console_port)
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if deleted_at is not None:
            pulumi.set(__self__, "deleted_at", deleted_at)
        if dns_a_record is not None:
            pulumi.set(__self__, "dns_a_record", dns_a_record)
        if kafka_api_node_base_port is not None:
            pulumi.set(__self__, "kafka_api_node_base_port", kafka_api_node_base_port)
        if kafka_api_seed_port is not None:
            pulumi.set(__self__, "kafka_api_seed_port", kafka_api_seed_port)
        if private_endpoint_connections is not None:
            pulumi.set(__self__, "private_endpoint_connections", private_endpoint_connections)
        if redpanda_proxy_node_base_port is not None:
            pulumi.set(__self__, "redpanda_proxy_node_base_port", redpanda_proxy_node_base_port)
        if redpanda_proxy_seed_port is not None:
            pulumi.set(__self__, "redpanda_proxy_seed_port", redpanda_proxy_seed_port)
        if schema_registry_seed_port is not None:
            pulumi.set(__self__, "schema_registry_seed_port", schema_registry_seed_port)
        if service_id is not None:
            pulumi.set(__self__, "service_id", service_id)
        if service_name is not None:
            pulumi.set(__self__, "service_name", service_name)

    @_builtins.property
    @pulumi.getter(name="approvedSubscriptions")
    def approved_subscriptions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of approved Azure subscription IDs.
        """
        return pulumi.get(self, "approved_subscriptions")

    @approved_subscriptions.setter
    def approved_subscriptions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "approved_subscriptions", value)

    @_builtins.property
    @pulumi.getter(name="consolePort")
    def console_port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Port for Redpanda Console.
        """
        return pulumi.get(self, "console_port")

    @console_port.setter
    def console_port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "console_port", value)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        When the Private Link service was created.
        """
        return pulumi.get(self, "created_at")

    @created_at.setter
    def created_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_at", value)

    @_builtins.property
    @pulumi.getter(name="deletedAt")
    def deleted_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        When the Private Link service was deleted.
        """
        return pulumi.get(self, "deleted_at")

    @deleted_at.setter
    def deleted_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "deleted_at", value)

    @_builtins.property
    @pulumi.getter(name="dnsARecord")
    def dns_a_record(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        DNS A record for the service.
        """
        return pulumi.get(self, "dns_a_record")

    @dns_a_record.setter
    def dns_a_record(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dns_a_record", value)

    @_builtins.property
    @pulumi.getter(name="kafkaApiNodeBasePort")
    def kafka_api_node_base_port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Base port for Kafka API nodes.
        """
        return pulumi.get(self, "kafka_api_node_base_port")

    @kafka_api_node_base_port.setter
    def kafka_api_node_base_port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "kafka_api_node_base_port", value)

    @_builtins.property
    @pulumi.getter(name="kafkaApiSeedPort")
    def kafka_api_seed_port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Port for Kafka API seed brokers.
        """
        return pulumi.get(self, "kafka_api_seed_port")

    @kafka_api_seed_port.setter
    def kafka_api_seed_port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "kafka_api_seed_port", value)

    @_builtins.property
    @pulumi.getter(name="privateEndpointConnections")
    def private_endpoint_connections(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterAzurePrivateLinkStatusPrivateEndpointConnectionArgs']]]]:
        """
        List of private endpoint connections.
        """
        return pulumi.get(self, "private_endpoint_connections")

    @private_endpoint_connections.setter
    def private_endpoint_connections(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterAzurePrivateLinkStatusPrivateEndpointConnectionArgs']]]]):
        pulumi.set(self, "private_endpoint_connections", value)

    @_builtins.property
    @pulumi.getter(name="redpandaProxyNodeBasePort")
    def redpanda_proxy_node_base_port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Base port for HTTP proxy nodes.
        """
        return pulumi.get(self, "redpanda_proxy_node_base_port")

    @redpanda_proxy_node_base_port.setter
    def redpanda_proxy_node_base_port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "redpanda_proxy_node_base_port", value)

    @_builtins.property
    @pulumi.getter(name="redpandaProxySeedPort")
    def redpanda_proxy_seed_port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Port for HTTP proxy.
        """
        return pulumi.get(self, "redpanda_proxy_seed_port")

    @redpanda_proxy_seed_port.setter
    def redpanda_proxy_seed_port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "redpanda_proxy_seed_port", value)

    @_builtins.property
    @pulumi.getter(name="schemaRegistrySeedPort")
    def schema_registry_seed_port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Port for Schema Registry.
        """
        return pulumi.get(self, "schema_registry_seed_port")

    @schema_registry_seed_port.setter
    def schema_registry_seed_port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "schema_registry_seed_port", value)

    @_builtins.property
    @pulumi.getter(name="serviceId")
    def service_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Private Link service ID.
        """
        return pulumi.get(self, "service_id")

    @service_id.setter
    def service_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "service_id", value)

    @_builtins.property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Private Link service name.
        """
        return pulumi.get(self, "service_name")

    @service_name.setter
    def service_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "service_name", value)


if not MYPY:
    class ClusterAzurePrivateLinkStatusPrivateEndpointConnectionArgsDict(TypedDict):
        connection_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the connection.
        """
        connection_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the connection.
        """
        created_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        When the endpoint connection was created.
        """
        private_endpoint_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the private endpoint.
        """
        private_endpoint_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the private endpoint.
        """
        status: NotRequired[pulumi.Input[_builtins.str]]
        """
        Status of the endpoint connection.
        """
elif False:
    ClusterAzurePrivateLinkStatusPrivateEndpointConnectionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterAzurePrivateLinkStatusPrivateEndpointConnectionArgs:
    def __init__(__self__, *,
                 connection_id: Optional[pulumi.Input[_builtins.str]] = None,
                 connection_name: Optional[pulumi.Input[_builtins.str]] = None,
                 created_at: Optional[pulumi.Input[_builtins.str]] = None,
                 private_endpoint_id: Optional[pulumi.Input[_builtins.str]] = None,
                 private_endpoint_name: Optional[pulumi.Input[_builtins.str]] = None,
                 status: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] connection_id: ID of the connection.
        :param pulumi.Input[_builtins.str] connection_name: Name of the connection.
        :param pulumi.Input[_builtins.str] created_at: When the endpoint connection was created.
        :param pulumi.Input[_builtins.str] private_endpoint_id: ID of the private endpoint.
        :param pulumi.Input[_builtins.str] private_endpoint_name: Name of the private endpoint.
        :param pulumi.Input[_builtins.str] status: Status of the endpoint connection.
        """
        if connection_id is not None:
            pulumi.set(__self__, "connection_id", connection_id)
        if connection_name is not None:
            pulumi.set(__self__, "connection_name", connection_name)
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if private_endpoint_id is not None:
            pulumi.set(__self__, "private_endpoint_id", private_endpoint_id)
        if private_endpoint_name is not None:
            pulumi.set(__self__, "private_endpoint_name", private_endpoint_name)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter(name="connectionId")
    def connection_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the connection.
        """
        return pulumi.get(self, "connection_id")

    @connection_id.setter
    def connection_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "connection_id", value)

    @_builtins.property
    @pulumi.getter(name="connectionName")
    def connection_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the connection.
        """
        return pulumi.get(self, "connection_name")

    @connection_name.setter
    def connection_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "connection_name", value)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        When the endpoint connection was created.
        """
        return pulumi.get(self, "created_at")

    @created_at.setter
    def created_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_at", value)

    @_builtins.property
    @pulumi.getter(name="privateEndpointId")
    def private_endpoint_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the private endpoint.
        """
        return pulumi.get(self, "private_endpoint_id")

    @private_endpoint_id.setter
    def private_endpoint_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "private_endpoint_id", value)

    @_builtins.property
    @pulumi.getter(name="privateEndpointName")
    def private_endpoint_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the private endpoint.
        """
        return pulumi.get(self, "private_endpoint_name")

    @private_endpoint_name.setter
    def private_endpoint_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "private_endpoint_name", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Status of the endpoint connection.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status", value)


if not MYPY:
    class ClusterCustomerManagedResourcesArgsDict(TypedDict):
        aws: NotRequired[pulumi.Input['ClusterCustomerManagedResourcesAwsArgsDict']]
        gcp: NotRequired[pulumi.Input['ClusterCustomerManagedResourcesGcpArgsDict']]
elif False:
    ClusterCustomerManagedResourcesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterCustomerManagedResourcesArgs:
    def __init__(__self__, *,
                 aws: Optional[pulumi.Input['ClusterCustomerManagedResourcesAwsArgs']] = None,
                 gcp: Optional[pulumi.Input['ClusterCustomerManagedResourcesGcpArgs']] = None):
        if aws is not None:
            pulumi.set(__self__, "aws", aws)
        if gcp is not None:
            pulumi.set(__self__, "gcp", gcp)

    @_builtins.property
    @pulumi.getter
    def aws(self) -> Optional[pulumi.Input['ClusterCustomerManagedResourcesAwsArgs']]:
        return pulumi.get(self, "aws")

    @aws.setter
    def aws(self, value: Optional[pulumi.Input['ClusterCustomerManagedResourcesAwsArgs']]):
        pulumi.set(self, "aws", value)

    @_builtins.property
    @pulumi.getter
    def gcp(self) -> Optional[pulumi.Input['ClusterCustomerManagedResourcesGcpArgs']]:
        return pulumi.get(self, "gcp")

    @gcp.setter
    def gcp(self, value: Optional[pulumi.Input['ClusterCustomerManagedResourcesGcpArgs']]):
        pulumi.set(self, "gcp", value)


if not MYPY:
    class ClusterCustomerManagedResourcesAwsArgsDict(TypedDict):
        agent_instance_profile: pulumi.Input['ClusterCustomerManagedResourcesAwsAgentInstanceProfileArgsDict']
        cloud_storage_bucket: pulumi.Input['ClusterCustomerManagedResourcesAwsCloudStorageBucketArgsDict']
        cluster_security_group: pulumi.Input['ClusterCustomerManagedResourcesAwsClusterSecurityGroupArgsDict']
        connectors_node_group_instance_profile: pulumi.Input['ClusterCustomerManagedResourcesAwsConnectorsNodeGroupInstanceProfileArgsDict']
        connectors_security_group: pulumi.Input['ClusterCustomerManagedResourcesAwsConnectorsSecurityGroupArgsDict']
        k8s_cluster_role: pulumi.Input['ClusterCustomerManagedResourcesAwsK8sClusterRoleArgsDict']
        node_security_group: pulumi.Input['ClusterCustomerManagedResourcesAwsNodeSecurityGroupArgsDict']
        permissions_boundary_policy: pulumi.Input['ClusterCustomerManagedResourcesAwsPermissionsBoundaryPolicyArgsDict']
        redpanda_agent_security_group: pulumi.Input['ClusterCustomerManagedResourcesAwsRedpandaAgentSecurityGroupArgsDict']
        redpanda_node_group_instance_profile: pulumi.Input['ClusterCustomerManagedResourcesAwsRedpandaNodeGroupInstanceProfileArgsDict']
        redpanda_node_group_security_group: pulumi.Input['ClusterCustomerManagedResourcesAwsRedpandaNodeGroupSecurityGroupArgsDict']
        utility_node_group_instance_profile: pulumi.Input['ClusterCustomerManagedResourcesAwsUtilityNodeGroupInstanceProfileArgsDict']
        utility_security_group: pulumi.Input['ClusterCustomerManagedResourcesAwsUtilitySecurityGroupArgsDict']
elif False:
    ClusterCustomerManagedResourcesAwsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterCustomerManagedResourcesAwsArgs:
    def __init__(__self__, *,
                 agent_instance_profile: pulumi.Input['ClusterCustomerManagedResourcesAwsAgentInstanceProfileArgs'],
                 cloud_storage_bucket: pulumi.Input['ClusterCustomerManagedResourcesAwsCloudStorageBucketArgs'],
                 cluster_security_group: pulumi.Input['ClusterCustomerManagedResourcesAwsClusterSecurityGroupArgs'],
                 connectors_node_group_instance_profile: pulumi.Input['ClusterCustomerManagedResourcesAwsConnectorsNodeGroupInstanceProfileArgs'],
                 connectors_security_group: pulumi.Input['ClusterCustomerManagedResourcesAwsConnectorsSecurityGroupArgs'],
                 k8s_cluster_role: pulumi.Input['ClusterCustomerManagedResourcesAwsK8sClusterRoleArgs'],
                 node_security_group: pulumi.Input['ClusterCustomerManagedResourcesAwsNodeSecurityGroupArgs'],
                 permissions_boundary_policy: pulumi.Input['ClusterCustomerManagedResourcesAwsPermissionsBoundaryPolicyArgs'],
                 redpanda_agent_security_group: pulumi.Input['ClusterCustomerManagedResourcesAwsRedpandaAgentSecurityGroupArgs'],
                 redpanda_node_group_instance_profile: pulumi.Input['ClusterCustomerManagedResourcesAwsRedpandaNodeGroupInstanceProfileArgs'],
                 redpanda_node_group_security_group: pulumi.Input['ClusterCustomerManagedResourcesAwsRedpandaNodeGroupSecurityGroupArgs'],
                 utility_node_group_instance_profile: pulumi.Input['ClusterCustomerManagedResourcesAwsUtilityNodeGroupInstanceProfileArgs'],
                 utility_security_group: pulumi.Input['ClusterCustomerManagedResourcesAwsUtilitySecurityGroupArgs']):
        pulumi.set(__self__, "agent_instance_profile", agent_instance_profile)
        pulumi.set(__self__, "cloud_storage_bucket", cloud_storage_bucket)
        pulumi.set(__self__, "cluster_security_group", cluster_security_group)
        pulumi.set(__self__, "connectors_node_group_instance_profile", connectors_node_group_instance_profile)
        pulumi.set(__self__, "connectors_security_group", connectors_security_group)
        pulumi.set(__self__, "k8s_cluster_role", k8s_cluster_role)
        pulumi.set(__self__, "node_security_group", node_security_group)
        pulumi.set(__self__, "permissions_boundary_policy", permissions_boundary_policy)
        pulumi.set(__self__, "redpanda_agent_security_group", redpanda_agent_security_group)
        pulumi.set(__self__, "redpanda_node_group_instance_profile", redpanda_node_group_instance_profile)
        pulumi.set(__self__, "redpanda_node_group_security_group", redpanda_node_group_security_group)
        pulumi.set(__self__, "utility_node_group_instance_profile", utility_node_group_instance_profile)
        pulumi.set(__self__, "utility_security_group", utility_security_group)

    @_builtins.property
    @pulumi.getter(name="agentInstanceProfile")
    def agent_instance_profile(self) -> pulumi.Input['ClusterCustomerManagedResourcesAwsAgentInstanceProfileArgs']:
        return pulumi.get(self, "agent_instance_profile")

    @agent_instance_profile.setter
    def agent_instance_profile(self, value: pulumi.Input['ClusterCustomerManagedResourcesAwsAgentInstanceProfileArgs']):
        pulumi.set(self, "agent_instance_profile", value)

    @_builtins.property
    @pulumi.getter(name="cloudStorageBucket")
    def cloud_storage_bucket(self) -> pulumi.Input['ClusterCustomerManagedResourcesAwsCloudStorageBucketArgs']:
        return pulumi.get(self, "cloud_storage_bucket")

    @cloud_storage_bucket.setter
    def cloud_storage_bucket(self, value: pulumi.Input['ClusterCustomerManagedResourcesAwsCloudStorageBucketArgs']):
        pulumi.set(self, "cloud_storage_bucket", value)

    @_builtins.property
    @pulumi.getter(name="clusterSecurityGroup")
    def cluster_security_group(self) -> pulumi.Input['ClusterCustomerManagedResourcesAwsClusterSecurityGroupArgs']:
        return pulumi.get(self, "cluster_security_group")

    @cluster_security_group.setter
    def cluster_security_group(self, value: pulumi.Input['ClusterCustomerManagedResourcesAwsClusterSecurityGroupArgs']):
        pulumi.set(self, "cluster_security_group", value)

    @_builtins.property
    @pulumi.getter(name="connectorsNodeGroupInstanceProfile")
    def connectors_node_group_instance_profile(self) -> pulumi.Input['ClusterCustomerManagedResourcesAwsConnectorsNodeGroupInstanceProfileArgs']:
        return pulumi.get(self, "connectors_node_group_instance_profile")

    @connectors_node_group_instance_profile.setter
    def connectors_node_group_instance_profile(self, value: pulumi.Input['ClusterCustomerManagedResourcesAwsConnectorsNodeGroupInstanceProfileArgs']):
        pulumi.set(self, "connectors_node_group_instance_profile", value)

    @_builtins.property
    @pulumi.getter(name="connectorsSecurityGroup")
    def connectors_security_group(self) -> pulumi.Input['ClusterCustomerManagedResourcesAwsConnectorsSecurityGroupArgs']:
        return pulumi.get(self, "connectors_security_group")

    @connectors_security_group.setter
    def connectors_security_group(self, value: pulumi.Input['ClusterCustomerManagedResourcesAwsConnectorsSecurityGroupArgs']):
        pulumi.set(self, "connectors_security_group", value)

    @_builtins.property
    @pulumi.getter(name="k8sClusterRole")
    def k8s_cluster_role(self) -> pulumi.Input['ClusterCustomerManagedResourcesAwsK8sClusterRoleArgs']:
        return pulumi.get(self, "k8s_cluster_role")

    @k8s_cluster_role.setter
    def k8s_cluster_role(self, value: pulumi.Input['ClusterCustomerManagedResourcesAwsK8sClusterRoleArgs']):
        pulumi.set(self, "k8s_cluster_role", value)

    @_builtins.property
    @pulumi.getter(name="nodeSecurityGroup")
    def node_security_group(self) -> pulumi.Input['ClusterCustomerManagedResourcesAwsNodeSecurityGroupArgs']:
        return pulumi.get(self, "node_security_group")

    @node_security_group.setter
    def node_security_group(self, value: pulumi.Input['ClusterCustomerManagedResourcesAwsNodeSecurityGroupArgs']):
        pulumi.set(self, "node_security_group", value)

    @_builtins.property
    @pulumi.getter(name="permissionsBoundaryPolicy")
    def permissions_boundary_policy(self) -> pulumi.Input['ClusterCustomerManagedResourcesAwsPermissionsBoundaryPolicyArgs']:
        return pulumi.get(self, "permissions_boundary_policy")

    @permissions_boundary_policy.setter
    def permissions_boundary_policy(self, value: pulumi.Input['ClusterCustomerManagedResourcesAwsPermissionsBoundaryPolicyArgs']):
        pulumi.set(self, "permissions_boundary_policy", value)

    @_builtins.property
    @pulumi.getter(name="redpandaAgentSecurityGroup")
    def redpanda_agent_security_group(self) -> pulumi.Input['ClusterCustomerManagedResourcesAwsRedpandaAgentSecurityGroupArgs']:
        return pulumi.get(self, "redpanda_agent_security_group")

    @redpanda_agent_security_group.setter
    def redpanda_agent_security_group(self, value: pulumi.Input['ClusterCustomerManagedResourcesAwsRedpandaAgentSecurityGroupArgs']):
        pulumi.set(self, "redpanda_agent_security_group", value)

    @_builtins.property
    @pulumi.getter(name="redpandaNodeGroupInstanceProfile")
    def redpanda_node_group_instance_profile(self) -> pulumi.Input['ClusterCustomerManagedResourcesAwsRedpandaNodeGroupInstanceProfileArgs']:
        return pulumi.get(self, "redpanda_node_group_instance_profile")

    @redpanda_node_group_instance_profile.setter
    def redpanda_node_group_instance_profile(self, value: pulumi.Input['ClusterCustomerManagedResourcesAwsRedpandaNodeGroupInstanceProfileArgs']):
        pulumi.set(self, "redpanda_node_group_instance_profile", value)

    @_builtins.property
    @pulumi.getter(name="redpandaNodeGroupSecurityGroup")
    def redpanda_node_group_security_group(self) -> pulumi.Input['ClusterCustomerManagedResourcesAwsRedpandaNodeGroupSecurityGroupArgs']:
        return pulumi.get(self, "redpanda_node_group_security_group")

    @redpanda_node_group_security_group.setter
    def redpanda_node_group_security_group(self, value: pulumi.Input['ClusterCustomerManagedResourcesAwsRedpandaNodeGroupSecurityGroupArgs']):
        pulumi.set(self, "redpanda_node_group_security_group", value)

    @_builtins.property
    @pulumi.getter(name="utilityNodeGroupInstanceProfile")
    def utility_node_group_instance_profile(self) -> pulumi.Input['ClusterCustomerManagedResourcesAwsUtilityNodeGroupInstanceProfileArgs']:
        return pulumi.get(self, "utility_node_group_instance_profile")

    @utility_node_group_instance_profile.setter
    def utility_node_group_instance_profile(self, value: pulumi.Input['ClusterCustomerManagedResourcesAwsUtilityNodeGroupInstanceProfileArgs']):
        pulumi.set(self, "utility_node_group_instance_profile", value)

    @_builtins.property
    @pulumi.getter(name="utilitySecurityGroup")
    def utility_security_group(self) -> pulumi.Input['ClusterCustomerManagedResourcesAwsUtilitySecurityGroupArgs']:
        return pulumi.get(self, "utility_security_group")

    @utility_security_group.setter
    def utility_security_group(self, value: pulumi.Input['ClusterCustomerManagedResourcesAwsUtilitySecurityGroupArgs']):
        pulumi.set(self, "utility_security_group", value)


if not MYPY:
    class ClusterCustomerManagedResourcesAwsAgentInstanceProfileArgsDict(TypedDict):
        arn: pulumi.Input[_builtins.str]
        """
        ARN for the agent instance profile
        """
elif False:
    ClusterCustomerManagedResourcesAwsAgentInstanceProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterCustomerManagedResourcesAwsAgentInstanceProfileArgs:
    def __init__(__self__, *,
                 arn: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] arn: ARN for the agent instance profile
        """
        pulumi.set(__self__, "arn", arn)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> pulumi.Input[_builtins.str]:
        """
        ARN for the agent instance profile
        """
        return pulumi.get(self, "arn")

    @arn.setter
    def arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "arn", value)


if not MYPY:
    class ClusterCustomerManagedResourcesAwsCloudStorageBucketArgsDict(TypedDict):
        arn: pulumi.Input[_builtins.str]
        """
        ARN for the cloud storage bucket
        """
elif False:
    ClusterCustomerManagedResourcesAwsCloudStorageBucketArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterCustomerManagedResourcesAwsCloudStorageBucketArgs:
    def __init__(__self__, *,
                 arn: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] arn: ARN for the cloud storage bucket
        """
        pulumi.set(__self__, "arn", arn)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> pulumi.Input[_builtins.str]:
        """
        ARN for the cloud storage bucket
        """
        return pulumi.get(self, "arn")

    @arn.setter
    def arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "arn", value)


if not MYPY:
    class ClusterCustomerManagedResourcesAwsClusterSecurityGroupArgsDict(TypedDict):
        arn: pulumi.Input[_builtins.str]
        """
        ARN for the cluster security group
        """
elif False:
    ClusterCustomerManagedResourcesAwsClusterSecurityGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterCustomerManagedResourcesAwsClusterSecurityGroupArgs:
    def __init__(__self__, *,
                 arn: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] arn: ARN for the cluster security group
        """
        pulumi.set(__self__, "arn", arn)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> pulumi.Input[_builtins.str]:
        """
        ARN for the cluster security group
        """
        return pulumi.get(self, "arn")

    @arn.setter
    def arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "arn", value)


if not MYPY:
    class ClusterCustomerManagedResourcesAwsConnectorsNodeGroupInstanceProfileArgsDict(TypedDict):
        arn: pulumi.Input[_builtins.str]
        """
        ARN for the connectors node group instance profile
        """
elif False:
    ClusterCustomerManagedResourcesAwsConnectorsNodeGroupInstanceProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterCustomerManagedResourcesAwsConnectorsNodeGroupInstanceProfileArgs:
    def __init__(__self__, *,
                 arn: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] arn: ARN for the connectors node group instance profile
        """
        pulumi.set(__self__, "arn", arn)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> pulumi.Input[_builtins.str]:
        """
        ARN for the connectors node group instance profile
        """
        return pulumi.get(self, "arn")

    @arn.setter
    def arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "arn", value)


if not MYPY:
    class ClusterCustomerManagedResourcesAwsConnectorsSecurityGroupArgsDict(TypedDict):
        arn: pulumi.Input[_builtins.str]
        """
        ARN for the connectors security group
        """
elif False:
    ClusterCustomerManagedResourcesAwsConnectorsSecurityGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterCustomerManagedResourcesAwsConnectorsSecurityGroupArgs:
    def __init__(__self__, *,
                 arn: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] arn: ARN for the connectors security group
        """
        pulumi.set(__self__, "arn", arn)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> pulumi.Input[_builtins.str]:
        """
        ARN for the connectors security group
        """
        return pulumi.get(self, "arn")

    @arn.setter
    def arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "arn", value)


if not MYPY:
    class ClusterCustomerManagedResourcesAwsK8sClusterRoleArgsDict(TypedDict):
        arn: pulumi.Input[_builtins.str]
        """
        ARN for the Kubernetes cluster role
        """
elif False:
    ClusterCustomerManagedResourcesAwsK8sClusterRoleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterCustomerManagedResourcesAwsK8sClusterRoleArgs:
    def __init__(__self__, *,
                 arn: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] arn: ARN for the Kubernetes cluster role
        """
        pulumi.set(__self__, "arn", arn)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> pulumi.Input[_builtins.str]:
        """
        ARN for the Kubernetes cluster role
        """
        return pulumi.get(self, "arn")

    @arn.setter
    def arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "arn", value)


if not MYPY:
    class ClusterCustomerManagedResourcesAwsNodeSecurityGroupArgsDict(TypedDict):
        arn: pulumi.Input[_builtins.str]
        """
        ARN for the node security group
        """
elif False:
    ClusterCustomerManagedResourcesAwsNodeSecurityGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterCustomerManagedResourcesAwsNodeSecurityGroupArgs:
    def __init__(__self__, *,
                 arn: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] arn: ARN for the node security group
        """
        pulumi.set(__self__, "arn", arn)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> pulumi.Input[_builtins.str]:
        """
        ARN for the node security group
        """
        return pulumi.get(self, "arn")

    @arn.setter
    def arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "arn", value)


if not MYPY:
    class ClusterCustomerManagedResourcesAwsPermissionsBoundaryPolicyArgsDict(TypedDict):
        arn: pulumi.Input[_builtins.str]
        """
        ARN for the permissions boundary policy
        """
elif False:
    ClusterCustomerManagedResourcesAwsPermissionsBoundaryPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterCustomerManagedResourcesAwsPermissionsBoundaryPolicyArgs:
    def __init__(__self__, *,
                 arn: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] arn: ARN for the permissions boundary policy
        """
        pulumi.set(__self__, "arn", arn)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> pulumi.Input[_builtins.str]:
        """
        ARN for the permissions boundary policy
        """
        return pulumi.get(self, "arn")

    @arn.setter
    def arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "arn", value)


if not MYPY:
    class ClusterCustomerManagedResourcesAwsRedpandaAgentSecurityGroupArgsDict(TypedDict):
        arn: pulumi.Input[_builtins.str]
        """
        ARN for the redpanda agent security group
        """
elif False:
    ClusterCustomerManagedResourcesAwsRedpandaAgentSecurityGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterCustomerManagedResourcesAwsRedpandaAgentSecurityGroupArgs:
    def __init__(__self__, *,
                 arn: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] arn: ARN for the redpanda agent security group
        """
        pulumi.set(__self__, "arn", arn)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> pulumi.Input[_builtins.str]:
        """
        ARN for the redpanda agent security group
        """
        return pulumi.get(self, "arn")

    @arn.setter
    def arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "arn", value)


if not MYPY:
    class ClusterCustomerManagedResourcesAwsRedpandaNodeGroupInstanceProfileArgsDict(TypedDict):
        arn: pulumi.Input[_builtins.str]
        """
        ARN for the redpanda node group instance profile
        """
elif False:
    ClusterCustomerManagedResourcesAwsRedpandaNodeGroupInstanceProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterCustomerManagedResourcesAwsRedpandaNodeGroupInstanceProfileArgs:
    def __init__(__self__, *,
                 arn: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] arn: ARN for the redpanda node group instance profile
        """
        pulumi.set(__self__, "arn", arn)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> pulumi.Input[_builtins.str]:
        """
        ARN for the redpanda node group instance profile
        """
        return pulumi.get(self, "arn")

    @arn.setter
    def arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "arn", value)


if not MYPY:
    class ClusterCustomerManagedResourcesAwsRedpandaNodeGroupSecurityGroupArgsDict(TypedDict):
        arn: pulumi.Input[_builtins.str]
        """
        ARN for the redpanda node group security group
        """
elif False:
    ClusterCustomerManagedResourcesAwsRedpandaNodeGroupSecurityGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterCustomerManagedResourcesAwsRedpandaNodeGroupSecurityGroupArgs:
    def __init__(__self__, *,
                 arn: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] arn: ARN for the redpanda node group security group
        """
        pulumi.set(__self__, "arn", arn)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> pulumi.Input[_builtins.str]:
        """
        ARN for the redpanda node group security group
        """
        return pulumi.get(self, "arn")

    @arn.setter
    def arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "arn", value)


if not MYPY:
    class ClusterCustomerManagedResourcesAwsUtilityNodeGroupInstanceProfileArgsDict(TypedDict):
        arn: pulumi.Input[_builtins.str]
        """
        ARN for the utility node group instance profile
        """
elif False:
    ClusterCustomerManagedResourcesAwsUtilityNodeGroupInstanceProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterCustomerManagedResourcesAwsUtilityNodeGroupInstanceProfileArgs:
    def __init__(__self__, *,
                 arn: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] arn: ARN for the utility node group instance profile
        """
        pulumi.set(__self__, "arn", arn)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> pulumi.Input[_builtins.str]:
        """
        ARN for the utility node group instance profile
        """
        return pulumi.get(self, "arn")

    @arn.setter
    def arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "arn", value)


if not MYPY:
    class ClusterCustomerManagedResourcesAwsUtilitySecurityGroupArgsDict(TypedDict):
        arn: pulumi.Input[_builtins.str]
        """
        ARN for the utility security group
        """
elif False:
    ClusterCustomerManagedResourcesAwsUtilitySecurityGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterCustomerManagedResourcesAwsUtilitySecurityGroupArgs:
    def __init__(__self__, *,
                 arn: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] arn: ARN for the utility security group
        """
        pulumi.set(__self__, "arn", arn)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> pulumi.Input[_builtins.str]:
        """
        ARN for the utility security group
        """
        return pulumi.get(self, "arn")

    @arn.setter
    def arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "arn", value)


if not MYPY:
    class ClusterCustomerManagedResourcesGcpArgsDict(TypedDict):
        agent_service_account: pulumi.Input['ClusterCustomerManagedResourcesGcpAgentServiceAccountArgsDict']
        """
        GCP service account for the agent.
        """
        connector_service_account: pulumi.Input['ClusterCustomerManagedResourcesGcpConnectorServiceAccountArgsDict']
        """
        GCP service account for managed connectors.
        """
        console_service_account: pulumi.Input['ClusterCustomerManagedResourcesGcpConsoleServiceAccountArgsDict']
        """
        GCP service account for Redpanda Console.
        """
        gke_service_account: pulumi.Input['ClusterCustomerManagedResourcesGcpGkeServiceAccountArgsDict']
        """
        GCP service account for GCP Kubernetes Engine (GKE).
        """
        redpanda_cluster_service_account: pulumi.Input['ClusterCustomerManagedResourcesGcpRedpandaClusterServiceAccountArgsDict']
        """
        GCP service account for the Redpanda cluster.
        """
        subnet: pulumi.Input['ClusterCustomerManagedResourcesGcpSubnetArgsDict']
        """
        GCP subnet where Redpanda cluster is deployed.
        """
        tiered_storage_bucket: pulumi.Input['ClusterCustomerManagedResourcesGcpTieredStorageBucketArgsDict']
        """
        GCP storage bucket for Tiered storage.
        """
        psc_nat_subnet_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        NAT subnet name if GCP Private Service Connect is enabled.
        """
elif False:
    ClusterCustomerManagedResourcesGcpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterCustomerManagedResourcesGcpArgs:
    def __init__(__self__, *,
                 agent_service_account: pulumi.Input['ClusterCustomerManagedResourcesGcpAgentServiceAccountArgs'],
                 connector_service_account: pulumi.Input['ClusterCustomerManagedResourcesGcpConnectorServiceAccountArgs'],
                 console_service_account: pulumi.Input['ClusterCustomerManagedResourcesGcpConsoleServiceAccountArgs'],
                 gke_service_account: pulumi.Input['ClusterCustomerManagedResourcesGcpGkeServiceAccountArgs'],
                 redpanda_cluster_service_account: pulumi.Input['ClusterCustomerManagedResourcesGcpRedpandaClusterServiceAccountArgs'],
                 subnet: pulumi.Input['ClusterCustomerManagedResourcesGcpSubnetArgs'],
                 tiered_storage_bucket: pulumi.Input['ClusterCustomerManagedResourcesGcpTieredStorageBucketArgs'],
                 psc_nat_subnet_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['ClusterCustomerManagedResourcesGcpAgentServiceAccountArgs'] agent_service_account: GCP service account for the agent.
        :param pulumi.Input['ClusterCustomerManagedResourcesGcpConnectorServiceAccountArgs'] connector_service_account: GCP service account for managed connectors.
        :param pulumi.Input['ClusterCustomerManagedResourcesGcpConsoleServiceAccountArgs'] console_service_account: GCP service account for Redpanda Console.
        :param pulumi.Input['ClusterCustomerManagedResourcesGcpGkeServiceAccountArgs'] gke_service_account: GCP service account for GCP Kubernetes Engine (GKE).
        :param pulumi.Input['ClusterCustomerManagedResourcesGcpRedpandaClusterServiceAccountArgs'] redpanda_cluster_service_account: GCP service account for the Redpanda cluster.
        :param pulumi.Input['ClusterCustomerManagedResourcesGcpSubnetArgs'] subnet: GCP subnet where Redpanda cluster is deployed.
        :param pulumi.Input['ClusterCustomerManagedResourcesGcpTieredStorageBucketArgs'] tiered_storage_bucket: GCP storage bucket for Tiered storage.
        :param pulumi.Input[_builtins.str] psc_nat_subnet_name: NAT subnet name if GCP Private Service Connect is enabled.
        """
        pulumi.set(__self__, "agent_service_account", agent_service_account)
        pulumi.set(__self__, "connector_service_account", connector_service_account)
        pulumi.set(__self__, "console_service_account", console_service_account)
        pulumi.set(__self__, "gke_service_account", gke_service_account)
        pulumi.set(__self__, "redpanda_cluster_service_account", redpanda_cluster_service_account)
        pulumi.set(__self__, "subnet", subnet)
        pulumi.set(__self__, "tiered_storage_bucket", tiered_storage_bucket)
        if psc_nat_subnet_name is not None:
            pulumi.set(__self__, "psc_nat_subnet_name", psc_nat_subnet_name)

    @_builtins.property
    @pulumi.getter(name="agentServiceAccount")
    def agent_service_account(self) -> pulumi.Input['ClusterCustomerManagedResourcesGcpAgentServiceAccountArgs']:
        """
        GCP service account for the agent.
        """
        return pulumi.get(self, "agent_service_account")

    @agent_service_account.setter
    def agent_service_account(self, value: pulumi.Input['ClusterCustomerManagedResourcesGcpAgentServiceAccountArgs']):
        pulumi.set(self, "agent_service_account", value)

    @_builtins.property
    @pulumi.getter(name="connectorServiceAccount")
    def connector_service_account(self) -> pulumi.Input['ClusterCustomerManagedResourcesGcpConnectorServiceAccountArgs']:
        """
        GCP service account for managed connectors.
        """
        return pulumi.get(self, "connector_service_account")

    @connector_service_account.setter
    def connector_service_account(self, value: pulumi.Input['ClusterCustomerManagedResourcesGcpConnectorServiceAccountArgs']):
        pulumi.set(self, "connector_service_account", value)

    @_builtins.property
    @pulumi.getter(name="consoleServiceAccount")
    def console_service_account(self) -> pulumi.Input['ClusterCustomerManagedResourcesGcpConsoleServiceAccountArgs']:
        """
        GCP service account for Redpanda Console.
        """
        return pulumi.get(self, "console_service_account")

    @console_service_account.setter
    def console_service_account(self, value: pulumi.Input['ClusterCustomerManagedResourcesGcpConsoleServiceAccountArgs']):
        pulumi.set(self, "console_service_account", value)

    @_builtins.property
    @pulumi.getter(name="gkeServiceAccount")
    def gke_service_account(self) -> pulumi.Input['ClusterCustomerManagedResourcesGcpGkeServiceAccountArgs']:
        """
        GCP service account for GCP Kubernetes Engine (GKE).
        """
        return pulumi.get(self, "gke_service_account")

    @gke_service_account.setter
    def gke_service_account(self, value: pulumi.Input['ClusterCustomerManagedResourcesGcpGkeServiceAccountArgs']):
        pulumi.set(self, "gke_service_account", value)

    @_builtins.property
    @pulumi.getter(name="redpandaClusterServiceAccount")
    def redpanda_cluster_service_account(self) -> pulumi.Input['ClusterCustomerManagedResourcesGcpRedpandaClusterServiceAccountArgs']:
        """
        GCP service account for the Redpanda cluster.
        """
        return pulumi.get(self, "redpanda_cluster_service_account")

    @redpanda_cluster_service_account.setter
    def redpanda_cluster_service_account(self, value: pulumi.Input['ClusterCustomerManagedResourcesGcpRedpandaClusterServiceAccountArgs']):
        pulumi.set(self, "redpanda_cluster_service_account", value)

    @_builtins.property
    @pulumi.getter
    def subnet(self) -> pulumi.Input['ClusterCustomerManagedResourcesGcpSubnetArgs']:
        """
        GCP subnet where Redpanda cluster is deployed.
        """
        return pulumi.get(self, "subnet")

    @subnet.setter
    def subnet(self, value: pulumi.Input['ClusterCustomerManagedResourcesGcpSubnetArgs']):
        pulumi.set(self, "subnet", value)

    @_builtins.property
    @pulumi.getter(name="tieredStorageBucket")
    def tiered_storage_bucket(self) -> pulumi.Input['ClusterCustomerManagedResourcesGcpTieredStorageBucketArgs']:
        """
        GCP storage bucket for Tiered storage.
        """
        return pulumi.get(self, "tiered_storage_bucket")

    @tiered_storage_bucket.setter
    def tiered_storage_bucket(self, value: pulumi.Input['ClusterCustomerManagedResourcesGcpTieredStorageBucketArgs']):
        pulumi.set(self, "tiered_storage_bucket", value)

    @_builtins.property
    @pulumi.getter(name="pscNatSubnetName")
    def psc_nat_subnet_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        NAT subnet name if GCP Private Service Connect is enabled.
        """
        return pulumi.get(self, "psc_nat_subnet_name")

    @psc_nat_subnet_name.setter
    def psc_nat_subnet_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "psc_nat_subnet_name", value)


if not MYPY:
    class ClusterCustomerManagedResourcesGcpAgentServiceAccountArgsDict(TypedDict):
        email: pulumi.Input[_builtins.str]
        """
        GCP service account email.
        """
elif False:
    ClusterCustomerManagedResourcesGcpAgentServiceAccountArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterCustomerManagedResourcesGcpAgentServiceAccountArgs:
    def __init__(__self__, *,
                 email: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] email: GCP service account email.
        """
        pulumi.set(__self__, "email", email)

    @_builtins.property
    @pulumi.getter
    def email(self) -> pulumi.Input[_builtins.str]:
        """
        GCP service account email.
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "email", value)


if not MYPY:
    class ClusterCustomerManagedResourcesGcpConnectorServiceAccountArgsDict(TypedDict):
        email: pulumi.Input[_builtins.str]
        """
        GCP service account email.
        """
elif False:
    ClusterCustomerManagedResourcesGcpConnectorServiceAccountArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterCustomerManagedResourcesGcpConnectorServiceAccountArgs:
    def __init__(__self__, *,
                 email: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] email: GCP service account email.
        """
        pulumi.set(__self__, "email", email)

    @_builtins.property
    @pulumi.getter
    def email(self) -> pulumi.Input[_builtins.str]:
        """
        GCP service account email.
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "email", value)


if not MYPY:
    class ClusterCustomerManagedResourcesGcpConsoleServiceAccountArgsDict(TypedDict):
        email: pulumi.Input[_builtins.str]
        """
        GCP service account email.
        """
elif False:
    ClusterCustomerManagedResourcesGcpConsoleServiceAccountArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterCustomerManagedResourcesGcpConsoleServiceAccountArgs:
    def __init__(__self__, *,
                 email: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] email: GCP service account email.
        """
        pulumi.set(__self__, "email", email)

    @_builtins.property
    @pulumi.getter
    def email(self) -> pulumi.Input[_builtins.str]:
        """
        GCP service account email.
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "email", value)


if not MYPY:
    class ClusterCustomerManagedResourcesGcpGkeServiceAccountArgsDict(TypedDict):
        email: pulumi.Input[_builtins.str]
        """
        GCP service account email.
        """
elif False:
    ClusterCustomerManagedResourcesGcpGkeServiceAccountArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterCustomerManagedResourcesGcpGkeServiceAccountArgs:
    def __init__(__self__, *,
                 email: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] email: GCP service account email.
        """
        pulumi.set(__self__, "email", email)

    @_builtins.property
    @pulumi.getter
    def email(self) -> pulumi.Input[_builtins.str]:
        """
        GCP service account email.
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "email", value)


if not MYPY:
    class ClusterCustomerManagedResourcesGcpRedpandaClusterServiceAccountArgsDict(TypedDict):
        email: pulumi.Input[_builtins.str]
        """
        GCP service account email.
        """
elif False:
    ClusterCustomerManagedResourcesGcpRedpandaClusterServiceAccountArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterCustomerManagedResourcesGcpRedpandaClusterServiceAccountArgs:
    def __init__(__self__, *,
                 email: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] email: GCP service account email.
        """
        pulumi.set(__self__, "email", email)

    @_builtins.property
    @pulumi.getter
    def email(self) -> pulumi.Input[_builtins.str]:
        """
        GCP service account email.
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "email", value)


if not MYPY:
    class ClusterCustomerManagedResourcesGcpSubnetArgsDict(TypedDict):
        k8s_master_ipv4_range: pulumi.Input[_builtins.str]
        """
        Kubernetes Master IPv4 range, e.g. 10.0.0.0/24.
        """
        name: pulumi.Input[_builtins.str]
        """
        Subnet name.
        """
        secondary_ipv4_range_pods: pulumi.Input['ClusterCustomerManagedResourcesGcpSubnetSecondaryIpv4RangePodsArgsDict']
        """
        Secondary IPv4 range for pods.
        """
        secondary_ipv4_range_services: pulumi.Input['ClusterCustomerManagedResourcesGcpSubnetSecondaryIpv4RangeServicesArgsDict']
        """
        Secondary IPv4 range for services.
        """
elif False:
    ClusterCustomerManagedResourcesGcpSubnetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterCustomerManagedResourcesGcpSubnetArgs:
    def __init__(__self__, *,
                 k8s_master_ipv4_range: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 secondary_ipv4_range_pods: pulumi.Input['ClusterCustomerManagedResourcesGcpSubnetSecondaryIpv4RangePodsArgs'],
                 secondary_ipv4_range_services: pulumi.Input['ClusterCustomerManagedResourcesGcpSubnetSecondaryIpv4RangeServicesArgs']):
        """
        :param pulumi.Input[_builtins.str] k8s_master_ipv4_range: Kubernetes Master IPv4 range, e.g. 10.0.0.0/24.
        :param pulumi.Input[_builtins.str] name: Subnet name.
        :param pulumi.Input['ClusterCustomerManagedResourcesGcpSubnetSecondaryIpv4RangePodsArgs'] secondary_ipv4_range_pods: Secondary IPv4 range for pods.
        :param pulumi.Input['ClusterCustomerManagedResourcesGcpSubnetSecondaryIpv4RangeServicesArgs'] secondary_ipv4_range_services: Secondary IPv4 range for services.
        """
        pulumi.set(__self__, "k8s_master_ipv4_range", k8s_master_ipv4_range)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "secondary_ipv4_range_pods", secondary_ipv4_range_pods)
        pulumi.set(__self__, "secondary_ipv4_range_services", secondary_ipv4_range_services)

    @_builtins.property
    @pulumi.getter(name="k8sMasterIpv4Range")
    def k8s_master_ipv4_range(self) -> pulumi.Input[_builtins.str]:
        """
        Kubernetes Master IPv4 range, e.g. 10.0.0.0/24.
        """
        return pulumi.get(self, "k8s_master_ipv4_range")

    @k8s_master_ipv4_range.setter
    def k8s_master_ipv4_range(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "k8s_master_ipv4_range", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Subnet name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="secondaryIpv4RangePods")
    def secondary_ipv4_range_pods(self) -> pulumi.Input['ClusterCustomerManagedResourcesGcpSubnetSecondaryIpv4RangePodsArgs']:
        """
        Secondary IPv4 range for pods.
        """
        return pulumi.get(self, "secondary_ipv4_range_pods")

    @secondary_ipv4_range_pods.setter
    def secondary_ipv4_range_pods(self, value: pulumi.Input['ClusterCustomerManagedResourcesGcpSubnetSecondaryIpv4RangePodsArgs']):
        pulumi.set(self, "secondary_ipv4_range_pods", value)

    @_builtins.property
    @pulumi.getter(name="secondaryIpv4RangeServices")
    def secondary_ipv4_range_services(self) -> pulumi.Input['ClusterCustomerManagedResourcesGcpSubnetSecondaryIpv4RangeServicesArgs']:
        """
        Secondary IPv4 range for services.
        """
        return pulumi.get(self, "secondary_ipv4_range_services")

    @secondary_ipv4_range_services.setter
    def secondary_ipv4_range_services(self, value: pulumi.Input['ClusterCustomerManagedResourcesGcpSubnetSecondaryIpv4RangeServicesArgs']):
        pulumi.set(self, "secondary_ipv4_range_services", value)


if not MYPY:
    class ClusterCustomerManagedResourcesGcpSubnetSecondaryIpv4RangePodsArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Secondary IPv4 range name for pods.
        """
elif False:
    ClusterCustomerManagedResourcesGcpSubnetSecondaryIpv4RangePodsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterCustomerManagedResourcesGcpSubnetSecondaryIpv4RangePodsArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] name: Secondary IPv4 range name for pods.
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Secondary IPv4 range name for pods.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class ClusterCustomerManagedResourcesGcpSubnetSecondaryIpv4RangeServicesArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Secondary IPv4 range name for services.
        """
elif False:
    ClusterCustomerManagedResourcesGcpSubnetSecondaryIpv4RangeServicesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterCustomerManagedResourcesGcpSubnetSecondaryIpv4RangeServicesArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] name: Secondary IPv4 range name for services.
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Secondary IPv4 range name for services.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class ClusterCustomerManagedResourcesGcpTieredStorageBucketArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        GCP storage bucket name.
        """
elif False:
    ClusterCustomerManagedResourcesGcpTieredStorageBucketArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterCustomerManagedResourcesGcpTieredStorageBucketArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] name: GCP storage bucket name.
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        GCP storage bucket name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class ClusterGcpPrivateServiceConnectArgsDict(TypedDict):
        consumer_accept_lists: pulumi.Input[Sequence[pulumi.Input['ClusterGcpPrivateServiceConnectConsumerAcceptListArgsDict']]]
        """
        List of consumers that are allowed to connect to Redpanda GCP PSC (Private Service Connect) service attachment.
        """
        enabled: pulumi.Input[_builtins.bool]
        """
        Whether Redpanda GCP Private Service Connect is enabled.
        """
        global_access_enabled: pulumi.Input[_builtins.bool]
        """
        Whether global access is enabled.
        """
        status: NotRequired[pulumi.Input['ClusterGcpPrivateServiceConnectStatusArgsDict']]
        """
        Current status of the Private Service Connect configuration.
        """
elif False:
    ClusterGcpPrivateServiceConnectArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterGcpPrivateServiceConnectArgs:
    def __init__(__self__, *,
                 consumer_accept_lists: pulumi.Input[Sequence[pulumi.Input['ClusterGcpPrivateServiceConnectConsumerAcceptListArgs']]],
                 enabled: pulumi.Input[_builtins.bool],
                 global_access_enabled: pulumi.Input[_builtins.bool],
                 status: Optional[pulumi.Input['ClusterGcpPrivateServiceConnectStatusArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ClusterGcpPrivateServiceConnectConsumerAcceptListArgs']]] consumer_accept_lists: List of consumers that are allowed to connect to Redpanda GCP PSC (Private Service Connect) service attachment.
        :param pulumi.Input[_builtins.bool] enabled: Whether Redpanda GCP Private Service Connect is enabled.
        :param pulumi.Input[_builtins.bool] global_access_enabled: Whether global access is enabled.
        :param pulumi.Input['ClusterGcpPrivateServiceConnectStatusArgs'] status: Current status of the Private Service Connect configuration.
        """
        pulumi.set(__self__, "consumer_accept_lists", consumer_accept_lists)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "global_access_enabled", global_access_enabled)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter(name="consumerAcceptLists")
    def consumer_accept_lists(self) -> pulumi.Input[Sequence[pulumi.Input['ClusterGcpPrivateServiceConnectConsumerAcceptListArgs']]]:
        """
        List of consumers that are allowed to connect to Redpanda GCP PSC (Private Service Connect) service attachment.
        """
        return pulumi.get(self, "consumer_accept_lists")

    @consumer_accept_lists.setter
    def consumer_accept_lists(self, value: pulumi.Input[Sequence[pulumi.Input['ClusterGcpPrivateServiceConnectConsumerAcceptListArgs']]]):
        pulumi.set(self, "consumer_accept_lists", value)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        """
        Whether Redpanda GCP Private Service Connect is enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="globalAccessEnabled")
    def global_access_enabled(self) -> pulumi.Input[_builtins.bool]:
        """
        Whether global access is enabled.
        """
        return pulumi.get(self, "global_access_enabled")

    @global_access_enabled.setter
    def global_access_enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "global_access_enabled", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input['ClusterGcpPrivateServiceConnectStatusArgs']]:
        """
        Current status of the Private Service Connect configuration.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input['ClusterGcpPrivateServiceConnectStatusArgs']]):
        pulumi.set(self, "status", value)


if not MYPY:
    class ClusterGcpPrivateServiceConnectConsumerAcceptListArgsDict(TypedDict):
        source: pulumi.Input[_builtins.str]
        """
        Either the GCP project number or its alphanumeric ID.
        """
elif False:
    ClusterGcpPrivateServiceConnectConsumerAcceptListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterGcpPrivateServiceConnectConsumerAcceptListArgs:
    def __init__(__self__, *,
                 source: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] source: Either the GCP project number or its alphanumeric ID.
        """
        pulumi.set(__self__, "source", source)

    @_builtins.property
    @pulumi.getter
    def source(self) -> pulumi.Input[_builtins.str]:
        """
        Either the GCP project number or its alphanumeric ID.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "source", value)


if not MYPY:
    class ClusterGcpPrivateServiceConnectStatusArgsDict(TypedDict):
        connected_endpoints: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterGcpPrivateServiceConnectStatusConnectedEndpointArgsDict']]]]
        """
        List of connected endpoints.
        """
        created_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        When the Private Service Connect service was created.
        """
        deleted_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        When the Private Service Connect service was deleted.
        """
        dns_a_records: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        DNS A records for the service.
        """
        kafka_api_node_base_port: NotRequired[pulumi.Input[_builtins.int]]
        """
        Base port for Kafka API nodes.
        """
        kafka_api_seed_port: NotRequired[pulumi.Input[_builtins.int]]
        """
        Port for Kafka API seed brokers.
        """
        redpanda_proxy_node_base_port: NotRequired[pulumi.Input[_builtins.int]]
        """
        Base port for HTTP proxy nodes.
        """
        redpanda_proxy_seed_port: NotRequired[pulumi.Input[_builtins.int]]
        """
        Port for HTTP proxy.
        """
        schema_registry_seed_port: NotRequired[pulumi.Input[_builtins.int]]
        """
        Port for Schema Registry.
        """
        seed_hostname: NotRequired[pulumi.Input[_builtins.str]]
        """
        Hostname for the seed brokers.
        """
        service_attachment: NotRequired[pulumi.Input[_builtins.str]]
        """
        The service attachment identifier.
        """
elif False:
    ClusterGcpPrivateServiceConnectStatusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterGcpPrivateServiceConnectStatusArgs:
    def __init__(__self__, *,
                 connected_endpoints: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterGcpPrivateServiceConnectStatusConnectedEndpointArgs']]]] = None,
                 created_at: Optional[pulumi.Input[_builtins.str]] = None,
                 deleted_at: Optional[pulumi.Input[_builtins.str]] = None,
                 dns_a_records: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 kafka_api_node_base_port: Optional[pulumi.Input[_builtins.int]] = None,
                 kafka_api_seed_port: Optional[pulumi.Input[_builtins.int]] = None,
                 redpanda_proxy_node_base_port: Optional[pulumi.Input[_builtins.int]] = None,
                 redpanda_proxy_seed_port: Optional[pulumi.Input[_builtins.int]] = None,
                 schema_registry_seed_port: Optional[pulumi.Input[_builtins.int]] = None,
                 seed_hostname: Optional[pulumi.Input[_builtins.str]] = None,
                 service_attachment: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ClusterGcpPrivateServiceConnectStatusConnectedEndpointArgs']]] connected_endpoints: List of connected endpoints.
        :param pulumi.Input[_builtins.str] created_at: When the Private Service Connect service was created.
        :param pulumi.Input[_builtins.str] deleted_at: When the Private Service Connect service was deleted.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] dns_a_records: DNS A records for the service.
        :param pulumi.Input[_builtins.int] kafka_api_node_base_port: Base port for Kafka API nodes.
        :param pulumi.Input[_builtins.int] kafka_api_seed_port: Port for Kafka API seed brokers.
        :param pulumi.Input[_builtins.int] redpanda_proxy_node_base_port: Base port for HTTP proxy nodes.
        :param pulumi.Input[_builtins.int] redpanda_proxy_seed_port: Port for HTTP proxy.
        :param pulumi.Input[_builtins.int] schema_registry_seed_port: Port for Schema Registry.
        :param pulumi.Input[_builtins.str] seed_hostname: Hostname for the seed brokers.
        :param pulumi.Input[_builtins.str] service_attachment: The service attachment identifier.
        """
        if connected_endpoints is not None:
            pulumi.set(__self__, "connected_endpoints", connected_endpoints)
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if deleted_at is not None:
            pulumi.set(__self__, "deleted_at", deleted_at)
        if dns_a_records is not None:
            pulumi.set(__self__, "dns_a_records", dns_a_records)
        if kafka_api_node_base_port is not None:
            pulumi.set(__self__, "kafka_api_node_base_port", kafka_api_node_base_port)
        if kafka_api_seed_port is not None:
            pulumi.set(__self__, "kafka_api_seed_port", kafka_api_seed_port)
        if redpanda_proxy_node_base_port is not None:
            pulumi.set(__self__, "redpanda_proxy_node_base_port", redpanda_proxy_node_base_port)
        if redpanda_proxy_seed_port is not None:
            pulumi.set(__self__, "redpanda_proxy_seed_port", redpanda_proxy_seed_port)
        if schema_registry_seed_port is not None:
            pulumi.set(__self__, "schema_registry_seed_port", schema_registry_seed_port)
        if seed_hostname is not None:
            pulumi.set(__self__, "seed_hostname", seed_hostname)
        if service_attachment is not None:
            pulumi.set(__self__, "service_attachment", service_attachment)

    @_builtins.property
    @pulumi.getter(name="connectedEndpoints")
    def connected_endpoints(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterGcpPrivateServiceConnectStatusConnectedEndpointArgs']]]]:
        """
        List of connected endpoints.
        """
        return pulumi.get(self, "connected_endpoints")

    @connected_endpoints.setter
    def connected_endpoints(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterGcpPrivateServiceConnectStatusConnectedEndpointArgs']]]]):
        pulumi.set(self, "connected_endpoints", value)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        When the Private Service Connect service was created.
        """
        return pulumi.get(self, "created_at")

    @created_at.setter
    def created_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_at", value)

    @_builtins.property
    @pulumi.getter(name="deletedAt")
    def deleted_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        When the Private Service Connect service was deleted.
        """
        return pulumi.get(self, "deleted_at")

    @deleted_at.setter
    def deleted_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "deleted_at", value)

    @_builtins.property
    @pulumi.getter(name="dnsARecords")
    def dns_a_records(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        DNS A records for the service.
        """
        return pulumi.get(self, "dns_a_records")

    @dns_a_records.setter
    def dns_a_records(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "dns_a_records", value)

    @_builtins.property
    @pulumi.getter(name="kafkaApiNodeBasePort")
    def kafka_api_node_base_port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Base port for Kafka API nodes.
        """
        return pulumi.get(self, "kafka_api_node_base_port")

    @kafka_api_node_base_port.setter
    def kafka_api_node_base_port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "kafka_api_node_base_port", value)

    @_builtins.property
    @pulumi.getter(name="kafkaApiSeedPort")
    def kafka_api_seed_port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Port for Kafka API seed brokers.
        """
        return pulumi.get(self, "kafka_api_seed_port")

    @kafka_api_seed_port.setter
    def kafka_api_seed_port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "kafka_api_seed_port", value)

    @_builtins.property
    @pulumi.getter(name="redpandaProxyNodeBasePort")
    def redpanda_proxy_node_base_port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Base port for HTTP proxy nodes.
        """
        return pulumi.get(self, "redpanda_proxy_node_base_port")

    @redpanda_proxy_node_base_port.setter
    def redpanda_proxy_node_base_port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "redpanda_proxy_node_base_port", value)

    @_builtins.property
    @pulumi.getter(name="redpandaProxySeedPort")
    def redpanda_proxy_seed_port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Port for HTTP proxy.
        """
        return pulumi.get(self, "redpanda_proxy_seed_port")

    @redpanda_proxy_seed_port.setter
    def redpanda_proxy_seed_port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "redpanda_proxy_seed_port", value)

    @_builtins.property
    @pulumi.getter(name="schemaRegistrySeedPort")
    def schema_registry_seed_port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Port for Schema Registry.
        """
        return pulumi.get(self, "schema_registry_seed_port")

    @schema_registry_seed_port.setter
    def schema_registry_seed_port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "schema_registry_seed_port", value)

    @_builtins.property
    @pulumi.getter(name="seedHostname")
    def seed_hostname(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Hostname for the seed brokers.
        """
        return pulumi.get(self, "seed_hostname")

    @seed_hostname.setter
    def seed_hostname(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "seed_hostname", value)

    @_builtins.property
    @pulumi.getter(name="serviceAttachment")
    def service_attachment(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The service attachment identifier.
        """
        return pulumi.get(self, "service_attachment")

    @service_attachment.setter
    def service_attachment(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "service_attachment", value)


if not MYPY:
    class ClusterGcpPrivateServiceConnectStatusConnectedEndpointArgsDict(TypedDict):
        connection_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The connection ID.
        """
        consumer_network: NotRequired[pulumi.Input[_builtins.str]]
        """
        The consumer network.
        """
        endpoint: NotRequired[pulumi.Input[_builtins.str]]
        """
        The endpoint address.
        """
        status: NotRequired[pulumi.Input[_builtins.str]]
        """
        Status of the endpoint connection.
        """
elif False:
    ClusterGcpPrivateServiceConnectStatusConnectedEndpointArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterGcpPrivateServiceConnectStatusConnectedEndpointArgs:
    def __init__(__self__, *,
                 connection_id: Optional[pulumi.Input[_builtins.str]] = None,
                 consumer_network: Optional[pulumi.Input[_builtins.str]] = None,
                 endpoint: Optional[pulumi.Input[_builtins.str]] = None,
                 status: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] connection_id: The connection ID.
        :param pulumi.Input[_builtins.str] consumer_network: The consumer network.
        :param pulumi.Input[_builtins.str] endpoint: The endpoint address.
        :param pulumi.Input[_builtins.str] status: Status of the endpoint connection.
        """
        if connection_id is not None:
            pulumi.set(__self__, "connection_id", connection_id)
        if consumer_network is not None:
            pulumi.set(__self__, "consumer_network", consumer_network)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter(name="connectionId")
    def connection_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The connection ID.
        """
        return pulumi.get(self, "connection_id")

    @connection_id.setter
    def connection_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "connection_id", value)

    @_builtins.property
    @pulumi.getter(name="consumerNetwork")
    def consumer_network(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The consumer network.
        """
        return pulumi.get(self, "consumer_network")

    @consumer_network.setter
    def consumer_network(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "consumer_network", value)

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The endpoint address.
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "endpoint", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Status of the endpoint connection.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status", value)


if not MYPY:
    class ClusterHttpProxyArgsDict(TypedDict):
        mtls: NotRequired[pulumi.Input['ClusterHttpProxyMtlsArgsDict']]
        """
        mTLS configuration.
        """
        url: NotRequired[pulumi.Input[_builtins.str]]
        """
        The HTTP Proxy URL.
        """
elif False:
    ClusterHttpProxyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterHttpProxyArgs:
    def __init__(__self__, *,
                 mtls: Optional[pulumi.Input['ClusterHttpProxyMtlsArgs']] = None,
                 url: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['ClusterHttpProxyMtlsArgs'] mtls: mTLS configuration.
        :param pulumi.Input[_builtins.str] url: The HTTP Proxy URL.
        """
        if mtls is not None:
            pulumi.set(__self__, "mtls", mtls)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def mtls(self) -> Optional[pulumi.Input['ClusterHttpProxyMtlsArgs']]:
        """
        mTLS configuration.
        """
        return pulumi.get(self, "mtls")

    @mtls.setter
    def mtls(self, value: Optional[pulumi.Input['ClusterHttpProxyMtlsArgs']]):
        pulumi.set(self, "mtls", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The HTTP Proxy URL.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "url", value)


if not MYPY:
    class ClusterHttpProxyMtlsArgsDict(TypedDict):
        ca_certificates_pems: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        CA certificate in PEM format.
        """
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether mTLS is enabled.
        """
        principal_mapping_rules: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Principal mapping rules for mTLS authentication. See the Redpanda documentation on configuring authentication.
        """
elif False:
    ClusterHttpProxyMtlsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterHttpProxyMtlsArgs:
    def __init__(__self__, *,
                 ca_certificates_pems: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 principal_mapping_rules: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] ca_certificates_pems: CA certificate in PEM format.
        :param pulumi.Input[_builtins.bool] enabled: Whether mTLS is enabled.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] principal_mapping_rules: Principal mapping rules for mTLS authentication. See the Redpanda documentation on configuring authentication.
        """
        if ca_certificates_pems is not None:
            pulumi.set(__self__, "ca_certificates_pems", ca_certificates_pems)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if principal_mapping_rules is not None:
            pulumi.set(__self__, "principal_mapping_rules", principal_mapping_rules)

    @_builtins.property
    @pulumi.getter(name="caCertificatesPems")
    def ca_certificates_pems(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        CA certificate in PEM format.
        """
        return pulumi.get(self, "ca_certificates_pems")

    @ca_certificates_pems.setter
    def ca_certificates_pems(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "ca_certificates_pems", value)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether mTLS is enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="principalMappingRules")
    def principal_mapping_rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Principal mapping rules for mTLS authentication. See the Redpanda documentation on configuring authentication.
        """
        return pulumi.get(self, "principal_mapping_rules")

    @principal_mapping_rules.setter
    def principal_mapping_rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "principal_mapping_rules", value)


if not MYPY:
    class ClusterKafkaApiArgsDict(TypedDict):
        mtls: NotRequired[pulumi.Input['ClusterKafkaApiMtlsArgsDict']]
        """
        mTLS configuration.
        """
        seed_brokers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of Kafka broker addresses.
        """
elif False:
    ClusterKafkaApiArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterKafkaApiArgs:
    def __init__(__self__, *,
                 mtls: Optional[pulumi.Input['ClusterKafkaApiMtlsArgs']] = None,
                 seed_brokers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input['ClusterKafkaApiMtlsArgs'] mtls: mTLS configuration.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] seed_brokers: List of Kafka broker addresses.
        """
        if mtls is not None:
            pulumi.set(__self__, "mtls", mtls)
        if seed_brokers is not None:
            pulumi.set(__self__, "seed_brokers", seed_brokers)

    @_builtins.property
    @pulumi.getter
    def mtls(self) -> Optional[pulumi.Input['ClusterKafkaApiMtlsArgs']]:
        """
        mTLS configuration.
        """
        return pulumi.get(self, "mtls")

    @mtls.setter
    def mtls(self, value: Optional[pulumi.Input['ClusterKafkaApiMtlsArgs']]):
        pulumi.set(self, "mtls", value)

    @_builtins.property
    @pulumi.getter(name="seedBrokers")
    def seed_brokers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of Kafka broker addresses.
        """
        return pulumi.get(self, "seed_brokers")

    @seed_brokers.setter
    def seed_brokers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "seed_brokers", value)


if not MYPY:
    class ClusterKafkaApiMtlsArgsDict(TypedDict):
        ca_certificates_pems: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        CA certificate in PEM format.
        """
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether mTLS is enabled.
        """
        principal_mapping_rules: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Principal mapping rules for mTLS authentication. See the Redpanda documentation on configuring authentication.
        """
elif False:
    ClusterKafkaApiMtlsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterKafkaApiMtlsArgs:
    def __init__(__self__, *,
                 ca_certificates_pems: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 principal_mapping_rules: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] ca_certificates_pems: CA certificate in PEM format.
        :param pulumi.Input[_builtins.bool] enabled: Whether mTLS is enabled.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] principal_mapping_rules: Principal mapping rules for mTLS authentication. See the Redpanda documentation on configuring authentication.
        """
        if ca_certificates_pems is not None:
            pulumi.set(__self__, "ca_certificates_pems", ca_certificates_pems)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if principal_mapping_rules is not None:
            pulumi.set(__self__, "principal_mapping_rules", principal_mapping_rules)

    @_builtins.property
    @pulumi.getter(name="caCertificatesPems")
    def ca_certificates_pems(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        CA certificate in PEM format.
        """
        return pulumi.get(self, "ca_certificates_pems")

    @ca_certificates_pems.setter
    def ca_certificates_pems(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "ca_certificates_pems", value)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether mTLS is enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="principalMappingRules")
    def principal_mapping_rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Principal mapping rules for mTLS authentication. See the Redpanda documentation on configuring authentication.
        """
        return pulumi.get(self, "principal_mapping_rules")

    @principal_mapping_rules.setter
    def principal_mapping_rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "principal_mapping_rules", value)


if not MYPY:
    class ClusterKafkaConnectArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether Kafka Connect is enabled.
        """
elif False:
    ClusterKafkaConnectArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterKafkaConnectArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Whether Kafka Connect is enabled.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether Kafka Connect is enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class ClusterMaintenanceWindowConfigArgsDict(TypedDict):
        anytime: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If true, maintenance can occur at any time.
        """
        day_hour: NotRequired[pulumi.Input['ClusterMaintenanceWindowConfigDayHourArgsDict']]
        unspecified: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If true, maintenance window is unspecified.
        """
elif False:
    ClusterMaintenanceWindowConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterMaintenanceWindowConfigArgs:
    def __init__(__self__, *,
                 anytime: Optional[pulumi.Input[_builtins.bool]] = None,
                 day_hour: Optional[pulumi.Input['ClusterMaintenanceWindowConfigDayHourArgs']] = None,
                 unspecified: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] anytime: If true, maintenance can occur at any time.
        :param pulumi.Input[_builtins.bool] unspecified: If true, maintenance window is unspecified.
        """
        if anytime is not None:
            pulumi.set(__self__, "anytime", anytime)
        if day_hour is not None:
            pulumi.set(__self__, "day_hour", day_hour)
        if unspecified is not None:
            pulumi.set(__self__, "unspecified", unspecified)

    @_builtins.property
    @pulumi.getter
    def anytime(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If true, maintenance can occur at any time.
        """
        return pulumi.get(self, "anytime")

    @anytime.setter
    def anytime(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "anytime", value)

    @_builtins.property
    @pulumi.getter(name="dayHour")
    def day_hour(self) -> Optional[pulumi.Input['ClusterMaintenanceWindowConfigDayHourArgs']]:
        return pulumi.get(self, "day_hour")

    @day_hour.setter
    def day_hour(self, value: Optional[pulumi.Input['ClusterMaintenanceWindowConfigDayHourArgs']]):
        pulumi.set(self, "day_hour", value)

    @_builtins.property
    @pulumi.getter
    def unspecified(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If true, maintenance window is unspecified.
        """
        return pulumi.get(self, "unspecified")

    @unspecified.setter
    def unspecified(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "unspecified", value)


if not MYPY:
    class ClusterMaintenanceWindowConfigDayHourArgsDict(TypedDict):
        day_of_week: NotRequired[pulumi.Input[_builtins.str]]
        """
        Day of week.
        """
        hour_of_day: NotRequired[pulumi.Input[_builtins.int]]
        """
        Hour of day.
        """
elif False:
    ClusterMaintenanceWindowConfigDayHourArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterMaintenanceWindowConfigDayHourArgs:
    def __init__(__self__, *,
                 day_of_week: Optional[pulumi.Input[_builtins.str]] = None,
                 hour_of_day: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] day_of_week: Day of week.
        :param pulumi.Input[_builtins.int] hour_of_day: Hour of day.
        """
        if day_of_week is not None:
            pulumi.set(__self__, "day_of_week", day_of_week)
        if hour_of_day is not None:
            pulumi.set(__self__, "hour_of_day", hour_of_day)

    @_builtins.property
    @pulumi.getter(name="dayOfWeek")
    def day_of_week(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Day of week.
        """
        return pulumi.get(self, "day_of_week")

    @day_of_week.setter
    def day_of_week(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "day_of_week", value)

    @_builtins.property
    @pulumi.getter(name="hourOfDay")
    def hour_of_day(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Hour of day.
        """
        return pulumi.get(self, "hour_of_day")

    @hour_of_day.setter
    def hour_of_day(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "hour_of_day", value)


if not MYPY:
    class ClusterPrometheusArgsDict(TypedDict):
        url: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Prometheus metrics endpoint URL.
        """
elif False:
    ClusterPrometheusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterPrometheusArgs:
    def __init__(__self__, *,
                 url: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] url: The Prometheus metrics endpoint URL.
        """
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Prometheus metrics endpoint URL.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "url", value)


if not MYPY:
    class ClusterRedpandaConsoleArgsDict(TypedDict):
        url: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Redpanda Console URL.
        """
elif False:
    ClusterRedpandaConsoleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterRedpandaConsoleArgs:
    def __init__(__self__, *,
                 url: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] url: The Redpanda Console URL.
        """
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Redpanda Console URL.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "url", value)


if not MYPY:
    class ClusterSchemaRegistryArgsDict(TypedDict):
        mtls: NotRequired[pulumi.Input['ClusterSchemaRegistryMtlsArgsDict']]
        """
        mTLS configuration.
        """
        url: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Schema Registry URL.
        """
elif False:
    ClusterSchemaRegistryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterSchemaRegistryArgs:
    def __init__(__self__, *,
                 mtls: Optional[pulumi.Input['ClusterSchemaRegistryMtlsArgs']] = None,
                 url: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['ClusterSchemaRegistryMtlsArgs'] mtls: mTLS configuration.
        :param pulumi.Input[_builtins.str] url: The Schema Registry URL.
        """
        if mtls is not None:
            pulumi.set(__self__, "mtls", mtls)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def mtls(self) -> Optional[pulumi.Input['ClusterSchemaRegistryMtlsArgs']]:
        """
        mTLS configuration.
        """
        return pulumi.get(self, "mtls")

    @mtls.setter
    def mtls(self, value: Optional[pulumi.Input['ClusterSchemaRegistryMtlsArgs']]):
        pulumi.set(self, "mtls", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Schema Registry URL.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "url", value)


if not MYPY:
    class ClusterSchemaRegistryMtlsArgsDict(TypedDict):
        ca_certificates_pems: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        CA certificate in PEM format.
        """
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether mTLS is enabled.
        """
        principal_mapping_rules: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Principal mapping rules for mTLS authentication. See the Redpanda documentation on configuring authentication.
        """
elif False:
    ClusterSchemaRegistryMtlsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterSchemaRegistryMtlsArgs:
    def __init__(__self__, *,
                 ca_certificates_pems: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 principal_mapping_rules: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] ca_certificates_pems: CA certificate in PEM format.
        :param pulumi.Input[_builtins.bool] enabled: Whether mTLS is enabled.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] principal_mapping_rules: Principal mapping rules for mTLS authentication. See the Redpanda documentation on configuring authentication.
        """
        if ca_certificates_pems is not None:
            pulumi.set(__self__, "ca_certificates_pems", ca_certificates_pems)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if principal_mapping_rules is not None:
            pulumi.set(__self__, "principal_mapping_rules", principal_mapping_rules)

    @_builtins.property
    @pulumi.getter(name="caCertificatesPems")
    def ca_certificates_pems(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        CA certificate in PEM format.
        """
        return pulumi.get(self, "ca_certificates_pems")

    @ca_certificates_pems.setter
    def ca_certificates_pems(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "ca_certificates_pems", value)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether mTLS is enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="principalMappingRules")
    def principal_mapping_rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Principal mapping rules for mTLS authentication. See the Redpanda documentation on configuring authentication.
        """
        return pulumi.get(self, "principal_mapping_rules")

    @principal_mapping_rules.setter
    def principal_mapping_rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "principal_mapping_rules", value)


if not MYPY:
    class ClusterStateDescriptionArgsDict(TypedDict):
        code: NotRequired[pulumi.Input[_builtins.int]]
        """
        Error code if cluster is in error state.
        """
        message: NotRequired[pulumi.Input[_builtins.str]]
        """
        Detailed error message if cluster is in error state.
        """
elif False:
    ClusterStateDescriptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterStateDescriptionArgs:
    def __init__(__self__, *,
                 code: Optional[pulumi.Input[_builtins.int]] = None,
                 message: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] code: Error code if cluster is in error state.
        :param pulumi.Input[_builtins.str] message: Detailed error message if cluster is in error state.
        """
        if code is not None:
            pulumi.set(__self__, "code", code)
        if message is not None:
            pulumi.set(__self__, "message", message)

    @_builtins.property
    @pulumi.getter
    def code(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Error code if cluster is in error state.
        """
        return pulumi.get(self, "code")

    @code.setter
    def code(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "code", value)

    @_builtins.property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Detailed error message if cluster is in error state.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "message", value)


if not MYPY:
    class NetworkCustomerManagedResourcesArgsDict(TypedDict):
        aws: NotRequired[pulumi.Input['NetworkCustomerManagedResourcesAwsArgsDict']]
        gcp: NotRequired[pulumi.Input['NetworkCustomerManagedResourcesGcpArgsDict']]
elif False:
    NetworkCustomerManagedResourcesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkCustomerManagedResourcesArgs:
    def __init__(__self__, *,
                 aws: Optional[pulumi.Input['NetworkCustomerManagedResourcesAwsArgs']] = None,
                 gcp: Optional[pulumi.Input['NetworkCustomerManagedResourcesGcpArgs']] = None):
        if aws is not None:
            pulumi.set(__self__, "aws", aws)
        if gcp is not None:
            pulumi.set(__self__, "gcp", gcp)

    @_builtins.property
    @pulumi.getter
    def aws(self) -> Optional[pulumi.Input['NetworkCustomerManagedResourcesAwsArgs']]:
        return pulumi.get(self, "aws")

    @aws.setter
    def aws(self, value: Optional[pulumi.Input['NetworkCustomerManagedResourcesAwsArgs']]):
        pulumi.set(self, "aws", value)

    @_builtins.property
    @pulumi.getter
    def gcp(self) -> Optional[pulumi.Input['NetworkCustomerManagedResourcesGcpArgs']]:
        return pulumi.get(self, "gcp")

    @gcp.setter
    def gcp(self, value: Optional[pulumi.Input['NetworkCustomerManagedResourcesGcpArgs']]):
        pulumi.set(self, "gcp", value)


if not MYPY:
    class NetworkCustomerManagedResourcesAwsArgsDict(TypedDict):
        dynamodb_table: pulumi.Input['NetworkCustomerManagedResourcesAwsDynamodbTableArgsDict']
        management_bucket: pulumi.Input['NetworkCustomerManagedResourcesAwsManagementBucketArgsDict']
        private_subnets: pulumi.Input['NetworkCustomerManagedResourcesAwsPrivateSubnetsArgsDict']
        vpc: pulumi.Input['NetworkCustomerManagedResourcesAwsVpcArgsDict']
elif False:
    NetworkCustomerManagedResourcesAwsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkCustomerManagedResourcesAwsArgs:
    def __init__(__self__, *,
                 dynamodb_table: pulumi.Input['NetworkCustomerManagedResourcesAwsDynamodbTableArgs'],
                 management_bucket: pulumi.Input['NetworkCustomerManagedResourcesAwsManagementBucketArgs'],
                 private_subnets: pulumi.Input['NetworkCustomerManagedResourcesAwsPrivateSubnetsArgs'],
                 vpc: pulumi.Input['NetworkCustomerManagedResourcesAwsVpcArgs']):
        pulumi.set(__self__, "dynamodb_table", dynamodb_table)
        pulumi.set(__self__, "management_bucket", management_bucket)
        pulumi.set(__self__, "private_subnets", private_subnets)
        pulumi.set(__self__, "vpc", vpc)

    @_builtins.property
    @pulumi.getter(name="dynamodbTable")
    def dynamodb_table(self) -> pulumi.Input['NetworkCustomerManagedResourcesAwsDynamodbTableArgs']:
        return pulumi.get(self, "dynamodb_table")

    @dynamodb_table.setter
    def dynamodb_table(self, value: pulumi.Input['NetworkCustomerManagedResourcesAwsDynamodbTableArgs']):
        pulumi.set(self, "dynamodb_table", value)

    @_builtins.property
    @pulumi.getter(name="managementBucket")
    def management_bucket(self) -> pulumi.Input['NetworkCustomerManagedResourcesAwsManagementBucketArgs']:
        return pulumi.get(self, "management_bucket")

    @management_bucket.setter
    def management_bucket(self, value: pulumi.Input['NetworkCustomerManagedResourcesAwsManagementBucketArgs']):
        pulumi.set(self, "management_bucket", value)

    @_builtins.property
    @pulumi.getter(name="privateSubnets")
    def private_subnets(self) -> pulumi.Input['NetworkCustomerManagedResourcesAwsPrivateSubnetsArgs']:
        return pulumi.get(self, "private_subnets")

    @private_subnets.setter
    def private_subnets(self, value: pulumi.Input['NetworkCustomerManagedResourcesAwsPrivateSubnetsArgs']):
        pulumi.set(self, "private_subnets", value)

    @_builtins.property
    @pulumi.getter
    def vpc(self) -> pulumi.Input['NetworkCustomerManagedResourcesAwsVpcArgs']:
        return pulumi.get(self, "vpc")

    @vpc.setter
    def vpc(self, value: pulumi.Input['NetworkCustomerManagedResourcesAwsVpcArgs']):
        pulumi.set(self, "vpc", value)


if not MYPY:
    class NetworkCustomerManagedResourcesAwsDynamodbTableArgsDict(TypedDict):
        arn: pulumi.Input[_builtins.str]
        """
        AWS DynamoDB table identifier
        """
elif False:
    NetworkCustomerManagedResourcesAwsDynamodbTableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkCustomerManagedResourcesAwsDynamodbTableArgs:
    def __init__(__self__, *,
                 arn: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] arn: AWS DynamoDB table identifier
        """
        pulumi.set(__self__, "arn", arn)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> pulumi.Input[_builtins.str]:
        """
        AWS DynamoDB table identifier
        """
        return pulumi.get(self, "arn")

    @arn.setter
    def arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "arn", value)


if not MYPY:
    class NetworkCustomerManagedResourcesAwsManagementBucketArgsDict(TypedDict):
        arn: pulumi.Input[_builtins.str]
        """
        AWS storage bucket identifier
        """
elif False:
    NetworkCustomerManagedResourcesAwsManagementBucketArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkCustomerManagedResourcesAwsManagementBucketArgs:
    def __init__(__self__, *,
                 arn: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] arn: AWS storage bucket identifier
        """
        pulumi.set(__self__, "arn", arn)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> pulumi.Input[_builtins.str]:
        """
        AWS storage bucket identifier
        """
        return pulumi.get(self, "arn")

    @arn.setter
    def arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "arn", value)


if not MYPY:
    class NetworkCustomerManagedResourcesAwsPrivateSubnetsArgsDict(TypedDict):
        arns: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        AWS private subnet identifiers
        """
elif False:
    NetworkCustomerManagedResourcesAwsPrivateSubnetsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkCustomerManagedResourcesAwsPrivateSubnetsArgs:
    def __init__(__self__, *,
                 arns: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] arns: AWS private subnet identifiers
        """
        pulumi.set(__self__, "arns", arns)

    @_builtins.property
    @pulumi.getter
    def arns(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        AWS private subnet identifiers
        """
        return pulumi.get(self, "arns")

    @arns.setter
    def arns(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "arns", value)


if not MYPY:
    class NetworkCustomerManagedResourcesAwsVpcArgsDict(TypedDict):
        arn: pulumi.Input[_builtins.str]
        """
        AWS VPC identifier
        """
elif False:
    NetworkCustomerManagedResourcesAwsVpcArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkCustomerManagedResourcesAwsVpcArgs:
    def __init__(__self__, *,
                 arn: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] arn: AWS VPC identifier
        """
        pulumi.set(__self__, "arn", arn)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> pulumi.Input[_builtins.str]:
        """
        AWS VPC identifier
        """
        return pulumi.get(self, "arn")

    @arn.setter
    def arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "arn", value)


if not MYPY:
    class NetworkCustomerManagedResourcesGcpArgsDict(TypedDict):
        management_bucket: pulumi.Input['NetworkCustomerManagedResourcesGcpManagementBucketArgsDict']
        network_name: pulumi.Input[_builtins.str]
        """
        Name of user-created network where the Redpanda cluster is deployed
        """
        network_project_id: pulumi.Input[_builtins.str]
        """
        GCP project ID where the network is created
        """
elif False:
    NetworkCustomerManagedResourcesGcpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkCustomerManagedResourcesGcpArgs:
    def __init__(__self__, *,
                 management_bucket: pulumi.Input['NetworkCustomerManagedResourcesGcpManagementBucketArgs'],
                 network_name: pulumi.Input[_builtins.str],
                 network_project_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] network_name: Name of user-created network where the Redpanda cluster is deployed
        :param pulumi.Input[_builtins.str] network_project_id: GCP project ID where the network is created
        """
        pulumi.set(__self__, "management_bucket", management_bucket)
        pulumi.set(__self__, "network_name", network_name)
        pulumi.set(__self__, "network_project_id", network_project_id)

    @_builtins.property
    @pulumi.getter(name="managementBucket")
    def management_bucket(self) -> pulumi.Input['NetworkCustomerManagedResourcesGcpManagementBucketArgs']:
        return pulumi.get(self, "management_bucket")

    @management_bucket.setter
    def management_bucket(self, value: pulumi.Input['NetworkCustomerManagedResourcesGcpManagementBucketArgs']):
        pulumi.set(self, "management_bucket", value)

    @_builtins.property
    @pulumi.getter(name="networkName")
    def network_name(self) -> pulumi.Input[_builtins.str]:
        """
        Name of user-created network where the Redpanda cluster is deployed
        """
        return pulumi.get(self, "network_name")

    @network_name.setter
    def network_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "network_name", value)

    @_builtins.property
    @pulumi.getter(name="networkProjectId")
    def network_project_id(self) -> pulumi.Input[_builtins.str]:
        """
        GCP project ID where the network is created
        """
        return pulumi.get(self, "network_project_id")

    @network_project_id.setter
    def network_project_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "network_project_id", value)


if not MYPY:
    class NetworkCustomerManagedResourcesGcpManagementBucketArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        GCP storage bucket name for storing the state of Redpanda cluster deployment
        """
elif False:
    NetworkCustomerManagedResourcesGcpManagementBucketArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkCustomerManagedResourcesGcpManagementBucketArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] name: GCP storage bucket name for storing the state of Redpanda cluster deployment
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        GCP storage bucket name for storing the state of Redpanda cluster deployment
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


