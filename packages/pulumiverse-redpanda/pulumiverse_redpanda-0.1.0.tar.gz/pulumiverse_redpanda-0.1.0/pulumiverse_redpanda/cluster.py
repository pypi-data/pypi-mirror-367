# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities
from . import outputs
from ._inputs import *

__all__ = ['ClusterArgs', 'Cluster']

@pulumi.input_type
class ClusterArgs:
    def __init__(__self__, *,
                 cluster_type: pulumi.Input[_builtins.str],
                 connection_type: pulumi.Input[_builtins.str],
                 network_id: pulumi.Input[_builtins.str],
                 resource_group_id: pulumi.Input[_builtins.str],
                 throughput_tier: pulumi.Input[_builtins.str],
                 allow_deletion: Optional[pulumi.Input[_builtins.bool]] = None,
                 aws_private_link: Optional[pulumi.Input['ClusterAwsPrivateLinkArgs']] = None,
                 azure_private_link: Optional[pulumi.Input['ClusterAzurePrivateLinkArgs']] = None,
                 cloud_provider: Optional[pulumi.Input[_builtins.str]] = None,
                 customer_managed_resources: Optional[pulumi.Input['ClusterCustomerManagedResourcesArgs']] = None,
                 gcp_global_access_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 gcp_private_service_connect: Optional[pulumi.Input['ClusterGcpPrivateServiceConnectArgs']] = None,
                 http_proxy: Optional[pulumi.Input['ClusterHttpProxyArgs']] = None,
                 kafka_api: Optional[pulumi.Input['ClusterKafkaApiArgs']] = None,
                 kafka_connect: Optional[pulumi.Input['ClusterKafkaConnectArgs']] = None,
                 maintenance_window_config: Optional[pulumi.Input['ClusterMaintenanceWindowConfigArgs']] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 read_replica_cluster_ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 redpanda_version: Optional[pulumi.Input[_builtins.str]] = None,
                 region: Optional[pulumi.Input[_builtins.str]] = None,
                 schema_registry: Optional[pulumi.Input['ClusterSchemaRegistryArgs']] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 zones: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        The set of arguments for constructing a Cluster resource.
        :param pulumi.Input[_builtins.str] cluster_type: Cluster type. Type is immutable and can only be set on cluster creation.
        :param pulumi.Input[_builtins.str] connection_type: Cluster connection type. Private clusters are not exposed to the internet. For BYOC clusters, Private is best-practice.
        :param pulumi.Input[_builtins.str] network_id: Network ID where cluster is placed.
        :param pulumi.Input[_builtins.str] resource_group_id: Resource group ID of the cluster.
        :param pulumi.Input[_builtins.str] throughput_tier: Throughput tier of the cluster.
        :param pulumi.Input[_builtins.bool] allow_deletion: Allows deletion of the cluster. Defaults to false.
        :param pulumi.Input['ClusterAwsPrivateLinkArgs'] aws_private_link: AWS PrivateLink configuration.
        :param pulumi.Input['ClusterAzurePrivateLinkArgs'] azure_private_link: Azure Private Link configuration.
        :param pulumi.Input[_builtins.str] cloud_provider: Cloud provider where resources are created.
        :param pulumi.Input['ClusterCustomerManagedResourcesArgs'] customer_managed_resources: Customer managed resources configuration for the cluster.
        :param pulumi.Input[_builtins.bool] gcp_global_access_enabled: If true, GCP global access is enabled.
        :param pulumi.Input['ClusterGcpPrivateServiceConnectArgs'] gcp_private_service_connect: GCP Private Service Connect configuration.
        :param pulumi.Input['ClusterHttpProxyArgs'] http_proxy: HTTP Proxy properties.
        :param pulumi.Input['ClusterKafkaApiArgs'] kafka_api: Cluster's Kafka API properties.
        :param pulumi.Input['ClusterKafkaConnectArgs'] kafka_connect: Kafka Connect configuration.
        :param pulumi.Input['ClusterMaintenanceWindowConfigArgs'] maintenance_window_config: Maintenance window configuration for the cluster.
        :param pulumi.Input[_builtins.str] name: Unique name of the cluster.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] read_replica_cluster_ids: IDs of clusters that can create read-only topics from this cluster.
        :param pulumi.Input[_builtins.str] redpanda_version: Current Redpanda version of the cluster.
        :param pulumi.Input[_builtins.str] region: Cloud provider region. Region represents the name of the region where the cluster will be provisioned.
        :param pulumi.Input['ClusterSchemaRegistryArgs'] schema_registry: Schema Registry properties.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags placed on cloud resources. If the cloud provider is GCP and the name of a tag has the prefix "gcp.network-tag.", the tag is a network tag that will be added to the Redpanda cluster GKE nodes. Otherwise, the tag is a normal tag. For example, if the name of a tag is "gcp.network-tag.network-tag-foo", the network tag named "network-tag-foo" will be added to the Redpanda cluster GKE nodes. Note: The value of a network tag will be ignored. See the details on network tags at https://cloud.google.com/vpc/docs/add-remove-network-tags.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] zones: Zones of the cluster. Must be valid zones within the selected region. If multiple zones are used, the cluster is a multi-AZ cluster.
        """
        pulumi.set(__self__, "cluster_type", cluster_type)
        pulumi.set(__self__, "connection_type", connection_type)
        pulumi.set(__self__, "network_id", network_id)
        pulumi.set(__self__, "resource_group_id", resource_group_id)
        pulumi.set(__self__, "throughput_tier", throughput_tier)
        if allow_deletion is not None:
            pulumi.set(__self__, "allow_deletion", allow_deletion)
        if aws_private_link is not None:
            pulumi.set(__self__, "aws_private_link", aws_private_link)
        if azure_private_link is not None:
            pulumi.set(__self__, "azure_private_link", azure_private_link)
        if cloud_provider is not None:
            pulumi.set(__self__, "cloud_provider", cloud_provider)
        if customer_managed_resources is not None:
            pulumi.set(__self__, "customer_managed_resources", customer_managed_resources)
        if gcp_global_access_enabled is not None:
            pulumi.set(__self__, "gcp_global_access_enabled", gcp_global_access_enabled)
        if gcp_private_service_connect is not None:
            pulumi.set(__self__, "gcp_private_service_connect", gcp_private_service_connect)
        if http_proxy is not None:
            pulumi.set(__self__, "http_proxy", http_proxy)
        if kafka_api is not None:
            pulumi.set(__self__, "kafka_api", kafka_api)
        if kafka_connect is not None:
            pulumi.set(__self__, "kafka_connect", kafka_connect)
        if maintenance_window_config is not None:
            pulumi.set(__self__, "maintenance_window_config", maintenance_window_config)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if read_replica_cluster_ids is not None:
            pulumi.set(__self__, "read_replica_cluster_ids", read_replica_cluster_ids)
        if redpanda_version is not None:
            pulumi.set(__self__, "redpanda_version", redpanda_version)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if schema_registry is not None:
            pulumi.set(__self__, "schema_registry", schema_registry)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if zones is not None:
            pulumi.set(__self__, "zones", zones)

    @_builtins.property
    @pulumi.getter(name="clusterType")
    def cluster_type(self) -> pulumi.Input[_builtins.str]:
        """
        Cluster type. Type is immutable and can only be set on cluster creation.
        """
        return pulumi.get(self, "cluster_type")

    @cluster_type.setter
    def cluster_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "cluster_type", value)

    @_builtins.property
    @pulumi.getter(name="connectionType")
    def connection_type(self) -> pulumi.Input[_builtins.str]:
        """
        Cluster connection type. Private clusters are not exposed to the internet. For BYOC clusters, Private is best-practice.
        """
        return pulumi.get(self, "connection_type")

    @connection_type.setter
    def connection_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "connection_type", value)

    @_builtins.property
    @pulumi.getter(name="networkId")
    def network_id(self) -> pulumi.Input[_builtins.str]:
        """
        Network ID where cluster is placed.
        """
        return pulumi.get(self, "network_id")

    @network_id.setter
    def network_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "network_id", value)

    @_builtins.property
    @pulumi.getter(name="resourceGroupId")
    def resource_group_id(self) -> pulumi.Input[_builtins.str]:
        """
        Resource group ID of the cluster.
        """
        return pulumi.get(self, "resource_group_id")

    @resource_group_id.setter
    def resource_group_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "resource_group_id", value)

    @_builtins.property
    @pulumi.getter(name="throughputTier")
    def throughput_tier(self) -> pulumi.Input[_builtins.str]:
        """
        Throughput tier of the cluster.
        """
        return pulumi.get(self, "throughput_tier")

    @throughput_tier.setter
    def throughput_tier(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "throughput_tier", value)

    @_builtins.property
    @pulumi.getter(name="allowDeletion")
    def allow_deletion(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Allows deletion of the cluster. Defaults to false.
        """
        return pulumi.get(self, "allow_deletion")

    @allow_deletion.setter
    def allow_deletion(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "allow_deletion", value)

    @_builtins.property
    @pulumi.getter(name="awsPrivateLink")
    def aws_private_link(self) -> Optional[pulumi.Input['ClusterAwsPrivateLinkArgs']]:
        """
        AWS PrivateLink configuration.
        """
        return pulumi.get(self, "aws_private_link")

    @aws_private_link.setter
    def aws_private_link(self, value: Optional[pulumi.Input['ClusterAwsPrivateLinkArgs']]):
        pulumi.set(self, "aws_private_link", value)

    @_builtins.property
    @pulumi.getter(name="azurePrivateLink")
    def azure_private_link(self) -> Optional[pulumi.Input['ClusterAzurePrivateLinkArgs']]:
        """
        Azure Private Link configuration.
        """
        return pulumi.get(self, "azure_private_link")

    @azure_private_link.setter
    def azure_private_link(self, value: Optional[pulumi.Input['ClusterAzurePrivateLinkArgs']]):
        pulumi.set(self, "azure_private_link", value)

    @_builtins.property
    @pulumi.getter(name="cloudProvider")
    def cloud_provider(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Cloud provider where resources are created.
        """
        return pulumi.get(self, "cloud_provider")

    @cloud_provider.setter
    def cloud_provider(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cloud_provider", value)

    @_builtins.property
    @pulumi.getter(name="customerManagedResources")
    def customer_managed_resources(self) -> Optional[pulumi.Input['ClusterCustomerManagedResourcesArgs']]:
        """
        Customer managed resources configuration for the cluster.
        """
        return pulumi.get(self, "customer_managed_resources")

    @customer_managed_resources.setter
    def customer_managed_resources(self, value: Optional[pulumi.Input['ClusterCustomerManagedResourcesArgs']]):
        pulumi.set(self, "customer_managed_resources", value)

    @_builtins.property
    @pulumi.getter(name="gcpGlobalAccessEnabled")
    def gcp_global_access_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If true, GCP global access is enabled.
        """
        return pulumi.get(self, "gcp_global_access_enabled")

    @gcp_global_access_enabled.setter
    def gcp_global_access_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "gcp_global_access_enabled", value)

    @_builtins.property
    @pulumi.getter(name="gcpPrivateServiceConnect")
    def gcp_private_service_connect(self) -> Optional[pulumi.Input['ClusterGcpPrivateServiceConnectArgs']]:
        """
        GCP Private Service Connect configuration.
        """
        return pulumi.get(self, "gcp_private_service_connect")

    @gcp_private_service_connect.setter
    def gcp_private_service_connect(self, value: Optional[pulumi.Input['ClusterGcpPrivateServiceConnectArgs']]):
        pulumi.set(self, "gcp_private_service_connect", value)

    @_builtins.property
    @pulumi.getter(name="httpProxy")
    def http_proxy(self) -> Optional[pulumi.Input['ClusterHttpProxyArgs']]:
        """
        HTTP Proxy properties.
        """
        return pulumi.get(self, "http_proxy")

    @http_proxy.setter
    def http_proxy(self, value: Optional[pulumi.Input['ClusterHttpProxyArgs']]):
        pulumi.set(self, "http_proxy", value)

    @_builtins.property
    @pulumi.getter(name="kafkaApi")
    def kafka_api(self) -> Optional[pulumi.Input['ClusterKafkaApiArgs']]:
        """
        Cluster's Kafka API properties.
        """
        return pulumi.get(self, "kafka_api")

    @kafka_api.setter
    def kafka_api(self, value: Optional[pulumi.Input['ClusterKafkaApiArgs']]):
        pulumi.set(self, "kafka_api", value)

    @_builtins.property
    @pulumi.getter(name="kafkaConnect")
    def kafka_connect(self) -> Optional[pulumi.Input['ClusterKafkaConnectArgs']]:
        """
        Kafka Connect configuration.
        """
        return pulumi.get(self, "kafka_connect")

    @kafka_connect.setter
    def kafka_connect(self, value: Optional[pulumi.Input['ClusterKafkaConnectArgs']]):
        pulumi.set(self, "kafka_connect", value)

    @_builtins.property
    @pulumi.getter(name="maintenanceWindowConfig")
    def maintenance_window_config(self) -> Optional[pulumi.Input['ClusterMaintenanceWindowConfigArgs']]:
        """
        Maintenance window configuration for the cluster.
        """
        return pulumi.get(self, "maintenance_window_config")

    @maintenance_window_config.setter
    def maintenance_window_config(self, value: Optional[pulumi.Input['ClusterMaintenanceWindowConfigArgs']]):
        pulumi.set(self, "maintenance_window_config", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Unique name of the cluster.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="readReplicaClusterIds")
    def read_replica_cluster_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        IDs of clusters that can create read-only topics from this cluster.
        """
        return pulumi.get(self, "read_replica_cluster_ids")

    @read_replica_cluster_ids.setter
    def read_replica_cluster_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "read_replica_cluster_ids", value)

    @_builtins.property
    @pulumi.getter(name="redpandaVersion")
    def redpanda_version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Current Redpanda version of the cluster.
        """
        return pulumi.get(self, "redpanda_version")

    @redpanda_version.setter
    def redpanda_version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "redpanda_version", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Cloud provider region. Region represents the name of the region where the cluster will be provisioned.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter(name="schemaRegistry")
    def schema_registry(self) -> Optional[pulumi.Input['ClusterSchemaRegistryArgs']]:
        """
        Schema Registry properties.
        """
        return pulumi.get(self, "schema_registry")

    @schema_registry.setter
    def schema_registry(self, value: Optional[pulumi.Input['ClusterSchemaRegistryArgs']]):
        pulumi.set(self, "schema_registry", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags placed on cloud resources. If the cloud provider is GCP and the name of a tag has the prefix "gcp.network-tag.", the tag is a network tag that will be added to the Redpanda cluster GKE nodes. Otherwise, the tag is a normal tag. For example, if the name of a tag is "gcp.network-tag.network-tag-foo", the network tag named "network-tag-foo" will be added to the Redpanda cluster GKE nodes. Note: The value of a network tag will be ignored. See the details on network tags at https://cloud.google.com/vpc/docs/add-remove-network-tags.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)

    @_builtins.property
    @pulumi.getter
    def zones(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Zones of the cluster. Must be valid zones within the selected region. If multiple zones are used, the cluster is a multi-AZ cluster.
        """
        return pulumi.get(self, "zones")

    @zones.setter
    def zones(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "zones", value)


@pulumi.input_type
class _ClusterState:
    def __init__(__self__, *,
                 allow_deletion: Optional[pulumi.Input[_builtins.bool]] = None,
                 aws_private_link: Optional[pulumi.Input['ClusterAwsPrivateLinkArgs']] = None,
                 azure_private_link: Optional[pulumi.Input['ClusterAzurePrivateLinkArgs']] = None,
                 cloud_provider: Optional[pulumi.Input[_builtins.str]] = None,
                 cluster_api_url: Optional[pulumi.Input[_builtins.str]] = None,
                 cluster_type: Optional[pulumi.Input[_builtins.str]] = None,
                 connection_type: Optional[pulumi.Input[_builtins.str]] = None,
                 created_at: Optional[pulumi.Input[_builtins.str]] = None,
                 customer_managed_resources: Optional[pulumi.Input['ClusterCustomerManagedResourcesArgs']] = None,
                 gcp_global_access_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 gcp_private_service_connect: Optional[pulumi.Input['ClusterGcpPrivateServiceConnectArgs']] = None,
                 http_proxy: Optional[pulumi.Input['ClusterHttpProxyArgs']] = None,
                 kafka_api: Optional[pulumi.Input['ClusterKafkaApiArgs']] = None,
                 kafka_connect: Optional[pulumi.Input['ClusterKafkaConnectArgs']] = None,
                 maintenance_window_config: Optional[pulumi.Input['ClusterMaintenanceWindowConfigArgs']] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 network_id: Optional[pulumi.Input[_builtins.str]] = None,
                 prometheus: Optional[pulumi.Input['ClusterPrometheusArgs']] = None,
                 read_replica_cluster_ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 redpanda_console: Optional[pulumi.Input['ClusterRedpandaConsoleArgs']] = None,
                 redpanda_version: Optional[pulumi.Input[_builtins.str]] = None,
                 region: Optional[pulumi.Input[_builtins.str]] = None,
                 resource_group_id: Optional[pulumi.Input[_builtins.str]] = None,
                 schema_registry: Optional[pulumi.Input['ClusterSchemaRegistryArgs']] = None,
                 state: Optional[pulumi.Input[_builtins.str]] = None,
                 state_description: Optional[pulumi.Input['ClusterStateDescriptionArgs']] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 throughput_tier: Optional[pulumi.Input[_builtins.str]] = None,
                 zones: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        Input properties used for looking up and filtering Cluster resources.
        :param pulumi.Input[_builtins.bool] allow_deletion: Allows deletion of the cluster. Defaults to false.
        :param pulumi.Input['ClusterAwsPrivateLinkArgs'] aws_private_link: AWS PrivateLink configuration.
        :param pulumi.Input['ClusterAzurePrivateLinkArgs'] azure_private_link: Azure Private Link configuration.
        :param pulumi.Input[_builtins.str] cloud_provider: Cloud provider where resources are created.
        :param pulumi.Input[_builtins.str] cluster_api_url: The URL of the cluster API.
        :param pulumi.Input[_builtins.str] cluster_type: Cluster type. Type is immutable and can only be set on cluster creation.
        :param pulumi.Input[_builtins.str] connection_type: Cluster connection type. Private clusters are not exposed to the internet. For BYOC clusters, Private is best-practice.
        :param pulumi.Input[_builtins.str] created_at: Timestamp when the cluster was created.
        :param pulumi.Input['ClusterCustomerManagedResourcesArgs'] customer_managed_resources: Customer managed resources configuration for the cluster.
        :param pulumi.Input[_builtins.bool] gcp_global_access_enabled: If true, GCP global access is enabled.
        :param pulumi.Input['ClusterGcpPrivateServiceConnectArgs'] gcp_private_service_connect: GCP Private Service Connect configuration.
        :param pulumi.Input['ClusterHttpProxyArgs'] http_proxy: HTTP Proxy properties.
        :param pulumi.Input['ClusterKafkaApiArgs'] kafka_api: Cluster's Kafka API properties.
        :param pulumi.Input['ClusterKafkaConnectArgs'] kafka_connect: Kafka Connect configuration.
        :param pulumi.Input['ClusterMaintenanceWindowConfigArgs'] maintenance_window_config: Maintenance window configuration for the cluster.
        :param pulumi.Input[_builtins.str] name: Unique name of the cluster.
        :param pulumi.Input[_builtins.str] network_id: Network ID where cluster is placed.
        :param pulumi.Input['ClusterPrometheusArgs'] prometheus: Prometheus metrics endpoint properties.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] read_replica_cluster_ids: IDs of clusters that can create read-only topics from this cluster.
        :param pulumi.Input['ClusterRedpandaConsoleArgs'] redpanda_console: Redpanda Console properties.
        :param pulumi.Input[_builtins.str] redpanda_version: Current Redpanda version of the cluster.
        :param pulumi.Input[_builtins.str] region: Cloud provider region. Region represents the name of the region where the cluster will be provisioned.
        :param pulumi.Input[_builtins.str] resource_group_id: Resource group ID of the cluster.
        :param pulumi.Input['ClusterSchemaRegistryArgs'] schema_registry: Schema Registry properties.
        :param pulumi.Input[_builtins.str] state: Current state of the cluster.
        :param pulumi.Input['ClusterStateDescriptionArgs'] state_description: Detailed state description when cluster is in a non-ready state.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags placed on cloud resources. If the cloud provider is GCP and the name of a tag has the prefix "gcp.network-tag.", the tag is a network tag that will be added to the Redpanda cluster GKE nodes. Otherwise, the tag is a normal tag. For example, if the name of a tag is "gcp.network-tag.network-tag-foo", the network tag named "network-tag-foo" will be added to the Redpanda cluster GKE nodes. Note: The value of a network tag will be ignored. See the details on network tags at https://cloud.google.com/vpc/docs/add-remove-network-tags.
        :param pulumi.Input[_builtins.str] throughput_tier: Throughput tier of the cluster.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] zones: Zones of the cluster. Must be valid zones within the selected region. If multiple zones are used, the cluster is a multi-AZ cluster.
        """
        if allow_deletion is not None:
            pulumi.set(__self__, "allow_deletion", allow_deletion)
        if aws_private_link is not None:
            pulumi.set(__self__, "aws_private_link", aws_private_link)
        if azure_private_link is not None:
            pulumi.set(__self__, "azure_private_link", azure_private_link)
        if cloud_provider is not None:
            pulumi.set(__self__, "cloud_provider", cloud_provider)
        if cluster_api_url is not None:
            pulumi.set(__self__, "cluster_api_url", cluster_api_url)
        if cluster_type is not None:
            pulumi.set(__self__, "cluster_type", cluster_type)
        if connection_type is not None:
            pulumi.set(__self__, "connection_type", connection_type)
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if customer_managed_resources is not None:
            pulumi.set(__self__, "customer_managed_resources", customer_managed_resources)
        if gcp_global_access_enabled is not None:
            pulumi.set(__self__, "gcp_global_access_enabled", gcp_global_access_enabled)
        if gcp_private_service_connect is not None:
            pulumi.set(__self__, "gcp_private_service_connect", gcp_private_service_connect)
        if http_proxy is not None:
            pulumi.set(__self__, "http_proxy", http_proxy)
        if kafka_api is not None:
            pulumi.set(__self__, "kafka_api", kafka_api)
        if kafka_connect is not None:
            pulumi.set(__self__, "kafka_connect", kafka_connect)
        if maintenance_window_config is not None:
            pulumi.set(__self__, "maintenance_window_config", maintenance_window_config)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if network_id is not None:
            pulumi.set(__self__, "network_id", network_id)
        if prometheus is not None:
            pulumi.set(__self__, "prometheus", prometheus)
        if read_replica_cluster_ids is not None:
            pulumi.set(__self__, "read_replica_cluster_ids", read_replica_cluster_ids)
        if redpanda_console is not None:
            pulumi.set(__self__, "redpanda_console", redpanda_console)
        if redpanda_version is not None:
            pulumi.set(__self__, "redpanda_version", redpanda_version)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if resource_group_id is not None:
            pulumi.set(__self__, "resource_group_id", resource_group_id)
        if schema_registry is not None:
            pulumi.set(__self__, "schema_registry", schema_registry)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if state_description is not None:
            pulumi.set(__self__, "state_description", state_description)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if throughput_tier is not None:
            pulumi.set(__self__, "throughput_tier", throughput_tier)
        if zones is not None:
            pulumi.set(__self__, "zones", zones)

    @_builtins.property
    @pulumi.getter(name="allowDeletion")
    def allow_deletion(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Allows deletion of the cluster. Defaults to false.
        """
        return pulumi.get(self, "allow_deletion")

    @allow_deletion.setter
    def allow_deletion(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "allow_deletion", value)

    @_builtins.property
    @pulumi.getter(name="awsPrivateLink")
    def aws_private_link(self) -> Optional[pulumi.Input['ClusterAwsPrivateLinkArgs']]:
        """
        AWS PrivateLink configuration.
        """
        return pulumi.get(self, "aws_private_link")

    @aws_private_link.setter
    def aws_private_link(self, value: Optional[pulumi.Input['ClusterAwsPrivateLinkArgs']]):
        pulumi.set(self, "aws_private_link", value)

    @_builtins.property
    @pulumi.getter(name="azurePrivateLink")
    def azure_private_link(self) -> Optional[pulumi.Input['ClusterAzurePrivateLinkArgs']]:
        """
        Azure Private Link configuration.
        """
        return pulumi.get(self, "azure_private_link")

    @azure_private_link.setter
    def azure_private_link(self, value: Optional[pulumi.Input['ClusterAzurePrivateLinkArgs']]):
        pulumi.set(self, "azure_private_link", value)

    @_builtins.property
    @pulumi.getter(name="cloudProvider")
    def cloud_provider(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Cloud provider where resources are created.
        """
        return pulumi.get(self, "cloud_provider")

    @cloud_provider.setter
    def cloud_provider(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cloud_provider", value)

    @_builtins.property
    @pulumi.getter(name="clusterApiUrl")
    def cluster_api_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The URL of the cluster API.
        """
        return pulumi.get(self, "cluster_api_url")

    @cluster_api_url.setter
    def cluster_api_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cluster_api_url", value)

    @_builtins.property
    @pulumi.getter(name="clusterType")
    def cluster_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Cluster type. Type is immutable and can only be set on cluster creation.
        """
        return pulumi.get(self, "cluster_type")

    @cluster_type.setter
    def cluster_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cluster_type", value)

    @_builtins.property
    @pulumi.getter(name="connectionType")
    def connection_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Cluster connection type. Private clusters are not exposed to the internet. For BYOC clusters, Private is best-practice.
        """
        return pulumi.get(self, "connection_type")

    @connection_type.setter
    def connection_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "connection_type", value)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Timestamp when the cluster was created.
        """
        return pulumi.get(self, "created_at")

    @created_at.setter
    def created_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_at", value)

    @_builtins.property
    @pulumi.getter(name="customerManagedResources")
    def customer_managed_resources(self) -> Optional[pulumi.Input['ClusterCustomerManagedResourcesArgs']]:
        """
        Customer managed resources configuration for the cluster.
        """
        return pulumi.get(self, "customer_managed_resources")

    @customer_managed_resources.setter
    def customer_managed_resources(self, value: Optional[pulumi.Input['ClusterCustomerManagedResourcesArgs']]):
        pulumi.set(self, "customer_managed_resources", value)

    @_builtins.property
    @pulumi.getter(name="gcpGlobalAccessEnabled")
    def gcp_global_access_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If true, GCP global access is enabled.
        """
        return pulumi.get(self, "gcp_global_access_enabled")

    @gcp_global_access_enabled.setter
    def gcp_global_access_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "gcp_global_access_enabled", value)

    @_builtins.property
    @pulumi.getter(name="gcpPrivateServiceConnect")
    def gcp_private_service_connect(self) -> Optional[pulumi.Input['ClusterGcpPrivateServiceConnectArgs']]:
        """
        GCP Private Service Connect configuration.
        """
        return pulumi.get(self, "gcp_private_service_connect")

    @gcp_private_service_connect.setter
    def gcp_private_service_connect(self, value: Optional[pulumi.Input['ClusterGcpPrivateServiceConnectArgs']]):
        pulumi.set(self, "gcp_private_service_connect", value)

    @_builtins.property
    @pulumi.getter(name="httpProxy")
    def http_proxy(self) -> Optional[pulumi.Input['ClusterHttpProxyArgs']]:
        """
        HTTP Proxy properties.
        """
        return pulumi.get(self, "http_proxy")

    @http_proxy.setter
    def http_proxy(self, value: Optional[pulumi.Input['ClusterHttpProxyArgs']]):
        pulumi.set(self, "http_proxy", value)

    @_builtins.property
    @pulumi.getter(name="kafkaApi")
    def kafka_api(self) -> Optional[pulumi.Input['ClusterKafkaApiArgs']]:
        """
        Cluster's Kafka API properties.
        """
        return pulumi.get(self, "kafka_api")

    @kafka_api.setter
    def kafka_api(self, value: Optional[pulumi.Input['ClusterKafkaApiArgs']]):
        pulumi.set(self, "kafka_api", value)

    @_builtins.property
    @pulumi.getter(name="kafkaConnect")
    def kafka_connect(self) -> Optional[pulumi.Input['ClusterKafkaConnectArgs']]:
        """
        Kafka Connect configuration.
        """
        return pulumi.get(self, "kafka_connect")

    @kafka_connect.setter
    def kafka_connect(self, value: Optional[pulumi.Input['ClusterKafkaConnectArgs']]):
        pulumi.set(self, "kafka_connect", value)

    @_builtins.property
    @pulumi.getter(name="maintenanceWindowConfig")
    def maintenance_window_config(self) -> Optional[pulumi.Input['ClusterMaintenanceWindowConfigArgs']]:
        """
        Maintenance window configuration for the cluster.
        """
        return pulumi.get(self, "maintenance_window_config")

    @maintenance_window_config.setter
    def maintenance_window_config(self, value: Optional[pulumi.Input['ClusterMaintenanceWindowConfigArgs']]):
        pulumi.set(self, "maintenance_window_config", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Unique name of the cluster.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="networkId")
    def network_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Network ID where cluster is placed.
        """
        return pulumi.get(self, "network_id")

    @network_id.setter
    def network_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "network_id", value)

    @_builtins.property
    @pulumi.getter
    def prometheus(self) -> Optional[pulumi.Input['ClusterPrometheusArgs']]:
        """
        Prometheus metrics endpoint properties.
        """
        return pulumi.get(self, "prometheus")

    @prometheus.setter
    def prometheus(self, value: Optional[pulumi.Input['ClusterPrometheusArgs']]):
        pulumi.set(self, "prometheus", value)

    @_builtins.property
    @pulumi.getter(name="readReplicaClusterIds")
    def read_replica_cluster_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        IDs of clusters that can create read-only topics from this cluster.
        """
        return pulumi.get(self, "read_replica_cluster_ids")

    @read_replica_cluster_ids.setter
    def read_replica_cluster_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "read_replica_cluster_ids", value)

    @_builtins.property
    @pulumi.getter(name="redpandaConsole")
    def redpanda_console(self) -> Optional[pulumi.Input['ClusterRedpandaConsoleArgs']]:
        """
        Redpanda Console properties.
        """
        return pulumi.get(self, "redpanda_console")

    @redpanda_console.setter
    def redpanda_console(self, value: Optional[pulumi.Input['ClusterRedpandaConsoleArgs']]):
        pulumi.set(self, "redpanda_console", value)

    @_builtins.property
    @pulumi.getter(name="redpandaVersion")
    def redpanda_version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Current Redpanda version of the cluster.
        """
        return pulumi.get(self, "redpanda_version")

    @redpanda_version.setter
    def redpanda_version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "redpanda_version", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Cloud provider region. Region represents the name of the region where the cluster will be provisioned.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter(name="resourceGroupId")
    def resource_group_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Resource group ID of the cluster.
        """
        return pulumi.get(self, "resource_group_id")

    @resource_group_id.setter
    def resource_group_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "resource_group_id", value)

    @_builtins.property
    @pulumi.getter(name="schemaRegistry")
    def schema_registry(self) -> Optional[pulumi.Input['ClusterSchemaRegistryArgs']]:
        """
        Schema Registry properties.
        """
        return pulumi.get(self, "schema_registry")

    @schema_registry.setter
    def schema_registry(self, value: Optional[pulumi.Input['ClusterSchemaRegistryArgs']]):
        pulumi.set(self, "schema_registry", value)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Current state of the cluster.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "state", value)

    @_builtins.property
    @pulumi.getter(name="stateDescription")
    def state_description(self) -> Optional[pulumi.Input['ClusterStateDescriptionArgs']]:
        """
        Detailed state description when cluster is in a non-ready state.
        """
        return pulumi.get(self, "state_description")

    @state_description.setter
    def state_description(self, value: Optional[pulumi.Input['ClusterStateDescriptionArgs']]):
        pulumi.set(self, "state_description", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags placed on cloud resources. If the cloud provider is GCP and the name of a tag has the prefix "gcp.network-tag.", the tag is a network tag that will be added to the Redpanda cluster GKE nodes. Otherwise, the tag is a normal tag. For example, if the name of a tag is "gcp.network-tag.network-tag-foo", the network tag named "network-tag-foo" will be added to the Redpanda cluster GKE nodes. Note: The value of a network tag will be ignored. See the details on network tags at https://cloud.google.com/vpc/docs/add-remove-network-tags.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)

    @_builtins.property
    @pulumi.getter(name="throughputTier")
    def throughput_tier(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Throughput tier of the cluster.
        """
        return pulumi.get(self, "throughput_tier")

    @throughput_tier.setter
    def throughput_tier(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "throughput_tier", value)

    @_builtins.property
    @pulumi.getter
    def zones(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Zones of the cluster. Must be valid zones within the selected region. If multiple zones are used, the cluster is a multi-AZ cluster.
        """
        return pulumi.get(self, "zones")

    @zones.setter
    def zones(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "zones", value)


@pulumi.type_token("redpanda:index/cluster:Cluster")
class Cluster(pulumi.CustomResource):
    @overload
    def __init__(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 allow_deletion: Optional[pulumi.Input[_builtins.bool]] = None,
                 aws_private_link: Optional[pulumi.Input[Union['ClusterAwsPrivateLinkArgs', 'ClusterAwsPrivateLinkArgsDict']]] = None,
                 azure_private_link: Optional[pulumi.Input[Union['ClusterAzurePrivateLinkArgs', 'ClusterAzurePrivateLinkArgsDict']]] = None,
                 cloud_provider: Optional[pulumi.Input[_builtins.str]] = None,
                 cluster_type: Optional[pulumi.Input[_builtins.str]] = None,
                 connection_type: Optional[pulumi.Input[_builtins.str]] = None,
                 customer_managed_resources: Optional[pulumi.Input[Union['ClusterCustomerManagedResourcesArgs', 'ClusterCustomerManagedResourcesArgsDict']]] = None,
                 gcp_global_access_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 gcp_private_service_connect: Optional[pulumi.Input[Union['ClusterGcpPrivateServiceConnectArgs', 'ClusterGcpPrivateServiceConnectArgsDict']]] = None,
                 http_proxy: Optional[pulumi.Input[Union['ClusterHttpProxyArgs', 'ClusterHttpProxyArgsDict']]] = None,
                 kafka_api: Optional[pulumi.Input[Union['ClusterKafkaApiArgs', 'ClusterKafkaApiArgsDict']]] = None,
                 kafka_connect: Optional[pulumi.Input[Union['ClusterKafkaConnectArgs', 'ClusterKafkaConnectArgsDict']]] = None,
                 maintenance_window_config: Optional[pulumi.Input[Union['ClusterMaintenanceWindowConfigArgs', 'ClusterMaintenanceWindowConfigArgsDict']]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 network_id: Optional[pulumi.Input[_builtins.str]] = None,
                 read_replica_cluster_ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 redpanda_version: Optional[pulumi.Input[_builtins.str]] = None,
                 region: Optional[pulumi.Input[_builtins.str]] = None,
                 resource_group_id: Optional[pulumi.Input[_builtins.str]] = None,
                 schema_registry: Optional[pulumi.Input[Union['ClusterSchemaRegistryArgs', 'ClusterSchemaRegistryArgsDict']]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 throughput_tier: Optional[pulumi.Input[_builtins.str]] = None,
                 zones: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 __props__=None):
        """
        Enables the provisioning and management of Redpanda clusters on AWS and GCP. A cluster must always have a network and resource group.

        ## Usage

        ### On AWS

        ```python
        import pulumi
        import pulumiverse_redpanda as redpanda

        test_resource_group = redpanda.ResourceGroup("testResourceGroup")
        config = pulumi.Config()
        region = config.get("region")
        if region is None:
            region = "us-east-2"
        cloud_provider = config.get("cloudProvider")
        if cloud_provider is None:
            cloud_provider = "aws"
        test_network = redpanda.Network("testNetwork",
            resource_group_id=test_resource_group.id,
            cloud_provider=cloud_provider,
            region=region,
            cluster_type="dedicated",
            cidr_block="10.0.0.0/20")
        zones = config.get_object("zones")
        if zones is None:
            zones = [
                "use2-az1",
                "use2-az2",
                "use2-az3",
            ]
        throughput_tier = config.get("throughputTier")
        if throughput_tier is None:
            throughput_tier = "tier-1-aws-v2-arm"
        test_cluster = redpanda.Cluster("testCluster",
            resource_group_id=test_resource_group.id,
            network_id=test_network.id,
            cloud_provider=cloud_provider,
            region=region,
            cluster_type="dedicated",
            connection_type="public",
            throughput_tier=throughput_tier,
            zones=zones,
            allow_deletion=True,
            tags={
                "key": "value",
            })
        # aws_private_link = {
        #   enabled         = true
        #   connect_console = true
        #   allowed_principals = ["arn:aws:iam::123456789024:root"]
        # }
        resource_group_name = config.get("resourceGroupName")
        if resource_group_name is None:
            resource_group_name = "testname"
        network_name = config.get("networkName")
        if network_name is None:
            network_name = "testname"
        cluster_name = config.get("clusterName")
        if cluster_name is None:
            cluster_name = "testname"
        user_pw = config.get("userPw")
        if user_pw is None:
            user_pw = "password"
        mechanism = config.get("mechanism")
        if mechanism is None:
            mechanism = "scram-sha-256"
        test_user = redpanda.User("testUser",
            password=user_pw,
            mechanism=mechanism,
            cluster_api_url=test_cluster.cluster_api_url)
        partition_count = config.get_float("partitionCount")
        if partition_count is None:
            partition_count = 3
        replication_factor = config.get_float("replicationFactor")
        if replication_factor is None:
            replication_factor = 3
        test_topic = redpanda.Topic("testTopic",
            partition_count=partition_count,
            replication_factor=replication_factor,
            cluster_api_url=test_cluster.cluster_api_url,
            allow_deletion=True)
        test_acl = redpanda.Acl("testAcl",
            resource_type="TOPIC",
            resource_name_=test_topic.name,
            resource_pattern_type="LITERAL",
            principal=test_user.name.apply(lambda name: f"User:{name}"),
            host="*",
            operation="READ",
            permission_type="ALLOW",
            cluster_api_url=test_cluster.cluster_api_url)
        user_name = config.get("userName")
        if user_name is None:
            user_name = "test-username"
        topic_name = config.get("topicName")
        if topic_name is None:
            topic_name = "test-topic"
        ```

        ### On GCP

        ```python
        import pulumi
        import pulumiverse_redpanda as redpanda

        test_resource_group = redpanda.ResourceGroup("testResourceGroup")
        config = pulumi.Config()
        region = config.get("region")
        if region is None:
            region = "us-central1"
        cloud_provider = config.get("cloudProvider")
        if cloud_provider is None:
            cloud_provider = "gcp"
        test_network = redpanda.Network("testNetwork",
            resource_group_id=test_resource_group.id,
            cloud_provider=cloud_provider,
            region=region,
            cluster_type="dedicated",
            cidr_block="10.0.0.0/20")
        zones = config.get_object("zones")
        if zones is None:
            zones = [
                "us-central1-a",
                "us-central1-b",
                "us-central1-c",
            ]
        throughput_tier = config.get("throughputTier")
        if throughput_tier is None:
            throughput_tier = "tier-1-gcp-um4g"
        test_cluster = redpanda.Cluster("testCluster",
            resource_group_id=test_resource_group.id,
            network_id=test_network.id,
            cloud_provider=cloud_provider,
            region=region,
            cluster_type="dedicated",
            connection_type="public",
            throughput_tier=throughput_tier,
            zones=zones,
            allow_deletion=True)
        ## This is a reference for GCP tags
        #   tags = {
        #     "key" = "value"
        #   }
        ## This is a reference for GCP Private Service Connect
        #   gcp_private_service_connect = {
        #     enabled               = true
        #     global_access_enabled = true
        #     consumer_accept_list = [
        #       {
        #         source = "projects/123456789012"
        #       }
        #     ]
        #   }
        cluster_name = config.get("clusterName")
        if cluster_name is None:
            cluster_name = ""
        resource_group_name = config.get("resourceGroupName")
        if resource_group_name is None:
            resource_group_name = ""
        network_name = config.get("networkName")
        if network_name is None:
            network_name = ""
        user_pw = config.get("userPw")
        if user_pw is None:
            user_pw = "password"
        mechanism = config.get("mechanism")
        if mechanism is None:
            mechanism = "scram-sha-256"
        test_user = redpanda.User("testUser",
            password=user_pw,
            mechanism=mechanism,
            cluster_api_url=test_cluster.cluster_api_url)
        partition_count = config.get_float("partitionCount")
        if partition_count is None:
            partition_count = 3
        replication_factor = config.get_float("replicationFactor")
        if replication_factor is None:
            replication_factor = 3
        test_topic = redpanda.Topic("testTopic",
            partition_count=partition_count,
            replication_factor=replication_factor,
            cluster_api_url=test_cluster.cluster_api_url,
            allow_deletion=True)
        test_acl = redpanda.Acl("testAcl",
            resource_type="TOPIC",
            resource_name_=test_topic.name,
            resource_pattern_type="LITERAL",
            principal=test_user.name.apply(lambda name: f"User:{name}"),
            host="*",
            operation="READ",
            permission_type="ALLOW",
            cluster_api_url=test_cluster.cluster_api_url)
        user_name = config.get("userName")
        if user_name is None:
            user_name = "test-username"
        topic_name = config.get("topicName")
        if topic_name is None:
            topic_name = "test-topic"
        ```

        ### On Azure

        ```python
        import pulumi
        import pulumiverse_redpanda as redpanda

        test_resource_group = redpanda.ResourceGroup("testResourceGroup")
        config = pulumi.Config()
        cloud_provider = config.get("cloudProvider")
        if cloud_provider is None:
            cloud_provider = "azure"
        region = config.get("region")
        if region is None:
            region = "eastus"
        test_network = redpanda.Network("testNetwork",
            resource_group_id=test_resource_group.id,
            cloud_provider=cloud_provider,
            region=region,
            cluster_type="dedicated",
            cidr_block="10.0.0.0/20")
        zones = config.get_object("zones")
        if zones is None:
            zones = [
                "eastus-az1",
                "eastus-az2",
                "eastus-az3",
            ]
        throughput_tier = config.get("throughputTier")
        if throughput_tier is None:
            throughput_tier = "tier-1-azure-v3-x86"
        test_cluster = redpanda.Cluster("testCluster",
            resource_group_id=test_resource_group.id,
            network_id=test_network.id,
            cloud_provider=cloud_provider,
            region=region,
            cluster_type="dedicated",
            connection_type="public",
            throughput_tier=throughput_tier,
            zones=zones,
            allow_deletion=True,
            tags={
                "key": "value",
            })
        #   azure_private_link = {
        #     enabled         = true
        #     connect_console = true
        #     allowed_subscriptions = ["12345678-1234-1234-1234-123456789012"]
        #   }
        resource_group_name = config.get("resourceGroupName")
        if resource_group_name is None:
            resource_group_name = "testname"
        network_name = config.get("networkName")
        if network_name is None:
            network_name = "testname"
        cluster_name = config.get("clusterName")
        if cluster_name is None:
            cluster_name = "testname"
        user_pw = config.get("userPw")
        if user_pw is None:
            user_pw = "password"
        mechanism = config.get("mechanism")
        if mechanism is None:
            mechanism = "scram-sha-256"
        test_user = redpanda.User("testUser",
            password=user_pw,
            mechanism=mechanism,
            cluster_api_url=test_cluster.cluster_api_url)
        partition_count = config.get_float("partitionCount")
        if partition_count is None:
            partition_count = 3
        replication_factor = config.get_float("replicationFactor")
        if replication_factor is None:
            replication_factor = 3
        test_topic = redpanda.Topic("testTopic",
            partition_count=partition_count,
            replication_factor=replication_factor,
            cluster_api_url=test_cluster.cluster_api_url,
            allow_deletion=True)
        test_acl = redpanda.Acl("testAcl",
            resource_type="TOPIC",
            resource_name_=test_topic.name,
            resource_pattern_type="LITERAL",
            principal=test_user.name.apply(lambda name: f"User:{name}"),
            host="*",
            operation="READ",
            permission_type="ALLOW",
            cluster_api_url=test_cluster.cluster_api_url)
        user_name = config.get("userName")
        if user_name is None:
            user_name = "test-username"
        topic_name = config.get("topicName")
        if topic_name is None:
            topic_name = "test-topic"
        ```

        ## BYOC

        This configuration of cluster allows the end user to provide access to their cloud account to the provider so that it can create the necessary infrastructure in their account rather than in Redpanda's Cloud.

        #### Additional Requirements

        To build a BYOC cluster you must provide credentials that enable the provider to authenticate to the relevant cloud provider. How this works will depend on which cloud provider you are using.

        ### AWS BYOC

        To create a BYOC AWS cluster you must provide an AWS_ACCESS_KEY_ID and AWS_SECRET_ACCESS_KEY. The account [must have fairly wide ranging permissions](https://docs.redpanda.com/redpanda-cloud/security/authorization/cloud-iam-policies/) to create the necessary infrastructure.

        ```python
        import pulumi
        import pulumiverse_redpanda as redpanda

        test_resource_group = redpanda.ResourceGroup("testResourceGroup")
        config = pulumi.Config()
        region = config.get("region")
        if region is None:
            region = "us-east-2"
        cloud_provider = config.get("cloudProvider")
        if cloud_provider is None:
            cloud_provider = "aws"
        test_network = redpanda.Network("testNetwork",
            resource_group_id=test_resource_group.id,
            cloud_provider=cloud_provider,
            region=region,
            cluster_type="byoc",
            cidr_block="10.0.0.0/20")
        zones = config.get_object("zones")
        if zones is None:
            zones = [
                "use2-az1",
                "use2-az2",
                "use2-az3",
            ]
        throughput_tier = config.get("throughputTier")
        if throughput_tier is None:
            throughput_tier = "tier-1-aws-v2-x86"
        test_cluster = redpanda.Cluster("testCluster",
            resource_group_id=test_resource_group.id,
            network_id=test_network.id,
            cloud_provider=test_network.cloud_provider,
            region=test_network.region,
            cluster_type=test_network.cluster_type,
            connection_type="public",
            throughput_tier=throughput_tier,
            zones=zones,
            allow_deletion=True,
            tags={
                "key": "value",
            })
        # aws_private_link = {
        #   enabled         = true
        #   connect_console = true
        #   allowed_principals = ["arn:aws:iam::123456789024:root"]
        # }
        resource_group_name = config.get("resourceGroupName")
        if resource_group_name is None:
            resource_group_name = "testname"
        network_name = config.get("networkName")
        if network_name is None:
            network_name = "testname"
        cluster_name = config.get("clusterName")
        if cluster_name is None:
            cluster_name = "testname"
        user_pw = config.get("userPw")
        if user_pw is None:
            user_pw = "password"
        mechanism = config.get("mechanism")
        if mechanism is None:
            mechanism = "scram-sha-256"
        test_user = redpanda.User("testUser",
            password=user_pw,
            mechanism=mechanism,
            cluster_api_url=test_cluster.cluster_api_url)
        partition_count = config.get_float("partitionCount")
        if partition_count is None:
            partition_count = 3
        replication_factor = config.get_float("replicationFactor")
        if replication_factor is None:
            replication_factor = 3
        test_topic = redpanda.Topic("testTopic",
            partition_count=partition_count,
            replication_factor=replication_factor,
            cluster_api_url=test_cluster.cluster_api_url,
            allow_deletion=True)
        test_acl = redpanda.Acl("testAcl",
            resource_type="TOPIC",
            resource_name_=test_topic.name,
            resource_pattern_type="LITERAL",
            principal=test_user.name.apply(lambda name: f"User:{name}"),
            host="*",
            operation="READ",
            permission_type="ALLOW",
            cluster_api_url=test_cluster.cluster_api_url)
        user_name = config.get("userName")
        if user_name is None:
            user_name = "test-username"
        topic_name = config.get("topicName")
        if topic_name is None:
            topic_name = "test-topic"
        ```

        ### GCP BYOC

        To create a GCP BYOC cluster you must provide a GCP_PROJECT_ID and GOOGLE_CREDENTIALS. We also accept the credentials encoded in base64 format if you use GOOGLE_CREDENTIALS_BASE64. The account [must have fairly wide ranging permissions](https://docs.redpanda.com/redpanda-cloud/security/authorization/cloud-iam-policies-gcp/) to create the necessary infrastructure.

        ```python
        import pulumi
        import pulumiverse_redpanda as redpanda

        test_resource_group = redpanda.ResourceGroup("testResourceGroup")
        config = pulumi.Config()
        region = config.get("region")
        if region is None:
            region = "us-central1"
        cloud_provider = config.get("cloudProvider")
        if cloud_provider is None:
            cloud_provider = "gcp"
        test_network = redpanda.Network("testNetwork",
            resource_group_id=test_resource_group.id,
            cloud_provider=cloud_provider,
            region=region,
            cluster_type="byoc",
            cidr_block="10.0.0.0/20")
        zones = config.get_object("zones")
        if zones is None:
            zones = [
                "us-central1-a",
                "us-central1-b",
                "us-central1-c",
            ]
        throughput_tier = config.get("throughputTier")
        if throughput_tier is None:
            throughput_tier = "tier-1-gcp-um4g"
        test_cluster = redpanda.Cluster("testCluster",
            resource_group_id=test_resource_group.id,
            network_id=test_network.id,
            cloud_provider=test_network.cloud_provider,
            region=test_network.region,
            cluster_type=test_network.cluster_type,
            connection_type="public",
            throughput_tier=throughput_tier,
            zones=zones,
            allow_deletion=True)
        ## This is a reference for GCP tags
        #   tags = {
        #     "key" = "value"
        #   }
        ## This is a reference for GCP Private Service Connect
        #   gcp_private_service_connect = {
        #     enabled               = true
        #     global_access_enabled = true
        #     consumer_accept_list = [
        #       {
        #         source = "projects/123456789012"
        #       }
        #     ]
        #   }
        cluster_name = config.get("clusterName")
        if cluster_name is None:
            cluster_name = ""
        resource_group_name = config.get("resourceGroupName")
        if resource_group_name is None:
            resource_group_name = ""
        network_name = config.get("networkName")
        if network_name is None:
            network_name = ""
        user_pw = config.get("userPw")
        if user_pw is None:
            user_pw = "password"
        mechanism = config.get("mechanism")
        if mechanism is None:
            mechanism = "scram-sha-256"
        test_user = redpanda.User("testUser",
            password=user_pw,
            mechanism=mechanism,
            cluster_api_url=test_cluster.cluster_api_url)
        partition_count = config.get_float("partitionCount")
        if partition_count is None:
            partition_count = 3
        replication_factor = config.get_float("replicationFactor")
        if replication_factor is None:
            replication_factor = 3
        test_topic = redpanda.Topic("testTopic",
            partition_count=partition_count,
            replication_factor=replication_factor,
            cluster_api_url=test_cluster.cluster_api_url,
            allow_deletion=True)
        test_acl = redpanda.Acl("testAcl",
            resource_type="TOPIC",
            resource_name_=test_topic.name,
            resource_pattern_type="LITERAL",
            principal=test_user.name.apply(lambda name: f"User:{name}"),
            host="*",
            operation="READ",
            permission_type="ALLOW",
            cluster_api_url=test_cluster.cluster_api_url)
        user_name = config.get("userName")
        if user_name is None:
            user_name = "test-username"
        topic_name = config.get("topicName")
        if topic_name is None:
            topic_name = "test-topic"
        ```

        ### Azure BYOC

        To create a BYOC Azure cluster you must provide Azure credentials, be logged in to the Azure CLI, or specify an Azure authentication method. This provider supports the same authentication methods and environment variables as the official AzureRM provider. For example, to use a service principal and client certificate, you can pass the environment variables `ARM_CLIENT_ID`, `ARM_CLIENT_SECRET`, `ARM_TENANT_ID`, and `ARM_SUBSCRIPTION_ID`.

        The account [must have fairly wide ranging permissions](https://docs.redpanda.com/redpanda-cloud/security/authorization/cloud-iam-policies-azure/) to create the necessary infrastructure.

        ```python
        import pulumi
        import pulumiverse_redpanda as redpanda

        test_resource_group = redpanda.ResourceGroup("testResourceGroup")
        config = pulumi.Config()
        cloud_provider = config.get("cloudProvider")
        if cloud_provider is None:
            cloud_provider = "azure"
        region = config.get("region")
        if region is None:
            region = "eastus"
        test_network = redpanda.Network("testNetwork",
            resource_group_id=test_resource_group.id,
            cloud_provider=cloud_provider,
            region=region,
            cluster_type="byoc",
            cidr_block="10.0.0.0/20")
        zones = config.get_object("zones")
        if zones is None:
            zones = [
                "eastus-az1",
                "eastus-az2",
                "eastus-az3",
            ]
        throughput_tier = config.get("throughputTier")
        if throughput_tier is None:
            throughput_tier = "tier-1-azure-v3-x86"
        test_cluster = redpanda.Cluster("testCluster",
            resource_group_id=test_resource_group.id,
            network_id=test_network.id,
            cloud_provider=test_network.cloud_provider,
            region=test_network.region,
            cluster_type=test_network.cluster_type,
            connection_type="public",
            throughput_tier=throughput_tier,
            zones=zones,
            allow_deletion=True,
            tags={
                "key": "value",
            })
        # azure_private_link = {
        #   enabled         = true
        #   connect_console = true
        #   allowed_subscriptions = ["12345678-1234-1234-1234-123456789012"]
        # }
        resource_group_name = config.get("resourceGroupName")
        if resource_group_name is None:
            resource_group_name = "testname"
        network_name = config.get("networkName")
        if network_name is None:
            network_name = "testname"
        cluster_name = config.get("clusterName")
        if cluster_name is None:
            cluster_name = "testname"
        user_pw = config.get("userPw")
        if user_pw is None:
            user_pw = "password"
        mechanism = config.get("mechanism")
        if mechanism is None:
            mechanism = "scram-sha-256"
        test_user = redpanda.User("testUser",
            password=user_pw,
            mechanism=mechanism,
            cluster_api_url=test_cluster.cluster_api_url)
        partition_count = config.get_float("partitionCount")
        if partition_count is None:
            partition_count = 3
        replication_factor = config.get_float("replicationFactor")
        if replication_factor is None:
            replication_factor = 3
        test_topic = redpanda.Topic("testTopic",
            partition_count=partition_count,
            replication_factor=replication_factor,
            cluster_api_url=test_cluster.cluster_api_url,
            allow_deletion=True)
        test_acl = redpanda.Acl("testAcl",
            resource_type="TOPIC",
            resource_name_=test_topic.name,
            resource_pattern_type="LITERAL",
            principal=test_user.name.apply(lambda name: f"User:{name}"),
            host="*",
            operation="READ",
            permission_type="ALLOW",
            cluster_api_url=test_cluster.cluster_api_url)
        user_name = config.get("userName")
        if user_name is None:
            user_name = "test-username"
        topic_name = config.get("topicName")
        if topic_name is None:
            topic_name = "test-topic"
        ```

        ## BYOVPC

        This accepts a network and other elements created by the end user inside their cloud provider account (currently limited to AWS) and builds a Redpanda Cluster inside it.

        There is a module provided for convenience of the end user here that handles the necessary setup. It contains outputs for the inputs the provider requires.

        ### Example Usage of a data source BYOC to manage users and ACLs

        ```python
        import pulumi
        import pulumi_redpanda as redpanda
        import pulumiverse_redpanda as redpanda

        config = pulumi.Config()
        cluster_id = config.get("clusterId")
        if cluster_id is None:
            cluster_id = ""
        test_cluster = redpanda.get_cluster(id=cluster_id)
        topic_config = config.get_object("topicConfig")
        if topic_config is None:
            topic_config = {
                "cleanup.policy": "compact",
                "flush.ms": 100,
                "compression.type": "snappy",
            }
        partition_count = config.get_float("partitionCount")
        if partition_count is None:
            partition_count = 3
        replication_factor = config.get_float("replicationFactor")
        if replication_factor is None:
            replication_factor = 3
        test_topic = redpanda.Topic("testTopic",
            partition_count=partition_count,
            replication_factor=replication_factor,
            cluster_api_url=test_cluster.cluster_api_url,
            allow_deletion=True,
            configuration=topic_config)
        user_pw = config.get("userPw")
        if user_pw is None:
            user_pw = "password"
        mechanism = config.get("mechanism")
        if mechanism is None:
            mechanism = "scram-sha-256"
        test_user = redpanda.User("testUser",
            password=user_pw,
            mechanism=mechanism,
            cluster_api_url=test_cluster.cluster_api_url)
        test_acl = redpanda.Acl("testAcl",
            resource_type="CLUSTER",
            resource_name_="kafka-cluster",
            resource_pattern_type="LITERAL",
            principal=test_user.name.apply(lambda name: f"User:{name}"),
            host="*",
            operation="ALTER",
            permission_type="ALLOW",
            cluster_api_url=test_cluster.cluster_api_url)
        user_name = config.get("userName")
        if user_name is None:
            user_name = "data-test-username"
        topic_name = config.get("topicName")
        if topic_name is None:
            topic_name = "data-test-topic"
        ```

        ## Import

        ```sh
        $ pulumi import redpanda:index/cluster:Cluster example clusterId
        ```

        :param str resource_name: The name of the resource.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[_builtins.bool] allow_deletion: Allows deletion of the cluster. Defaults to false.
        :param pulumi.Input[Union['ClusterAwsPrivateLinkArgs', 'ClusterAwsPrivateLinkArgsDict']] aws_private_link: AWS PrivateLink configuration.
        :param pulumi.Input[Union['ClusterAzurePrivateLinkArgs', 'ClusterAzurePrivateLinkArgsDict']] azure_private_link: Azure Private Link configuration.
        :param pulumi.Input[_builtins.str] cloud_provider: Cloud provider where resources are created.
        :param pulumi.Input[_builtins.str] cluster_type: Cluster type. Type is immutable and can only be set on cluster creation.
        :param pulumi.Input[_builtins.str] connection_type: Cluster connection type. Private clusters are not exposed to the internet. For BYOC clusters, Private is best-practice.
        :param pulumi.Input[Union['ClusterCustomerManagedResourcesArgs', 'ClusterCustomerManagedResourcesArgsDict']] customer_managed_resources: Customer managed resources configuration for the cluster.
        :param pulumi.Input[_builtins.bool] gcp_global_access_enabled: If true, GCP global access is enabled.
        :param pulumi.Input[Union['ClusterGcpPrivateServiceConnectArgs', 'ClusterGcpPrivateServiceConnectArgsDict']] gcp_private_service_connect: GCP Private Service Connect configuration.
        :param pulumi.Input[Union['ClusterHttpProxyArgs', 'ClusterHttpProxyArgsDict']] http_proxy: HTTP Proxy properties.
        :param pulumi.Input[Union['ClusterKafkaApiArgs', 'ClusterKafkaApiArgsDict']] kafka_api: Cluster's Kafka API properties.
        :param pulumi.Input[Union['ClusterKafkaConnectArgs', 'ClusterKafkaConnectArgsDict']] kafka_connect: Kafka Connect configuration.
        :param pulumi.Input[Union['ClusterMaintenanceWindowConfigArgs', 'ClusterMaintenanceWindowConfigArgsDict']] maintenance_window_config: Maintenance window configuration for the cluster.
        :param pulumi.Input[_builtins.str] name: Unique name of the cluster.
        :param pulumi.Input[_builtins.str] network_id: Network ID where cluster is placed.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] read_replica_cluster_ids: IDs of clusters that can create read-only topics from this cluster.
        :param pulumi.Input[_builtins.str] redpanda_version: Current Redpanda version of the cluster.
        :param pulumi.Input[_builtins.str] region: Cloud provider region. Region represents the name of the region where the cluster will be provisioned.
        :param pulumi.Input[_builtins.str] resource_group_id: Resource group ID of the cluster.
        :param pulumi.Input[Union['ClusterSchemaRegistryArgs', 'ClusterSchemaRegistryArgsDict']] schema_registry: Schema Registry properties.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags placed on cloud resources. If the cloud provider is GCP and the name of a tag has the prefix "gcp.network-tag.", the tag is a network tag that will be added to the Redpanda cluster GKE nodes. Otherwise, the tag is a normal tag. For example, if the name of a tag is "gcp.network-tag.network-tag-foo", the network tag named "network-tag-foo" will be added to the Redpanda cluster GKE nodes. Note: The value of a network tag will be ignored. See the details on network tags at https://cloud.google.com/vpc/docs/add-remove-network-tags.
        :param pulumi.Input[_builtins.str] throughput_tier: Throughput tier of the cluster.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] zones: Zones of the cluster. Must be valid zones within the selected region. If multiple zones are used, the cluster is a multi-AZ cluster.
        """
        ...
    @overload
    def __init__(__self__,
                 resource_name: str,
                 args: ClusterArgs,
                 opts: Optional[pulumi.ResourceOptions] = None):
        """
        Enables the provisioning and management of Redpanda clusters on AWS and GCP. A cluster must always have a network and resource group.

        ## Usage

        ### On AWS

        ```python
        import pulumi
        import pulumiverse_redpanda as redpanda

        test_resource_group = redpanda.ResourceGroup("testResourceGroup")
        config = pulumi.Config()
        region = config.get("region")
        if region is None:
            region = "us-east-2"
        cloud_provider = config.get("cloudProvider")
        if cloud_provider is None:
            cloud_provider = "aws"
        test_network = redpanda.Network("testNetwork",
            resource_group_id=test_resource_group.id,
            cloud_provider=cloud_provider,
            region=region,
            cluster_type="dedicated",
            cidr_block="10.0.0.0/20")
        zones = config.get_object("zones")
        if zones is None:
            zones = [
                "use2-az1",
                "use2-az2",
                "use2-az3",
            ]
        throughput_tier = config.get("throughputTier")
        if throughput_tier is None:
            throughput_tier = "tier-1-aws-v2-arm"
        test_cluster = redpanda.Cluster("testCluster",
            resource_group_id=test_resource_group.id,
            network_id=test_network.id,
            cloud_provider=cloud_provider,
            region=region,
            cluster_type="dedicated",
            connection_type="public",
            throughput_tier=throughput_tier,
            zones=zones,
            allow_deletion=True,
            tags={
                "key": "value",
            })
        # aws_private_link = {
        #   enabled         = true
        #   connect_console = true
        #   allowed_principals = ["arn:aws:iam::123456789024:root"]
        # }
        resource_group_name = config.get("resourceGroupName")
        if resource_group_name is None:
            resource_group_name = "testname"
        network_name = config.get("networkName")
        if network_name is None:
            network_name = "testname"
        cluster_name = config.get("clusterName")
        if cluster_name is None:
            cluster_name = "testname"
        user_pw = config.get("userPw")
        if user_pw is None:
            user_pw = "password"
        mechanism = config.get("mechanism")
        if mechanism is None:
            mechanism = "scram-sha-256"
        test_user = redpanda.User("testUser",
            password=user_pw,
            mechanism=mechanism,
            cluster_api_url=test_cluster.cluster_api_url)
        partition_count = config.get_float("partitionCount")
        if partition_count is None:
            partition_count = 3
        replication_factor = config.get_float("replicationFactor")
        if replication_factor is None:
            replication_factor = 3
        test_topic = redpanda.Topic("testTopic",
            partition_count=partition_count,
            replication_factor=replication_factor,
            cluster_api_url=test_cluster.cluster_api_url,
            allow_deletion=True)
        test_acl = redpanda.Acl("testAcl",
            resource_type="TOPIC",
            resource_name_=test_topic.name,
            resource_pattern_type="LITERAL",
            principal=test_user.name.apply(lambda name: f"User:{name}"),
            host="*",
            operation="READ",
            permission_type="ALLOW",
            cluster_api_url=test_cluster.cluster_api_url)
        user_name = config.get("userName")
        if user_name is None:
            user_name = "test-username"
        topic_name = config.get("topicName")
        if topic_name is None:
            topic_name = "test-topic"
        ```

        ### On GCP

        ```python
        import pulumi
        import pulumiverse_redpanda as redpanda

        test_resource_group = redpanda.ResourceGroup("testResourceGroup")
        config = pulumi.Config()
        region = config.get("region")
        if region is None:
            region = "us-central1"
        cloud_provider = config.get("cloudProvider")
        if cloud_provider is None:
            cloud_provider = "gcp"
        test_network = redpanda.Network("testNetwork",
            resource_group_id=test_resource_group.id,
            cloud_provider=cloud_provider,
            region=region,
            cluster_type="dedicated",
            cidr_block="10.0.0.0/20")
        zones = config.get_object("zones")
        if zones is None:
            zones = [
                "us-central1-a",
                "us-central1-b",
                "us-central1-c",
            ]
        throughput_tier = config.get("throughputTier")
        if throughput_tier is None:
            throughput_tier = "tier-1-gcp-um4g"
        test_cluster = redpanda.Cluster("testCluster",
            resource_group_id=test_resource_group.id,
            network_id=test_network.id,
            cloud_provider=cloud_provider,
            region=region,
            cluster_type="dedicated",
            connection_type="public",
            throughput_tier=throughput_tier,
            zones=zones,
            allow_deletion=True)
        ## This is a reference for GCP tags
        #   tags = {
        #     "key" = "value"
        #   }
        ## This is a reference for GCP Private Service Connect
        #   gcp_private_service_connect = {
        #     enabled               = true
        #     global_access_enabled = true
        #     consumer_accept_list = [
        #       {
        #         source = "projects/123456789012"
        #       }
        #     ]
        #   }
        cluster_name = config.get("clusterName")
        if cluster_name is None:
            cluster_name = ""
        resource_group_name = config.get("resourceGroupName")
        if resource_group_name is None:
            resource_group_name = ""
        network_name = config.get("networkName")
        if network_name is None:
            network_name = ""
        user_pw = config.get("userPw")
        if user_pw is None:
            user_pw = "password"
        mechanism = config.get("mechanism")
        if mechanism is None:
            mechanism = "scram-sha-256"
        test_user = redpanda.User("testUser",
            password=user_pw,
            mechanism=mechanism,
            cluster_api_url=test_cluster.cluster_api_url)
        partition_count = config.get_float("partitionCount")
        if partition_count is None:
            partition_count = 3
        replication_factor = config.get_float("replicationFactor")
        if replication_factor is None:
            replication_factor = 3
        test_topic = redpanda.Topic("testTopic",
            partition_count=partition_count,
            replication_factor=replication_factor,
            cluster_api_url=test_cluster.cluster_api_url,
            allow_deletion=True)
        test_acl = redpanda.Acl("testAcl",
            resource_type="TOPIC",
            resource_name_=test_topic.name,
            resource_pattern_type="LITERAL",
            principal=test_user.name.apply(lambda name: f"User:{name}"),
            host="*",
            operation="READ",
            permission_type="ALLOW",
            cluster_api_url=test_cluster.cluster_api_url)
        user_name = config.get("userName")
        if user_name is None:
            user_name = "test-username"
        topic_name = config.get("topicName")
        if topic_name is None:
            topic_name = "test-topic"
        ```

        ### On Azure

        ```python
        import pulumi
        import pulumiverse_redpanda as redpanda

        test_resource_group = redpanda.ResourceGroup("testResourceGroup")
        config = pulumi.Config()
        cloud_provider = config.get("cloudProvider")
        if cloud_provider is None:
            cloud_provider = "azure"
        region = config.get("region")
        if region is None:
            region = "eastus"
        test_network = redpanda.Network("testNetwork",
            resource_group_id=test_resource_group.id,
            cloud_provider=cloud_provider,
            region=region,
            cluster_type="dedicated",
            cidr_block="10.0.0.0/20")
        zones = config.get_object("zones")
        if zones is None:
            zones = [
                "eastus-az1",
                "eastus-az2",
                "eastus-az3",
            ]
        throughput_tier = config.get("throughputTier")
        if throughput_tier is None:
            throughput_tier = "tier-1-azure-v3-x86"
        test_cluster = redpanda.Cluster("testCluster",
            resource_group_id=test_resource_group.id,
            network_id=test_network.id,
            cloud_provider=cloud_provider,
            region=region,
            cluster_type="dedicated",
            connection_type="public",
            throughput_tier=throughput_tier,
            zones=zones,
            allow_deletion=True,
            tags={
                "key": "value",
            })
        #   azure_private_link = {
        #     enabled         = true
        #     connect_console = true
        #     allowed_subscriptions = ["12345678-1234-1234-1234-123456789012"]
        #   }
        resource_group_name = config.get("resourceGroupName")
        if resource_group_name is None:
            resource_group_name = "testname"
        network_name = config.get("networkName")
        if network_name is None:
            network_name = "testname"
        cluster_name = config.get("clusterName")
        if cluster_name is None:
            cluster_name = "testname"
        user_pw = config.get("userPw")
        if user_pw is None:
            user_pw = "password"
        mechanism = config.get("mechanism")
        if mechanism is None:
            mechanism = "scram-sha-256"
        test_user = redpanda.User("testUser",
            password=user_pw,
            mechanism=mechanism,
            cluster_api_url=test_cluster.cluster_api_url)
        partition_count = config.get_float("partitionCount")
        if partition_count is None:
            partition_count = 3
        replication_factor = config.get_float("replicationFactor")
        if replication_factor is None:
            replication_factor = 3
        test_topic = redpanda.Topic("testTopic",
            partition_count=partition_count,
            replication_factor=replication_factor,
            cluster_api_url=test_cluster.cluster_api_url,
            allow_deletion=True)
        test_acl = redpanda.Acl("testAcl",
            resource_type="TOPIC",
            resource_name_=test_topic.name,
            resource_pattern_type="LITERAL",
            principal=test_user.name.apply(lambda name: f"User:{name}"),
            host="*",
            operation="READ",
            permission_type="ALLOW",
            cluster_api_url=test_cluster.cluster_api_url)
        user_name = config.get("userName")
        if user_name is None:
            user_name = "test-username"
        topic_name = config.get("topicName")
        if topic_name is None:
            topic_name = "test-topic"
        ```

        ## BYOC

        This configuration of cluster allows the end user to provide access to their cloud account to the provider so that it can create the necessary infrastructure in their account rather than in Redpanda's Cloud.

        #### Additional Requirements

        To build a BYOC cluster you must provide credentials that enable the provider to authenticate to the relevant cloud provider. How this works will depend on which cloud provider you are using.

        ### AWS BYOC

        To create a BYOC AWS cluster you must provide an AWS_ACCESS_KEY_ID and AWS_SECRET_ACCESS_KEY. The account [must have fairly wide ranging permissions](https://docs.redpanda.com/redpanda-cloud/security/authorization/cloud-iam-policies/) to create the necessary infrastructure.

        ```python
        import pulumi
        import pulumiverse_redpanda as redpanda

        test_resource_group = redpanda.ResourceGroup("testResourceGroup")
        config = pulumi.Config()
        region = config.get("region")
        if region is None:
            region = "us-east-2"
        cloud_provider = config.get("cloudProvider")
        if cloud_provider is None:
            cloud_provider = "aws"
        test_network = redpanda.Network("testNetwork",
            resource_group_id=test_resource_group.id,
            cloud_provider=cloud_provider,
            region=region,
            cluster_type="byoc",
            cidr_block="10.0.0.0/20")
        zones = config.get_object("zones")
        if zones is None:
            zones = [
                "use2-az1",
                "use2-az2",
                "use2-az3",
            ]
        throughput_tier = config.get("throughputTier")
        if throughput_tier is None:
            throughput_tier = "tier-1-aws-v2-x86"
        test_cluster = redpanda.Cluster("testCluster",
            resource_group_id=test_resource_group.id,
            network_id=test_network.id,
            cloud_provider=test_network.cloud_provider,
            region=test_network.region,
            cluster_type=test_network.cluster_type,
            connection_type="public",
            throughput_tier=throughput_tier,
            zones=zones,
            allow_deletion=True,
            tags={
                "key": "value",
            })
        # aws_private_link = {
        #   enabled         = true
        #   connect_console = true
        #   allowed_principals = ["arn:aws:iam::123456789024:root"]
        # }
        resource_group_name = config.get("resourceGroupName")
        if resource_group_name is None:
            resource_group_name = "testname"
        network_name = config.get("networkName")
        if network_name is None:
            network_name = "testname"
        cluster_name = config.get("clusterName")
        if cluster_name is None:
            cluster_name = "testname"
        user_pw = config.get("userPw")
        if user_pw is None:
            user_pw = "password"
        mechanism = config.get("mechanism")
        if mechanism is None:
            mechanism = "scram-sha-256"
        test_user = redpanda.User("testUser",
            password=user_pw,
            mechanism=mechanism,
            cluster_api_url=test_cluster.cluster_api_url)
        partition_count = config.get_float("partitionCount")
        if partition_count is None:
            partition_count = 3
        replication_factor = config.get_float("replicationFactor")
        if replication_factor is None:
            replication_factor = 3
        test_topic = redpanda.Topic("testTopic",
            partition_count=partition_count,
            replication_factor=replication_factor,
            cluster_api_url=test_cluster.cluster_api_url,
            allow_deletion=True)
        test_acl = redpanda.Acl("testAcl",
            resource_type="TOPIC",
            resource_name_=test_topic.name,
            resource_pattern_type="LITERAL",
            principal=test_user.name.apply(lambda name: f"User:{name}"),
            host="*",
            operation="READ",
            permission_type="ALLOW",
            cluster_api_url=test_cluster.cluster_api_url)
        user_name = config.get("userName")
        if user_name is None:
            user_name = "test-username"
        topic_name = config.get("topicName")
        if topic_name is None:
            topic_name = "test-topic"
        ```

        ### GCP BYOC

        To create a GCP BYOC cluster you must provide a GCP_PROJECT_ID and GOOGLE_CREDENTIALS. We also accept the credentials encoded in base64 format if you use GOOGLE_CREDENTIALS_BASE64. The account [must have fairly wide ranging permissions](https://docs.redpanda.com/redpanda-cloud/security/authorization/cloud-iam-policies-gcp/) to create the necessary infrastructure.

        ```python
        import pulumi
        import pulumiverse_redpanda as redpanda

        test_resource_group = redpanda.ResourceGroup("testResourceGroup")
        config = pulumi.Config()
        region = config.get("region")
        if region is None:
            region = "us-central1"
        cloud_provider = config.get("cloudProvider")
        if cloud_provider is None:
            cloud_provider = "gcp"
        test_network = redpanda.Network("testNetwork",
            resource_group_id=test_resource_group.id,
            cloud_provider=cloud_provider,
            region=region,
            cluster_type="byoc",
            cidr_block="10.0.0.0/20")
        zones = config.get_object("zones")
        if zones is None:
            zones = [
                "us-central1-a",
                "us-central1-b",
                "us-central1-c",
            ]
        throughput_tier = config.get("throughputTier")
        if throughput_tier is None:
            throughput_tier = "tier-1-gcp-um4g"
        test_cluster = redpanda.Cluster("testCluster",
            resource_group_id=test_resource_group.id,
            network_id=test_network.id,
            cloud_provider=test_network.cloud_provider,
            region=test_network.region,
            cluster_type=test_network.cluster_type,
            connection_type="public",
            throughput_tier=throughput_tier,
            zones=zones,
            allow_deletion=True)
        ## This is a reference for GCP tags
        #   tags = {
        #     "key" = "value"
        #   }
        ## This is a reference for GCP Private Service Connect
        #   gcp_private_service_connect = {
        #     enabled               = true
        #     global_access_enabled = true
        #     consumer_accept_list = [
        #       {
        #         source = "projects/123456789012"
        #       }
        #     ]
        #   }
        cluster_name = config.get("clusterName")
        if cluster_name is None:
            cluster_name = ""
        resource_group_name = config.get("resourceGroupName")
        if resource_group_name is None:
            resource_group_name = ""
        network_name = config.get("networkName")
        if network_name is None:
            network_name = ""
        user_pw = config.get("userPw")
        if user_pw is None:
            user_pw = "password"
        mechanism = config.get("mechanism")
        if mechanism is None:
            mechanism = "scram-sha-256"
        test_user = redpanda.User("testUser",
            password=user_pw,
            mechanism=mechanism,
            cluster_api_url=test_cluster.cluster_api_url)
        partition_count = config.get_float("partitionCount")
        if partition_count is None:
            partition_count = 3
        replication_factor = config.get_float("replicationFactor")
        if replication_factor is None:
            replication_factor = 3
        test_topic = redpanda.Topic("testTopic",
            partition_count=partition_count,
            replication_factor=replication_factor,
            cluster_api_url=test_cluster.cluster_api_url,
            allow_deletion=True)
        test_acl = redpanda.Acl("testAcl",
            resource_type="TOPIC",
            resource_name_=test_topic.name,
            resource_pattern_type="LITERAL",
            principal=test_user.name.apply(lambda name: f"User:{name}"),
            host="*",
            operation="READ",
            permission_type="ALLOW",
            cluster_api_url=test_cluster.cluster_api_url)
        user_name = config.get("userName")
        if user_name is None:
            user_name = "test-username"
        topic_name = config.get("topicName")
        if topic_name is None:
            topic_name = "test-topic"
        ```

        ### Azure BYOC

        To create a BYOC Azure cluster you must provide Azure credentials, be logged in to the Azure CLI, or specify an Azure authentication method. This provider supports the same authentication methods and environment variables as the official AzureRM provider. For example, to use a service principal and client certificate, you can pass the environment variables `ARM_CLIENT_ID`, `ARM_CLIENT_SECRET`, `ARM_TENANT_ID`, and `ARM_SUBSCRIPTION_ID`.

        The account [must have fairly wide ranging permissions](https://docs.redpanda.com/redpanda-cloud/security/authorization/cloud-iam-policies-azure/) to create the necessary infrastructure.

        ```python
        import pulumi
        import pulumiverse_redpanda as redpanda

        test_resource_group = redpanda.ResourceGroup("testResourceGroup")
        config = pulumi.Config()
        cloud_provider = config.get("cloudProvider")
        if cloud_provider is None:
            cloud_provider = "azure"
        region = config.get("region")
        if region is None:
            region = "eastus"
        test_network = redpanda.Network("testNetwork",
            resource_group_id=test_resource_group.id,
            cloud_provider=cloud_provider,
            region=region,
            cluster_type="byoc",
            cidr_block="10.0.0.0/20")
        zones = config.get_object("zones")
        if zones is None:
            zones = [
                "eastus-az1",
                "eastus-az2",
                "eastus-az3",
            ]
        throughput_tier = config.get("throughputTier")
        if throughput_tier is None:
            throughput_tier = "tier-1-azure-v3-x86"
        test_cluster = redpanda.Cluster("testCluster",
            resource_group_id=test_resource_group.id,
            network_id=test_network.id,
            cloud_provider=test_network.cloud_provider,
            region=test_network.region,
            cluster_type=test_network.cluster_type,
            connection_type="public",
            throughput_tier=throughput_tier,
            zones=zones,
            allow_deletion=True,
            tags={
                "key": "value",
            })
        # azure_private_link = {
        #   enabled         = true
        #   connect_console = true
        #   allowed_subscriptions = ["12345678-1234-1234-1234-123456789012"]
        # }
        resource_group_name = config.get("resourceGroupName")
        if resource_group_name is None:
            resource_group_name = "testname"
        network_name = config.get("networkName")
        if network_name is None:
            network_name = "testname"
        cluster_name = config.get("clusterName")
        if cluster_name is None:
            cluster_name = "testname"
        user_pw = config.get("userPw")
        if user_pw is None:
            user_pw = "password"
        mechanism = config.get("mechanism")
        if mechanism is None:
            mechanism = "scram-sha-256"
        test_user = redpanda.User("testUser",
            password=user_pw,
            mechanism=mechanism,
            cluster_api_url=test_cluster.cluster_api_url)
        partition_count = config.get_float("partitionCount")
        if partition_count is None:
            partition_count = 3
        replication_factor = config.get_float("replicationFactor")
        if replication_factor is None:
            replication_factor = 3
        test_topic = redpanda.Topic("testTopic",
            partition_count=partition_count,
            replication_factor=replication_factor,
            cluster_api_url=test_cluster.cluster_api_url,
            allow_deletion=True)
        test_acl = redpanda.Acl("testAcl",
            resource_type="TOPIC",
            resource_name_=test_topic.name,
            resource_pattern_type="LITERAL",
            principal=test_user.name.apply(lambda name: f"User:{name}"),
            host="*",
            operation="READ",
            permission_type="ALLOW",
            cluster_api_url=test_cluster.cluster_api_url)
        user_name = config.get("userName")
        if user_name is None:
            user_name = "test-username"
        topic_name = config.get("topicName")
        if topic_name is None:
            topic_name = "test-topic"
        ```

        ## BYOVPC

        This accepts a network and other elements created by the end user inside their cloud provider account (currently limited to AWS) and builds a Redpanda Cluster inside it.

        There is a module provided for convenience of the end user here that handles the necessary setup. It contains outputs for the inputs the provider requires.

        ### Example Usage of a data source BYOC to manage users and ACLs

        ```python
        import pulumi
        import pulumi_redpanda as redpanda
        import pulumiverse_redpanda as redpanda

        config = pulumi.Config()
        cluster_id = config.get("clusterId")
        if cluster_id is None:
            cluster_id = ""
        test_cluster = redpanda.get_cluster(id=cluster_id)
        topic_config = config.get_object("topicConfig")
        if topic_config is None:
            topic_config = {
                "cleanup.policy": "compact",
                "flush.ms": 100,
                "compression.type": "snappy",
            }
        partition_count = config.get_float("partitionCount")
        if partition_count is None:
            partition_count = 3
        replication_factor = config.get_float("replicationFactor")
        if replication_factor is None:
            replication_factor = 3
        test_topic = redpanda.Topic("testTopic",
            partition_count=partition_count,
            replication_factor=replication_factor,
            cluster_api_url=test_cluster.cluster_api_url,
            allow_deletion=True,
            configuration=topic_config)
        user_pw = config.get("userPw")
        if user_pw is None:
            user_pw = "password"
        mechanism = config.get("mechanism")
        if mechanism is None:
            mechanism = "scram-sha-256"
        test_user = redpanda.User("testUser",
            password=user_pw,
            mechanism=mechanism,
            cluster_api_url=test_cluster.cluster_api_url)
        test_acl = redpanda.Acl("testAcl",
            resource_type="CLUSTER",
            resource_name_="kafka-cluster",
            resource_pattern_type="LITERAL",
            principal=test_user.name.apply(lambda name: f"User:{name}"),
            host="*",
            operation="ALTER",
            permission_type="ALLOW",
            cluster_api_url=test_cluster.cluster_api_url)
        user_name = config.get("userName")
        if user_name is None:
            user_name = "data-test-username"
        topic_name = config.get("topicName")
        if topic_name is None:
            topic_name = "data-test-topic"
        ```

        ## Import

        ```sh
        $ pulumi import redpanda:index/cluster:Cluster example clusterId
        ```

        :param str resource_name: The name of the resource.
        :param ClusterArgs args: The arguments to use to populate this resource's properties.
        :param pulumi.ResourceOptions opts: Options for the resource.
        """
        ...
    def __init__(__self__, resource_name: str, *args, **kwargs):
        resource_args, opts = _utilities.get_resource_args_opts(ClusterArgs, pulumi.ResourceOptions, *args, **kwargs)
        if resource_args is not None:
            __self__._internal_init(resource_name, opts, **resource_args.__dict__)
        else:
            __self__._internal_init(resource_name, *args, **kwargs)

    def _internal_init(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 allow_deletion: Optional[pulumi.Input[_builtins.bool]] = None,
                 aws_private_link: Optional[pulumi.Input[Union['ClusterAwsPrivateLinkArgs', 'ClusterAwsPrivateLinkArgsDict']]] = None,
                 azure_private_link: Optional[pulumi.Input[Union['ClusterAzurePrivateLinkArgs', 'ClusterAzurePrivateLinkArgsDict']]] = None,
                 cloud_provider: Optional[pulumi.Input[_builtins.str]] = None,
                 cluster_type: Optional[pulumi.Input[_builtins.str]] = None,
                 connection_type: Optional[pulumi.Input[_builtins.str]] = None,
                 customer_managed_resources: Optional[pulumi.Input[Union['ClusterCustomerManagedResourcesArgs', 'ClusterCustomerManagedResourcesArgsDict']]] = None,
                 gcp_global_access_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 gcp_private_service_connect: Optional[pulumi.Input[Union['ClusterGcpPrivateServiceConnectArgs', 'ClusterGcpPrivateServiceConnectArgsDict']]] = None,
                 http_proxy: Optional[pulumi.Input[Union['ClusterHttpProxyArgs', 'ClusterHttpProxyArgsDict']]] = None,
                 kafka_api: Optional[pulumi.Input[Union['ClusterKafkaApiArgs', 'ClusterKafkaApiArgsDict']]] = None,
                 kafka_connect: Optional[pulumi.Input[Union['ClusterKafkaConnectArgs', 'ClusterKafkaConnectArgsDict']]] = None,
                 maintenance_window_config: Optional[pulumi.Input[Union['ClusterMaintenanceWindowConfigArgs', 'ClusterMaintenanceWindowConfigArgsDict']]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 network_id: Optional[pulumi.Input[_builtins.str]] = None,
                 read_replica_cluster_ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 redpanda_version: Optional[pulumi.Input[_builtins.str]] = None,
                 region: Optional[pulumi.Input[_builtins.str]] = None,
                 resource_group_id: Optional[pulumi.Input[_builtins.str]] = None,
                 schema_registry: Optional[pulumi.Input[Union['ClusterSchemaRegistryArgs', 'ClusterSchemaRegistryArgsDict']]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 throughput_tier: Optional[pulumi.Input[_builtins.str]] = None,
                 zones: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 __props__=None):
        opts = pulumi.ResourceOptions.merge(_utilities.get_resource_opts_defaults(), opts)
        if not isinstance(opts, pulumi.ResourceOptions):
            raise TypeError('Expected resource options to be a ResourceOptions instance')
        if opts.id is None:
            if __props__ is not None:
                raise TypeError('__props__ is only valid when passed in combination with a valid opts.id to get an existing resource')
            __props__ = ClusterArgs.__new__(ClusterArgs)

            __props__.__dict__["allow_deletion"] = allow_deletion
            __props__.__dict__["aws_private_link"] = aws_private_link
            __props__.__dict__["azure_private_link"] = azure_private_link
            __props__.__dict__["cloud_provider"] = cloud_provider
            if cluster_type is None and not opts.urn:
                raise TypeError("Missing required property 'cluster_type'")
            __props__.__dict__["cluster_type"] = cluster_type
            if connection_type is None and not opts.urn:
                raise TypeError("Missing required property 'connection_type'")
            __props__.__dict__["connection_type"] = connection_type
            __props__.__dict__["customer_managed_resources"] = customer_managed_resources
            __props__.__dict__["gcp_global_access_enabled"] = gcp_global_access_enabled
            __props__.__dict__["gcp_private_service_connect"] = gcp_private_service_connect
            __props__.__dict__["http_proxy"] = http_proxy
            __props__.__dict__["kafka_api"] = kafka_api
            __props__.__dict__["kafka_connect"] = kafka_connect
            __props__.__dict__["maintenance_window_config"] = maintenance_window_config
            __props__.__dict__["name"] = name
            if network_id is None and not opts.urn:
                raise TypeError("Missing required property 'network_id'")
            __props__.__dict__["network_id"] = network_id
            __props__.__dict__["read_replica_cluster_ids"] = read_replica_cluster_ids
            __props__.__dict__["redpanda_version"] = redpanda_version
            __props__.__dict__["region"] = region
            if resource_group_id is None and not opts.urn:
                raise TypeError("Missing required property 'resource_group_id'")
            __props__.__dict__["resource_group_id"] = resource_group_id
            __props__.__dict__["schema_registry"] = schema_registry
            __props__.__dict__["tags"] = tags
            if throughput_tier is None and not opts.urn:
                raise TypeError("Missing required property 'throughput_tier'")
            __props__.__dict__["throughput_tier"] = throughput_tier
            __props__.__dict__["zones"] = zones
            __props__.__dict__["cluster_api_url"] = None
            __props__.__dict__["created_at"] = None
            __props__.__dict__["prometheus"] = None
            __props__.__dict__["redpanda_console"] = None
            __props__.__dict__["state"] = None
            __props__.__dict__["state_description"] = None
        super(Cluster, __self__).__init__(
            'redpanda:index/cluster:Cluster',
            resource_name,
            __props__,
            opts)

    @staticmethod
    def get(resource_name: str,
            id: pulumi.Input[str],
            opts: Optional[pulumi.ResourceOptions] = None,
            allow_deletion: Optional[pulumi.Input[_builtins.bool]] = None,
            aws_private_link: Optional[pulumi.Input[Union['ClusterAwsPrivateLinkArgs', 'ClusterAwsPrivateLinkArgsDict']]] = None,
            azure_private_link: Optional[pulumi.Input[Union['ClusterAzurePrivateLinkArgs', 'ClusterAzurePrivateLinkArgsDict']]] = None,
            cloud_provider: Optional[pulumi.Input[_builtins.str]] = None,
            cluster_api_url: Optional[pulumi.Input[_builtins.str]] = None,
            cluster_type: Optional[pulumi.Input[_builtins.str]] = None,
            connection_type: Optional[pulumi.Input[_builtins.str]] = None,
            created_at: Optional[pulumi.Input[_builtins.str]] = None,
            customer_managed_resources: Optional[pulumi.Input[Union['ClusterCustomerManagedResourcesArgs', 'ClusterCustomerManagedResourcesArgsDict']]] = None,
            gcp_global_access_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
            gcp_private_service_connect: Optional[pulumi.Input[Union['ClusterGcpPrivateServiceConnectArgs', 'ClusterGcpPrivateServiceConnectArgsDict']]] = None,
            http_proxy: Optional[pulumi.Input[Union['ClusterHttpProxyArgs', 'ClusterHttpProxyArgsDict']]] = None,
            kafka_api: Optional[pulumi.Input[Union['ClusterKafkaApiArgs', 'ClusterKafkaApiArgsDict']]] = None,
            kafka_connect: Optional[pulumi.Input[Union['ClusterKafkaConnectArgs', 'ClusterKafkaConnectArgsDict']]] = None,
            maintenance_window_config: Optional[pulumi.Input[Union['ClusterMaintenanceWindowConfigArgs', 'ClusterMaintenanceWindowConfigArgsDict']]] = None,
            name: Optional[pulumi.Input[_builtins.str]] = None,
            network_id: Optional[pulumi.Input[_builtins.str]] = None,
            prometheus: Optional[pulumi.Input[Union['ClusterPrometheusArgs', 'ClusterPrometheusArgsDict']]] = None,
            read_replica_cluster_ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
            redpanda_console: Optional[pulumi.Input[Union['ClusterRedpandaConsoleArgs', 'ClusterRedpandaConsoleArgsDict']]] = None,
            redpanda_version: Optional[pulumi.Input[_builtins.str]] = None,
            region: Optional[pulumi.Input[_builtins.str]] = None,
            resource_group_id: Optional[pulumi.Input[_builtins.str]] = None,
            schema_registry: Optional[pulumi.Input[Union['ClusterSchemaRegistryArgs', 'ClusterSchemaRegistryArgsDict']]] = None,
            state: Optional[pulumi.Input[_builtins.str]] = None,
            state_description: Optional[pulumi.Input[Union['ClusterStateDescriptionArgs', 'ClusterStateDescriptionArgsDict']]] = None,
            tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
            throughput_tier: Optional[pulumi.Input[_builtins.str]] = None,
            zones: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None) -> 'Cluster':
        """
        Get an existing Cluster resource's state with the given name, id, and optional extra
        properties used to qualify the lookup.

        :param str resource_name: The unique name of the resulting resource.
        :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[_builtins.bool] allow_deletion: Allows deletion of the cluster. Defaults to false.
        :param pulumi.Input[Union['ClusterAwsPrivateLinkArgs', 'ClusterAwsPrivateLinkArgsDict']] aws_private_link: AWS PrivateLink configuration.
        :param pulumi.Input[Union['ClusterAzurePrivateLinkArgs', 'ClusterAzurePrivateLinkArgsDict']] azure_private_link: Azure Private Link configuration.
        :param pulumi.Input[_builtins.str] cloud_provider: Cloud provider where resources are created.
        :param pulumi.Input[_builtins.str] cluster_api_url: The URL of the cluster API.
        :param pulumi.Input[_builtins.str] cluster_type: Cluster type. Type is immutable and can only be set on cluster creation.
        :param pulumi.Input[_builtins.str] connection_type: Cluster connection type. Private clusters are not exposed to the internet. For BYOC clusters, Private is best-practice.
        :param pulumi.Input[_builtins.str] created_at: Timestamp when the cluster was created.
        :param pulumi.Input[Union['ClusterCustomerManagedResourcesArgs', 'ClusterCustomerManagedResourcesArgsDict']] customer_managed_resources: Customer managed resources configuration for the cluster.
        :param pulumi.Input[_builtins.bool] gcp_global_access_enabled: If true, GCP global access is enabled.
        :param pulumi.Input[Union['ClusterGcpPrivateServiceConnectArgs', 'ClusterGcpPrivateServiceConnectArgsDict']] gcp_private_service_connect: GCP Private Service Connect configuration.
        :param pulumi.Input[Union['ClusterHttpProxyArgs', 'ClusterHttpProxyArgsDict']] http_proxy: HTTP Proxy properties.
        :param pulumi.Input[Union['ClusterKafkaApiArgs', 'ClusterKafkaApiArgsDict']] kafka_api: Cluster's Kafka API properties.
        :param pulumi.Input[Union['ClusterKafkaConnectArgs', 'ClusterKafkaConnectArgsDict']] kafka_connect: Kafka Connect configuration.
        :param pulumi.Input[Union['ClusterMaintenanceWindowConfigArgs', 'ClusterMaintenanceWindowConfigArgsDict']] maintenance_window_config: Maintenance window configuration for the cluster.
        :param pulumi.Input[_builtins.str] name: Unique name of the cluster.
        :param pulumi.Input[_builtins.str] network_id: Network ID where cluster is placed.
        :param pulumi.Input[Union['ClusterPrometheusArgs', 'ClusterPrometheusArgsDict']] prometheus: Prometheus metrics endpoint properties.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] read_replica_cluster_ids: IDs of clusters that can create read-only topics from this cluster.
        :param pulumi.Input[Union['ClusterRedpandaConsoleArgs', 'ClusterRedpandaConsoleArgsDict']] redpanda_console: Redpanda Console properties.
        :param pulumi.Input[_builtins.str] redpanda_version: Current Redpanda version of the cluster.
        :param pulumi.Input[_builtins.str] region: Cloud provider region. Region represents the name of the region where the cluster will be provisioned.
        :param pulumi.Input[_builtins.str] resource_group_id: Resource group ID of the cluster.
        :param pulumi.Input[Union['ClusterSchemaRegistryArgs', 'ClusterSchemaRegistryArgsDict']] schema_registry: Schema Registry properties.
        :param pulumi.Input[_builtins.str] state: Current state of the cluster.
        :param pulumi.Input[Union['ClusterStateDescriptionArgs', 'ClusterStateDescriptionArgsDict']] state_description: Detailed state description when cluster is in a non-ready state.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags placed on cloud resources. If the cloud provider is GCP and the name of a tag has the prefix "gcp.network-tag.", the tag is a network tag that will be added to the Redpanda cluster GKE nodes. Otherwise, the tag is a normal tag. For example, if the name of a tag is "gcp.network-tag.network-tag-foo", the network tag named "network-tag-foo" will be added to the Redpanda cluster GKE nodes. Note: The value of a network tag will be ignored. See the details on network tags at https://cloud.google.com/vpc/docs/add-remove-network-tags.
        :param pulumi.Input[_builtins.str] throughput_tier: Throughput tier of the cluster.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] zones: Zones of the cluster. Must be valid zones within the selected region. If multiple zones are used, the cluster is a multi-AZ cluster.
        """
        opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))

        __props__ = _ClusterState.__new__(_ClusterState)

        __props__.__dict__["allow_deletion"] = allow_deletion
        __props__.__dict__["aws_private_link"] = aws_private_link
        __props__.__dict__["azure_private_link"] = azure_private_link
        __props__.__dict__["cloud_provider"] = cloud_provider
        __props__.__dict__["cluster_api_url"] = cluster_api_url
        __props__.__dict__["cluster_type"] = cluster_type
        __props__.__dict__["connection_type"] = connection_type
        __props__.__dict__["created_at"] = created_at
        __props__.__dict__["customer_managed_resources"] = customer_managed_resources
        __props__.__dict__["gcp_global_access_enabled"] = gcp_global_access_enabled
        __props__.__dict__["gcp_private_service_connect"] = gcp_private_service_connect
        __props__.__dict__["http_proxy"] = http_proxy
        __props__.__dict__["kafka_api"] = kafka_api
        __props__.__dict__["kafka_connect"] = kafka_connect
        __props__.__dict__["maintenance_window_config"] = maintenance_window_config
        __props__.__dict__["name"] = name
        __props__.__dict__["network_id"] = network_id
        __props__.__dict__["prometheus"] = prometheus
        __props__.__dict__["read_replica_cluster_ids"] = read_replica_cluster_ids
        __props__.__dict__["redpanda_console"] = redpanda_console
        __props__.__dict__["redpanda_version"] = redpanda_version
        __props__.__dict__["region"] = region
        __props__.__dict__["resource_group_id"] = resource_group_id
        __props__.__dict__["schema_registry"] = schema_registry
        __props__.__dict__["state"] = state
        __props__.__dict__["state_description"] = state_description
        __props__.__dict__["tags"] = tags
        __props__.__dict__["throughput_tier"] = throughput_tier
        __props__.__dict__["zones"] = zones
        return Cluster(resource_name, opts=opts, __props__=__props__)

    @_builtins.property
    @pulumi.getter(name="allowDeletion")
    def allow_deletion(self) -> pulumi.Output[Optional[_builtins.bool]]:
        """
        Allows deletion of the cluster. Defaults to false.
        """
        return pulumi.get(self, "allow_deletion")

    @_builtins.property
    @pulumi.getter(name="awsPrivateLink")
    def aws_private_link(self) -> pulumi.Output[Optional['outputs.ClusterAwsPrivateLink']]:
        """
        AWS PrivateLink configuration.
        """
        return pulumi.get(self, "aws_private_link")

    @_builtins.property
    @pulumi.getter(name="azurePrivateLink")
    def azure_private_link(self) -> pulumi.Output[Optional['outputs.ClusterAzurePrivateLink']]:
        """
        Azure Private Link configuration.
        """
        return pulumi.get(self, "azure_private_link")

    @_builtins.property
    @pulumi.getter(name="cloudProvider")
    def cloud_provider(self) -> pulumi.Output[Optional[_builtins.str]]:
        """
        Cloud provider where resources are created.
        """
        return pulumi.get(self, "cloud_provider")

    @_builtins.property
    @pulumi.getter(name="clusterApiUrl")
    def cluster_api_url(self) -> pulumi.Output[_builtins.str]:
        """
        The URL of the cluster API.
        """
        return pulumi.get(self, "cluster_api_url")

    @_builtins.property
    @pulumi.getter(name="clusterType")
    def cluster_type(self) -> pulumi.Output[_builtins.str]:
        """
        Cluster type. Type is immutable and can only be set on cluster creation.
        """
        return pulumi.get(self, "cluster_type")

    @_builtins.property
    @pulumi.getter(name="connectionType")
    def connection_type(self) -> pulumi.Output[_builtins.str]:
        """
        Cluster connection type. Private clusters are not exposed to the internet. For BYOC clusters, Private is best-practice.
        """
        return pulumi.get(self, "connection_type")

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> pulumi.Output[_builtins.str]:
        """
        Timestamp when the cluster was created.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="customerManagedResources")
    def customer_managed_resources(self) -> pulumi.Output[Optional['outputs.ClusterCustomerManagedResources']]:
        """
        Customer managed resources configuration for the cluster.
        """
        return pulumi.get(self, "customer_managed_resources")

    @_builtins.property
    @pulumi.getter(name="gcpGlobalAccessEnabled")
    def gcp_global_access_enabled(self) -> pulumi.Output[Optional[_builtins.bool]]:
        """
        If true, GCP global access is enabled.
        """
        return pulumi.get(self, "gcp_global_access_enabled")

    @_builtins.property
    @pulumi.getter(name="gcpPrivateServiceConnect")
    def gcp_private_service_connect(self) -> pulumi.Output[Optional['outputs.ClusterGcpPrivateServiceConnect']]:
        """
        GCP Private Service Connect configuration.
        """
        return pulumi.get(self, "gcp_private_service_connect")

    @_builtins.property
    @pulumi.getter(name="httpProxy")
    def http_proxy(self) -> pulumi.Output['outputs.ClusterHttpProxy']:
        """
        HTTP Proxy properties.
        """
        return pulumi.get(self, "http_proxy")

    @_builtins.property
    @pulumi.getter(name="kafkaApi")
    def kafka_api(self) -> pulumi.Output['outputs.ClusterKafkaApi']:
        """
        Cluster's Kafka API properties.
        """
        return pulumi.get(self, "kafka_api")

    @_builtins.property
    @pulumi.getter(name="kafkaConnect")
    def kafka_connect(self) -> pulumi.Output['outputs.ClusterKafkaConnect']:
        """
        Kafka Connect configuration.
        """
        return pulumi.get(self, "kafka_connect")

    @_builtins.property
    @pulumi.getter(name="maintenanceWindowConfig")
    def maintenance_window_config(self) -> pulumi.Output['outputs.ClusterMaintenanceWindowConfig']:
        """
        Maintenance window configuration for the cluster.
        """
        return pulumi.get(self, "maintenance_window_config")

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Output[_builtins.str]:
        """
        Unique name of the cluster.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="networkId")
    def network_id(self) -> pulumi.Output[_builtins.str]:
        """
        Network ID where cluster is placed.
        """
        return pulumi.get(self, "network_id")

    @_builtins.property
    @pulumi.getter
    def prometheus(self) -> pulumi.Output['outputs.ClusterPrometheus']:
        """
        Prometheus metrics endpoint properties.
        """
        return pulumi.get(self, "prometheus")

    @_builtins.property
    @pulumi.getter(name="readReplicaClusterIds")
    def read_replica_cluster_ids(self) -> pulumi.Output[Optional[Sequence[_builtins.str]]]:
        """
        IDs of clusters that can create read-only topics from this cluster.
        """
        return pulumi.get(self, "read_replica_cluster_ids")

    @_builtins.property
    @pulumi.getter(name="redpandaConsole")
    def redpanda_console(self) -> pulumi.Output['outputs.ClusterRedpandaConsole']:
        """
        Redpanda Console properties.
        """
        return pulumi.get(self, "redpanda_console")

    @_builtins.property
    @pulumi.getter(name="redpandaVersion")
    def redpanda_version(self) -> pulumi.Output[Optional[_builtins.str]]:
        """
        Current Redpanda version of the cluster.
        """
        return pulumi.get(self, "redpanda_version")

    @_builtins.property
    @pulumi.getter
    def region(self) -> pulumi.Output[Optional[_builtins.str]]:
        """
        Cloud provider region. Region represents the name of the region where the cluster will be provisioned.
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter(name="resourceGroupId")
    def resource_group_id(self) -> pulumi.Output[_builtins.str]:
        """
        Resource group ID of the cluster.
        """
        return pulumi.get(self, "resource_group_id")

    @_builtins.property
    @pulumi.getter(name="schemaRegistry")
    def schema_registry(self) -> pulumi.Output['outputs.ClusterSchemaRegistry']:
        """
        Schema Registry properties.
        """
        return pulumi.get(self, "schema_registry")

    @_builtins.property
    @pulumi.getter
    def state(self) -> pulumi.Output[_builtins.str]:
        """
        Current state of the cluster.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="stateDescription")
    def state_description(self) -> pulumi.Output['outputs.ClusterStateDescription']:
        """
        Detailed state description when cluster is in a non-ready state.
        """
        return pulumi.get(self, "state_description")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> pulumi.Output[Optional[Mapping[str, _builtins.str]]]:
        """
        Tags placed on cloud resources. If the cloud provider is GCP and the name of a tag has the prefix "gcp.network-tag.", the tag is a network tag that will be added to the Redpanda cluster GKE nodes. Otherwise, the tag is a normal tag. For example, if the name of a tag is "gcp.network-tag.network-tag-foo", the network tag named "network-tag-foo" will be added to the Redpanda cluster GKE nodes. Note: The value of a network tag will be ignored. See the details on network tags at https://cloud.google.com/vpc/docs/add-remove-network-tags.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="throughputTier")
    def throughput_tier(self) -> pulumi.Output[_builtins.str]:
        """
        Throughput tier of the cluster.
        """
        return pulumi.get(self, "throughput_tier")

    @_builtins.property
    @pulumi.getter
    def zones(self) -> pulumi.Output[Optional[Sequence[_builtins.str]]]:
        """
        Zones of the cluster. Must be valid zones within the selected region. If multiple zones are used, the cluster is a multi-AZ cluster.
        """
        return pulumi.get(self, "zones")

