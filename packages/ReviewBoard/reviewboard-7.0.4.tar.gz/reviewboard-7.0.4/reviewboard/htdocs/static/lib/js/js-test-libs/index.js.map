{"version":3,"file":"index.js","sources":["../../../../../../node_modules/@beanbag/jasmine-suites/lib/index.js","../../../../../static/lib/js/js-test-libs/index.ts"],"sourcesContent":["(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('jasmine')) :\n    typeof define === 'function' && define.amd ? define(['exports', 'jasmine'], factory) :\n    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.JasmineSuites = {}));\n})(this, (function (exports) { 'use strict';\n\n    /*\n     * Jasmine Suites 2.0.\n     *\n     * This offers namespaced test suites for Jasmine 4.6+.\n     *\n     * Copyright (C) 2016 Beanbag, Inc.\n     *\n     * Licensed under the MIT license.\n     */\n    console.assert(jasmine && jasmine.SuiteBuilder && jasmine.SuiteBuilder.prototype.addSpecsToSuite_, 'jasmine-suites is not compatible with this version of Jasmine');\n    let _curSuiteObj = null;\n    let _rootSuite = null;\n\n    /*\n     * Information on a suite of tests.\n     *\n     * This is a fancy generator for Jasmine describe() calls, which allows for\n     * taking a '/'-separated namespace of names and generating nested test suites.\n     *\n     * Subsequent calls that reuse any of these paths will have their tests added\n     * to the suite. This makes it very easy to organize tests, making it much\n     * easier to run subsets of tests across many files.\n     */\n    const SuiteInfo = function (description) {\n      this.description = description;\n      this.specs = null;\n      this.children = {};\n      this._added = false;\n      this._suiteObj = null;\n    };\n\n    /*\n     * Returns a SuiteInfo for a key, creating one if necessary.\n     *\n     * The SuiteInfo will be added to this suite's list of children.\n     */\n    SuiteInfo.prototype.getOrCreate = function (key, description) {\n      var suite = this.children[key];\n      if (!suite) {\n        suite = new SuiteInfo(description);\n        this.children[key] = suite;\n      }\n      return suite;\n    };\n\n    /*\n     * Adds specs to this suite.\n     *\n     * The specs will either consist of a standard Jasmine specs function (if\n     * the caller sets suite.specs), or a set of internally-generated describe()\n     * calls.\n     */\n    SuiteInfo.prototype._addSpecs = function () {\n      var key;\n      if (!this.specs) {\n        for (key in this.children) {\n          if (this.children.hasOwnProperty(key)) {\n            this.children[key].describe(this);\n          }\n        }\n      } else if (!this._added) {\n        this.specs.call(this._suiteObj);\n      }\n    };\n\n    /*\n     * Runs a describe() for the suite.\n     *\n     * This will run through the tree of specs/suites and generate the set of\n     * nested describe() calls. Each of these will be registered with Jasmine.\n     *\n     * The result will be a jasmine.Suite object.\n     */\n    SuiteInfo.prototype.describe = function (parentSuiteInfo) {\n      var self = this;\n      if (self._added) {\n        self._addSpecs();\n      } else {\n        describe(self.description, function () {\n          var parentSuiteObj, oldParentSuiteObj, i;\n          self._suiteObj = _curSuiteObj;\n          console.assert(self._suiteObj);\n          if (parentSuiteInfo) {\n            parentSuiteObj = parentSuiteInfo._suiteObj;\n            oldParentSuiteObj = self._suiteObj.parentSuite;\n            if (oldParentSuiteObj !== parentSuiteObj) {\n              /*\n               * Remove the suite object from the old parent. This could\n               * potentially be slow, but in reality it's not going to\n               * have a large search space for most suites.\n               */\n              i = oldParentSuiteObj.children.indexOf(self._suiteObj);\n              if (i !== -1) {\n                oldParentSuiteObj.children.splice(i, 1);\n              }\n\n              /* Add the suite to the new parent and fix relations. */\n              parentSuiteObj.addChild(self._suiteObj);\n              self._suiteObj.parentSuite = parentSuiteObj;\n\n              /* Re-generate the full name of the suite. */\n              self._suiteObj.result.fullName = self._suiteObj.getFullName();\n            }\n          }\n          self._addSpecs();\n          self._added = true;\n        });\n      }\n      return self._suiteObj;\n    };\n    _rootSuite = new SuiteInfo();\n\n    /*\n     * We need access to the suite objects, which we can no longer get with 'this'\n     * above. So we need to monkey-patch the SuiteBuilder to capture this.\n     */\n    const suiteBuilderProto = jasmine.SuiteBuilder.prototype;\n    const _addSpecsToSuite = suiteBuilderProto.addSpecsToSuite_;\n    suiteBuilderProto.addSpecsToSuite_ = function (suite, definitionFn) {\n      _curSuiteObj = suite;\n      return _addSpecsToSuite.call(this, suite, definitionFn);\n    };\n\n    /*\n     * Defines a test suite with a nested, reusable namespace.\n     *\n     * The namespace consists of a '/'-separated list of names that the provided\n     * specs of tests belong to. Each name in the list is equivalent to a\n     * Jasmine describe() call, nested in the spec for the previous name, with\n     * the exception these names can be reused across files.\n     *\n     * If more than one file has the same prefix for its namespace, those\n     * describe() suites will be reused. This makes it really easy to categorize\n     * tests under file paths, project names, or anything else, allowing those\n     * related tests to be run together.\n     */\n    function suite(namespace, specs) {\n      var parts = namespace.split('/'),\n        parentSuite = _rootSuite,\n        key = '',\n        description,\n        curSuite,\n        firstSuite,\n        i;\n      for (i = 0; i < parts.length; i++) {\n        description = parts[i];\n        key += '/' + description;\n        curSuite = parentSuite.getOrCreate(key, description);\n        parentSuite = curSuite;\n        if (!firstSuite) {\n          firstSuite = curSuite;\n        }\n      }\n\n      /* The last suite is the one that'll run the provided test specs. */\n      curSuite.specs = specs;\n      return firstSuite.describe();\n    }\n    jasmine.getGlobal().suite = suite;\n\n    exports.suite = suite;\n\n}));\n//# sourceMappingURL=index.js.map\n","import { suite } from '@beanbag/jasmine-suites';\n\n\n/* Export what's needed to the global namespace. */\nconst _global = typeof globalThis !== 'undefined' ? globalThis : self;\n\n_global.suite = suite;\n"],"names":["console","assert","jasmine","SuiteBuilder","prototype","addSpecsToSuite_","_curSuiteObj","_rootSuite","SuiteInfo","description","children","_added","_suiteObj","getOrCreate","key","suite","_addSpecs","specs","hasOwnProperty","describe","call","parentSuiteInfo","self","parentSuiteObj","oldParentSuiteObj","i","parentSuite","indexOf","splice","addChild","result","fullName","getFullName","suiteBuilderProto","definitionFn","_addSpecsToSuite","curSuite","namespace","parts","split","_global","globalThis"],"mappings":";;;;;;;;;;;;;;;;;;;CAAA;;;;;;;;;CAkBAA,IAAAA,OAAA,CAAAC,MAAA,CAAAC,OAAA,IAAAA,OAAA,CAAAC,YAAA,IAAAD,OAAA,CAAAC,YAAA,CAAAC,SAAA,CAAAC,gBAAA,EAAA,+DAAA,CAAA,CAAA;CACA,IAAA,IAAAC,YAAA,GAAA,IAAA,CAAA;CACA,IAAA,IAAAC,UAAA,GAAA,IAAA,CAAA;;CAEA;;;;;;;;;;WAWUC,SAAO,GAAG;OACpB,IAAAC,CAAAA,WAAA,GAAAA,WAAA,CAAA;;CAGA,MAAA,IAAA,CAAAC,QAAA,GAAA,EAAA,CAAA;CACA,MAAA,IAAA,CAAAC,MAAA,GAAA,KAAA,CAAA;CACA,MAAA,IAAA,CAAAC,SAAA,GAAA,IAAA,CAAA;CACA,KAAA,CAAA;;;;;;;CAQMJ,IAAAA,SAAA,CAAAJ,SAAA,CAAAS,WAAA,GAAAC,UAAAA,GAAA,EAAAL,WAAA,EAAA;CAEN,MAAA,IAAAM,KAAA,GAAA,IAAAL,CAAAA,QAAA,CAAAI,GAAA,CAAA,CAAA;CACA,MAAA,IAAA,CAAAC,KAAA,EAAA;;CAGA,QAAA,IAAA,CAAAL,QAAA,CAAAI,GAAA,CAAA,GAAAC,KAAA,CAAA;CACA,OAAA;CACA,MAAA,OAAAA,KAAA,CAAA;CACA,KAAA,CAAA;;;;;;;;;cAUa,CAAAX,SAAM,CAASY,SAAU,GAAE,YAAA;CACjC,MAAA,IAAAF,GAAA,CAAA;CACD,MAAA,IAAA,CAAA,IAAA,CAAAG,KAAA,EAAA;CACN,QAAA,KAAAH,GAAA,IAAA,IAAA,CAAAJ,QAAA,EAAA;CACA,UAAA,IAAA,IAAA,CAAAA,QAAA,CAAAQ,cAAA,CAAAJ,GAAA,CAAA,EAAA;CACA,YAAA,IAAA,CAAAJ,QAAA,CAAAI,GAAA,CAAA,CAAAK,QAAA,CAAA,IAAA,CAAA,CAAA;CACA,WAAA;;CAGA,OAAA,MAAA,IAAA,CAAA,IAAA,CAAAR,MAAA,EAAA;CACA,QAAA,IAAA,CAAAM,KAAA,CAAAG,IAAA,CAAA,IAAA,CAAAR,SAAA,CAAA,CAAA;CACA,OAAA;;;CAGA;;;;;;;;CASAJ,IAAAA,SAAA,CAAAJ,kBAAgC,GAAA,UAAAiB,eAAc,EAAA;CAC9C,MAAA,IAAAC,IAAgB,GAAA,IAAA,CAAA;WAIhBA,IAAA,CAAAX,MAAA,EAAA;SACAW,IAAA,CAAAN,SAAA,EAAA,CAAA;QAEkB,MAAA;iBACF,CAAAM,IAAA,CAAAb,WAAA,EAA2B,YAAA;CAC5B,UAAA,IAAAc,cAAA,EAAAC,iBAAA,EAAAC,CAAA,CAAA;eAEf,CAAAb,SAAA,GAAAN,YAAA,CAAA;CACcN,UAAAA,OAAA,CAAAC,MAAA,CAAAqB,IAAA,CAAAV,SAAA,CAAA,CAAA;CACd,UAAA,IAAAS,eAAA,EAAA;aACAE,cAAA,GAAAF,eAAA,CAAAT,SAAA,CAAA;CACAY,YAAAA,iBAAA,GAAAF,IAAA,CAAAV,SAAA,CAAAc,WAAA,CAAA;aACA,IAAAF,iBAAA,KAAAD,cAAA,EAAA;CACa;;;;;eAMKE,CAAA,GAAAD,iBAAA,CAAAd,QAAA,CAAAiB,OAAA,CAAAL,IAAA,CAAAV,SAAA,CAAA,CAAA;CACZ,cAAA,IAAAa,CAAA,KAAA,CAAA,CAAA,EAAA;CACeD,gBAAAA,iBAAY,CAAAd,QAAA,CAAAkB,MAAA,CAAAH,CAAA,EAAA,CAAA,CAAA,CAAA;;;CAGjC;CAEAF,cAAAA,cAAA,CAAAM,QAAA,CAAAP,IAAA,CAAAV,SAAA,CAAA,CAAA;;;CAIM;eACAU,IAAA,CAAAV,SAAA,CAAAkB,MAAA,CAAAC,QAAA,GAAAT,IAAA,CAAAV,SAAA,CAAAoB,WAAA,EAAA,CAAA;CACN,aAAA;CAEA,WAAA;CACAV,UAAAA,IAAA,CAAAN,SAAA,EAAA,CAAA;CAGAM,UAAAA,IAAA,CAAAX,MAAA,GAAA,IAAA,CAAA;;CAGA,OAAA;OACA,OAAAW,IAAA,CAAAV,SAAA,CAAA;CACA,KAAA,CAAA;CACAL,IAAAA,UAAA,OAAAC,SAAA,EAAA,CAAA;;CAEA;;;;CAMA,IAAA,MAAAyB,iBAAA,GAAA/B,OAAA,CAAAC,YAAA,CAAAC,SAAA,CAAA;;CAGA6B,IAAAA,iBAAA,CAAA5B,gBAAA,GAAAU,UAAAA,KAAA,EAAAmB,YAAA,EAAA;CACA5B,MAAAA,YAAA,GAAAS,KAAA,CAAA;CACA,MAAA,OAAAoB,gBAAA,CAAAf,IAAA,CAAAL,IAAAA,EAAAA,KAAA,EAAAmB,YAAA,CAAA,CAAA;;;;;;;;;;;;;;;;cAgBInB,KAAAqB,CAAAC,SAAA,EAAApB,KAAA,EAAA;WACJqB,KAAA,GAAAD,SAAA,CAAAE,KAAA,CAAA,GAAA,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;CCtKA;CACA,MAAMC,OAAO,GAAG,OAAOC,UAAU,KAAK,WAAW,GAAGA,UAAU,GAAGnB,IAAI,CAAA;CAErEkB,OAAO,CAACzB,KAAK,GAAGA,gBAAK;;;;;;"}