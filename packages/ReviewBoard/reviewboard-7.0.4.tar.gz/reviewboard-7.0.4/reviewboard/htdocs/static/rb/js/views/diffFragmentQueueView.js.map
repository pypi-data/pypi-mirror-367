{"version":3,"file":"diffFragmentQueueView.js","names":["RB","DiffFragmentQueueView","Backbone","View","extend","initialize","options","_containerPrefix","containerPrefix","_diffFragmentViewOptions","diffFragmentViewOptions","_fragmentsBasePath","reviewRequestPath","_queueName","queueName","_queue","_saved","queueLoad","commentID","key","onFragmentRendered","queue","push","saveFragment","$el","_getCommentContainer","length","data","html","loadFragments","onDone","_","isEmpty","isFunction","each","queuedLoads","$","funcQueue","add","pendingCommentIDs","onFragmentRenderedFuncs","i","queuedLoad","hasOwnProperty","container","console","assert","view","render","_renderFragment","_loadDiff","join","next","start","commentIDs","queryArgs","linesOfContext","undefined","includes","TEMPLATE_SERIAL","apiCall","url","dataType","type","success","arrayBuffer","dataView","DataView","len","byteLength","pos","totalFragments","totalRenders","done","onFragmentLoaded","containerID","$container","error","parsed","_parseDiffFragmentFromPayload","load","getUint32","htmlLen","htmlStart","cb","DataUtils","readBlobAsString","Blob","slice","scrollManager","markForUpdate","DiffFragmentView","defaults","el","loadDiff","setActivityIndicator","markUpdated"],"sources":["../../../../../static/rb/js/views/diffFragmentQueueView.es6.js"],"sourcesContent":["/**\n * Queues loading of diff fragments from a page.\n *\n * This is used to load diff fragments one-by-one, and to intelligently\n * batch the loads to only fetch at most one set of fragments per file.\n */\nRB.DiffFragmentQueueView = Backbone.View.extend({\n    /**\n     * Initialize the queue.\n     *\n     * Args:\n     *     options (object):\n     *         Options passed to this view.\n     *\n     * Returns:\n     *     containerPrefix (string):\n     *         The prefix to prepend to diff comment IDs when forming\n     *         container element IDs.\n     *\n     *     diffFragmentViewOptions (object, optional):\n     *         Options to pass to each :js:class:`RB.DiffFragmentView` that's\n     *         created.\n     *\n     *     reviewRequestPath (string):\n     *         The URL for the review request that diff fragments will be\n     *         loaded from.\n     *\n     *     queueName (string):\n     *         The name of the diff loading queue.\n     */\n    initialize(options) {\n        this._containerPrefix = options.containerPrefix;\n        this._diffFragmentViewOptions = options.diffFragmentViewOptions;\n        this._fragmentsBasePath =\n            `${options.reviewRequestPath}_fragments/diff-comments/`;\n        this._queueName = options.queueName;\n\n        this._queue = {};\n        this._saved = {};\n    },\n\n    /**\n     * Queue the load of a diff fragment from the server.\n     *\n     * This will be added to a list, which will fetch the comments in batches\n     * based on file IDs.\n     *\n     * Args:\n     *     commentID (string):\n     *         The ID of the comment to queue.\n     *\n     *     key (string):\n     *         The key for the queue. Each comment with the same key will be\n     *         loaded in a batch. This will generally be the ID of a file.\n     *\n     *     onFragmentRendered (function, optional):\n     *         Optional callback for when the view for the fragment has\n     *         rendered. Contains the view as a parameter.\n     */\n    queueLoad(commentID, key, onFragmentRendered) {\n        const queue = this._queue;\n\n        if (!queue[key]) {\n            queue[key] = [];\n        }\n\n        queue[key].push({\n            commentID: commentID,\n            onFragmentRendered: onFragmentRendered || null,\n        });\n    },\n\n    /**\n     * Save a comment's loaded diff fragment for the next load operation.\n     *\n     * If the comment's diff fragment was already loaded, it will be\n     * temporarily stored until the next load operation involving that\n     * comment. Instead of loading the fragment from the server, the saved\n     * fragment's HTML will be used instead.\n     *\n     * Args:\n     *     commentID (string):\n     *         The ID of the comment to save.\n     */\n    saveFragment(commentID) {\n        const $el = this._getCommentContainer(commentID);\n\n        if ($el.length === 1 && $el.data('diff-fragment-view')) {\n            this._saved[commentID] = $el.html();\n        }\n    },\n\n    /**\n     * Load all queued diff fragments.\n     *\n     * The diff fragments for each keyed set in the queue will be loaded as\n     * a batch. The resulting fragments will be injected into the DOM.\n     *\n     * Any existing fragments that were saved will be loaded from the cache\n     * without requesting them from the server.\n     *\n     * Args:\n     *     onDone (function, optional):\n     *         Callback for when all fragments have been loaded.\n     */\n    loadFragments(onDone) {\n        if (_.isEmpty(this._queue) && _.isEmpty(this._saved)) {\n            if (_.isFunction(onDone)) {\n                onDone();\n            }\n\n            return;\n        }\n\n        const queueName = this._queueName;\n\n        _.each(this._queue, queuedLoads => {\n            $.funcQueue(queueName).add(() => {\n                const pendingCommentIDs = [];\n                const onFragmentRenderedFuncs = {};\n\n                /*\n                 * Check if there are any comment IDs that have been saved.\n                 * We don't need to reload these from the server.\n                 */\n                for (let i = 0; i < queuedLoads.length; i++) {\n                    const queuedLoad = queuedLoads[i];\n                    const commentID = queuedLoad.commentID;\n                    const onFragmentRendered =\n                        _.isFunction(queuedLoad.onFragmentRendered)\n                        ? queuedLoad.onFragmentRendered\n                        : null;\n\n                    if (this._saved.hasOwnProperty(commentID)) {\n                        const html = this._saved[commentID];\n\n                        const container = this._getCommentContainer(commentID);\n                        console.assert(container);\n\n                        let view = container.data('diff-fragment-view');\n\n                        if (view) {\n                            view.$el.html(html);\n                            view.render();\n                        } else {\n                            view = this._renderFragment(container, commentID,\n                                                        html);\n                        }\n\n                        if (onFragmentRendered) {\n                            onFragmentRendered(view);\n                        }\n\n                        delete this._saved[commentID];\n                    } else {\n                        pendingCommentIDs.push(commentID);\n                        onFragmentRenderedFuncs[commentID] =\n                            onFragmentRendered;\n                    }\n                }\n\n                if (pendingCommentIDs.length > 0) {\n                    /*\n                     * There are some comment IDs we don't have. Load these\n                     * from the server.\n                     *\n                     * Once these are loaded, they'll call next() on the queue\n                     * to process the next batch.\n                     */\n                    this._loadDiff(pendingCommentIDs.join(','), {\n                        queueName: queueName,\n                        onFragmentRendered: (commentID, view) => {\n                            if (onFragmentRenderedFuncs[commentID]) {\n                                onFragmentRenderedFuncs[commentID](view);\n                            }\n                        },\n                        onDone: () => $.funcQueue(queueName).next(),\n                    });\n                } else {\n                    /*\n                     * We processed all we need to process above. Go to the\n                     * next queue.\n                     */\n                    $.funcQueue(queueName).next();\n                }\n            });\n        });\n\n        if (_.isFunction(onDone)) {\n            $.funcQueue(queueName).add(() => {\n                onDone();\n                $.funcQueue(queueName).next();\n            });\n        }\n\n        // Clear the list.\n        this._queue = {};\n\n        $.funcQueue(queueName).start();\n    },\n\n    /**\n     * Return the container for a particular comment.\n     *\n     * Args:\n     *     commentID (string):\n     *         The ID of the comment.\n     *\n     * Returns:\n     *     jQuery:\n     *     The comment container, wrapped in a jQuery element. The caller\n     *     may want to check the length to be sure the container was found.\n     */\n    _getCommentContainer(commentID) {\n        return $(`#${this._containerPrefix}_${commentID}`);\n    },\n\n    /**\n     * Load a diff fragment for the given comment IDs and options.\n     *\n     * This will construct the URL for the relevant diff fragment and load\n     * it from the server.\n     *\n     * Args:\n     *     commentIDs (string):\n     *         A string of comment IDs to load fragments for.\n     *\n     *     options (object, optional):\n     *         Options for the loaded diff fragments.\n     *\n     * Option Args:\n     *     linesOfContext (string):\n     *         The lines of context to load for the diff. This is a string\n     *         containing a comma-separated set of line counts in the form\n     *         of ``numLinesBefore,numLinesAfter``.\n     *\n     *     onDone (function):\n     *         A function to call after the diff has been loaded.\n     *\n     *     queueName (string):\n     *         The name of the load queue. This is used to load batches of\n     *         fragments sequentially.\n     */\n    _loadDiff(commentIDs, options={}) {\n        const containerPrefix = this._containerPrefix;\n        const queryArgs = [];\n        const onFragmentRendered = (_.isFunction(options.onFragmentRendered)\n                                    ? options.onFragmentRendered\n                                    : null);\n\n        if (options.linesOfContext !== undefined) {\n            queryArgs.push(`lines_of_context=${options.linesOfContext}`);\n        }\n\n        if (!containerPrefix.includes('draft')) {\n            queryArgs.push('allow_expansion=1');\n        }\n\n        queryArgs.push(TEMPLATE_SERIAL);\n\n        RB.apiCall({\n            url: `${this._fragmentsBasePath}${commentIDs}/`,\n            data: queryArgs.join('&'),\n            dataType: 'arraybuffer',\n            type: 'GET',\n            success: arrayBuffer => {\n                const dataView = new DataView(arrayBuffer);\n                const len = dataView.byteLength;\n                let pos = 0;\n                let totalFragments = 0;\n                let totalRenders = 0;\n                let done = false;\n\n                const onFragmentLoaded = (commentID, html) => {\n                    /* Set the HTML in the container. */\n                    const containerID = `#${containerPrefix}_${commentID}`;\n                    const $container = $(containerID);\n\n                    if ($container.length === 0) {\n                        /*\n                         * This doesn't actually exist. We may be dealing with\n                         * inconsistent state due to something missing in the\n                         * database. We don't want to break the page if this\n                         * happens, so log and skip the entry.\n                         */\n                        console.error('Unable to find container %s for ' +\n                                      'comment ID %s. There may be missing ' +\n                                      'state in the database.',\n                                      containerID, commentID);\n                    } else {\n                        const view = this._renderFragment(\n                            $(`#${containerPrefix}_${commentID}`),\n                            commentID,\n                            html);\n\n                        if (onFragmentRendered) {\n                            onFragmentRendered(commentID, view);\n                        }\n                    }\n\n                    totalRenders++;\n\n                    if (done && totalRenders === totalFragments &&\n                        _.isFunction(options.onDone)) {\n                        /*\n                         * We've parsed and rendered all fragments, so we're\n                         * officially done.\n                         */\n                        options.onDone();\n                    }\n                }\n\n                while (!done) {\n                    const parsed = this._parseDiffFragmentFromPayload(\n                        arrayBuffer, dataView, pos);\n\n                    totalFragments++;\n                    pos = parsed.pos;\n                    done = (pos >= len);\n\n                    parsed.load(onFragmentLoaded);\n                }\n            }\n        });\n    },\n\n    /**\n     * Parse a single diff fragment from the payload.\n     *\n     * This will parse out information about the fragment (the comment ID and\n     * HTML) and return a response containing the new position and a function\n     * to call in order to load the parsed fragment.\n     *\n     * Args:\n     *     arrayBuffer (ArrayBuffer):\n     *         The array buffer being parsed.\n     *\n     *     dataView (DataView):\n     *         The data view on top of the array buffer, used to extract\n     *         information.\n     *\n     *     pos (number):\n     *         The current position within the array buffer.\n     *\n     * Returns:\n     *     object:\n     *     An object with two keys:\n     *\n     *     ``pos``:\n     *         The next position to parse.\n     *\n     *     ``load``:\n     *         A function for loading the fragment content. This takes a\n     *         callback function as an argument containing ``commentID`` and\n     *         ``html`` arguments.\n     */\n    _parseDiffFragmentFromPayload(arrayBuffer, dataView, pos) {\n        /* Read the comment ID. */\n        const commentID = dataView.getUint32(pos, true);\n        pos += 4;\n\n        /* Read the length of the HTML. */\n        const htmlLen = dataView.getUint32(pos, true);\n        pos += 4;\n\n        /* Read the HTML position for later. */\n        const htmlStart = pos;\n        pos += htmlLen;\n\n        return {\n            pos: pos,\n            load(cb) {\n                RB.DataUtils.readBlobAsString(\n                    new Blob([arrayBuffer.slice(htmlStart,\n                                                htmlStart + htmlLen)]),\n                    html => cb(commentID, html));\n            },\n        };\n    },\n\n    /**\n     * Render a diff fragment on the page.\n     *\n     * This will set up a view for the diff fragment, if one is not already\n     * created, and render it on the page.\n     *\n     * It will also mark the fragment for updates with the scroll manager\n     * so that if the user is scrolled to a location past the fragment, the\n     * resulting size change for the fragment won't cause the page to jump.\n     *\n     * Args:\n     *     $container (jQuery):\n     *         The container element where the fragment will be injected.\n     *\n     *     commentID (number):\n     *         The ID of the comment.\n     *\n     *     html (string):\n     *         The HTML contents of the fragment.\n     */\n    _renderFragment($container, commentID, html) {\n        RB.scrollManager.markForUpdate($container);\n\n        $container.html(html);\n\n        let view = $container.data('diff-fragment-view');\n\n        if (!view) {\n            view = new RB.DiffFragmentView(_.defaults({\n                el: $container,\n                loadDiff: options => {\n                    RB.setActivityIndicator(true, {type: 'GET'});\n\n                    this._loadDiff(commentID, _.defaults({\n                        onDone() {\n                            RB.setActivityIndicator(false, {});\n\n                            if (options.onDone) {\n                                options.onDone();\n                            }\n                        },\n                    }, options));\n                },\n            }, this._diffFragmentViewOptions));\n            $container.data('diff-fragment-view', view);\n        }\n\n        view.render();\n\n        RB.scrollManager.markUpdated($container);\n\n        return view;\n    },\n});\n"],"mappings":"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","ignoreList":[]}