{"version":3,"file":"scrollManagerView.js","names":["RB","ScrollManagerView","Backbone","View","extend","initialize","scrollYOffset","window","_updateScrollPosScheduled","_pendingElements","Map","_elements","_oldScrollY","_useScrollYOffset","scrollToElement","$el","scrollToPosition","offset","top","scrollY","scrollTo","pageXOffset","history","scrollRestoration","_scheduleUpdateScrollPos","markForUpdate","console","assert","length","oldOffset","set","oldHeight","outerHeight","left","pageYOffset","markUpdated","el","elInfo","get","newHeight","newOffset","delete","requestAnimationFrame","_updateScrollPos","bind","elInfos","forEach","newHeighht","push","sort","a","b","i","clear","scrollManager"],"sources":["../../../../../../static/rb/js/ui/views/scrollManagerView.es6.js"],"sourcesContent":["/**\n * Manages behavior and UI related to scrolling the page.\n *\n * This can be used by the UI to track pending and completed updates to\n * elements that might affect the current scroll position, such as new content\n * being injected into the DOM or being hidden/shown. When such updates occur\n * that would cause a page jump, the scroll manager will fix the scroll\n * position to counteract the jump.\n *\n * When a view is ready to make a DOM change that would impact the display or\n * size of an element, it should call\n * :js:func:`RB.ScrollManagerView.markForUpdate` before updating the element.\n * After, it should call :js:func:`RB.ScrollManagerView.markUpdates`.\n *\n * Views that create floating elements at the top of the page (such as banners)\n * should increment :js:attr:`RB.ScrollManagerView.scrollYOffset` by the height\n * of the element, and decrement it when the element goes away. This will\n * ensure that when navigating to an element through the scroll manager that\n * the height of the floating element will be taken into consideration for\n * the positioning.\n *\n * Attributes:\n *     scrollYOffset (number):\n *         The offset to add when scrolling to a target element or position.\n *         Callers should only increment or decrement this, and should never\n *         set it directly.\n */\nRB.ScrollManagerView = Backbone.View.extend({\n    /**\n     * Initialize the scroll manager.\n     */\n    initialize() {\n        this.scrollYOffset = 0;\n\n        // This is used so that unit tests can create a dummy window.\n        this.window = window;\n\n        this._updateScrollPosScheduled = false;\n        this._pendingElements = new Map();\n        this._elements = new Map();\n        this._oldScrollY = null;\n        this._useScrollYOffset = false;\n    },\n\n    /**\n     * Scroll to a specific element on the page.\n     *\n     * This will take the scroll offset into account.\n     *\n     * Args:\n     *     $el (jQuery):\n     *         The element to scroll to.\n     */\n    scrollToElement($el) {\n        this.scrollToPosition($el.offset().top);\n    },\n\n    /**\n     * Scroll to a specific position on the page.\n     *\n     * This will take the scroll offset into account.\n     *\n     * Args:\n     *     scrollY (number):\n     *         The Y position to scroll to.\n     */\n    scrollToPosition(scrollY) {\n        this._oldScrollY = scrollY;\n\n        /*\n         * We use this instead of a flag being passed around to functions\n         * because we might actually end up using a pre-scheduled update to\n         * the scroll position, rather than scheduling a new one.\n         */\n        this._useScrollYOffset = true;\n\n        /* Attempt to immedialely scroll to the desired position. */\n        this.window.scrollTo(this.window.pageXOffset, scrollY);\n\n        /*\n         * Chrome (and possibly other browsers in the future) attempt to be\n         * smart about restoring the initial scroll position after the page\n         * has fully loaded. However, we want to control the position in this\n         * case (probably in response to something in the URL we're handling),\n         * so we want to disable Chrome's behavior. Fortunately, there's an\n         * API for that.\n         */\n        if ('scrollRestoration' in history) {\n            history.scrollRestoration = 'manual';\n        }\n\n        this._scheduleUpdateScrollPos(true);\n    },\n\n    /**\n     * Mark an element for update.\n     *\n     * This should be called when an element will be updated with new\n     * content/size/visibility. The current state of the element will be\n     * tracked. When the update has finished, :js:func:`markUpdated` should\n     * be called to finalize the update.\n     *\n     * Args:\n     *     $el (jQuery):\n     *         The element being updated.\n     */\n    markForUpdate($el) {\n        console.assert($el.length === 1);\n\n        const oldOffset = $el.offset();\n\n        this._pendingElements.set($el[0], {\n            oldHeight: $el.outerHeight(),\n            oldOffset: {\n                left: oldOffset.left,\n                top: oldOffset.top,\n            },\n        });\n\n        if (this._oldScrollY === null) {\n            this._oldScrollY = this.window.pageYOffset;\n        }\n    },\n\n    /**\n     * Mark an element as having been updated.\n     *\n     * This will schedule a scroll position update, factoring in the size\n     * and position differences for the element and helping prevent a page\n     * jump if the update occurred before the current scroll position.\n     *\n     * Args:\n     *     $el (jQuery):\n     *         The element that was updated.\n     */\n    markUpdated($el) {\n        console.assert($el.length === 1);\n\n        const el = $el[0];\n        const elInfo = this._pendingElements.get(el);\n\n        if (elInfo) {\n            elInfo.newHeight = $el.outerHeight();\n            elInfo.newOffset = $el.offset();\n\n            this._elements.set(el, elInfo);\n            this._pendingElements.delete(el);\n        }\n\n        this._scheduleUpdateScrollPos();\n    },\n\n    /**\n     * Schedule an update for the scroll position.\n     *\n     * This will schedule the scroll position to be updated to take into\n     * account any updated elements. The update will happen in the next\n     * available animation frame. Only one will ever be scheduled at a time.\n     */\n    _scheduleUpdateScrollPos() {\n        if (!this._updateScrollPosScheduled) {\n            this._updateScrollPosScheduled = true;\n\n            /*\n             * Ideally we would update the DOM and set the scroll position at\n             * the same time, synchronized, without waiting for an animation\n             * frame and preventing any kind of a jump. This would work okay\n             * in some browsers (Chrome and Firefox are pretty good at not\n             * jumping), but some -- Safari (as of 10.1), Internet Explorer\n             * (as of 11), and Edge (as of 38.14393) -- will still jump after\n             * our code executes.\n             *\n             * We can minimize that jump by performing the scroll update during\n             * an animation frame, getting it as close as possible to the DOM\n             * layout update.\n             */\n            this.window.requestAnimationFrame(\n                this._updateScrollPos.bind(this));\n        }\n    },\n\n    /**\n     * Update the scroll position to factor in any element updates.\n     *\n     * This will look for any tracked elements that have been updated\n     * earlier in the page (before the current scroll position). It will\n     * then update the scroll position to take those updates into account,\n     * helping prevent a page jump.\n     */\n    _updateScrollPos() {\n        const elInfos = [];\n\n        this._elements.forEach((elInfo, el) => {\n            /*\n             * Check if the element remained the same size. We can ignore\n             * these.\n             */\n            if (elInfo.oldHeight !== elInfo.newHeighht) {\n                elInfo.el = el;\n                elInfos.push(elInfo);\n            }\n        });\n\n        let scrollY = this._oldScrollY;\n\n        if (this._useScrollYOffset) {\n            scrollY -= this.scrollYOffset;\n        }\n\n        if (elInfos.length > 0) {\n            /* Try to put these in order by position. */\n            elInfos.sort((a, b) => a.newOffset.top - b.newOffset.top);\n\n            for (let i = 0; i < elInfos.length; i++) {\n                const elInfo = elInfos[i];\n\n                /* Check if the element precedes the current scroll position. */\n                if (elInfo.newOffset.top + elInfo.newHeight < scrollY) {\n                    scrollY += (elInfo.newHeight - elInfo.oldHeight) +\n                               (elInfo.newOffset.top - elInfo.oldOffset.top);\n                }\n            }\n        }\n\n        this.window.scrollTo(this.window.pageXOffset, scrollY);\n\n        this._elements.clear();\n        this._oldScrollY = null;\n        this._useScrollYOffset = false;\n        this._updateScrollPosScheduled = false;\n    },\n});\n\n\nRB.scrollManager = new RB.ScrollManagerView();\n"],"mappings":"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","ignoreList":[]}