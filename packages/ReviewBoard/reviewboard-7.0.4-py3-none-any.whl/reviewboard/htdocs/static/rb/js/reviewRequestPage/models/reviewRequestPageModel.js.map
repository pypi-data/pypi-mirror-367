{"version":3,"file":"reviewRequestPageModel.js","names":["RB","ReviewRequestPage","ReviewablePage","extend","WATCH_UPDATED_BACKOFF_MULTIPLIER","WATCH_UPDATED_POLL_CAP_MS","defaults","_","updatesURL","prototype","initialize","apply","arguments","_watchedEntries","_watchedUpdatesPeriodMS","_watchedUpdatesTimeout","_watchedUpdatesLastScheduleTime","_watchedUpdatesLastTimestamp","entries","Backbone","Collection","model","Entry","parse","rsp","call","addEntry","entry","set","add","watchEntryUpdates","periodMS","Date","now","clearTimeout","id","_scheduleCheckUpdates","stopWatchingEntryUpdates","hasOwnProperty","isEmpty","key","Math","min","setTimeout","_loadUpdates","pluck","onDone","totalApplied","round","options","get","allEntryIDs","urlQuery","length","i","typeID","push","urlEntryTypeIDs","entryTypeID","sort","a","b","entryIDs","join","timestamp","toISOString","urlQueryStr","sync","url","dataType","noActivityIndicator","success","arrayBuffer","_processUpdatesFromPayload","byteLength","dataView","DataView","len","pos","totalUpdates","done","onUpdateLoaded","metadata","html","type","_processEntryUpdate","_reloadFromUpdate","newTimestamp","moment","utc","updatedTimestamp","toDate","lastTimestamp","trigger","isFunction","parsed","_processUpdateFromPayload","load","metadataLen","getUint32","metadataStart","htmlLen","htmlStart","cb","metadataBlob","Blob","slice","htmlBlob","DataUtils","readManyBlobsAsStrings","JSON","entryID","console","assert","entryType","isUpdated","beforeApplyUpdate","attributes","modelData","etag","afterApplyUpdate"],"sources":["../../../../../../static/rb/js/reviewRequestPage/models/reviewRequestPageModel.es6.js"],"sourcesContent":["/**\n * Model for the review request page.\n *\n * This manages state specific to the review request page, and handles\n * watching for server-side updates relevant to entries and UI on the page.\n */\nRB.ReviewRequestPage.ReviewRequestPage = RB.ReviewablePage.extend({\n    /**\n     * A multiplier to apply to the current polling interval for backoff.\n     *\n     * Every time an empty update comes in, this value will be multiplied onto\n     * the current polling interval, delaying the time until the next poll.\n     *\n     * Version Added:\n     *     6.0\n     */\n    WATCH_UPDATED_BACKOFF_MULTIPLIER: 1.15,\n\n    /**\n     * The maximum delay for polling intervals.\n     *\n     * This is applied only when calculating a new polling interval for\n     * backoff.\n     *\n     * Version Added:\n     *     6.0\n     */\n    WATCH_UPDATED_POLL_CAP_MS: 10 * 1000,\n\n    defaults: _.defaults({\n        updatesURL: null,\n    }, RB.ReviewablePage.prototype.defaults),\n\n    /**\n     * Initialize the model.\n     */\n    initialize() {\n        RB.ReviewablePage.prototype.initialize.apply(this, arguments);\n\n        this._watchedEntries = {};\n        this._watchedUpdatesPeriodMS = null;\n        this._watchedUpdatesTimeout = null;\n        this._watchedUpdatesLastScheduleTime = null;\n        this._watchedUpdatesLastTimestamp = null;\n\n        this.entries = new Backbone.Collection([], {\n            model: RB.ReviewRequestPage.Entry,\n        });\n    },\n\n    /**\n     * Parse the data for the page.\n     *\n     * This will take data from the server and turn it into a series of\n     * objects and attributes needed for parts of the page.\n     *\n     * Args:\n     *     rsp (object):\n     *         The incoming data provided for the page.\n     *\n     * Returns:\n     *     object:\n     *     The resulting attributes for the page.\n     */\n    parse(rsp) {\n        return _.extend({\n            updatesURL: rsp.updatesURL,\n        }, RB.ReviewablePage.prototype.parse.call(this, rsp));\n    },\n\n    /**\n     * Add an entry to the page.\n     *\n     * The entry's ``page`` attribute will be set to this page, for reference,\n     * and then the entry will be added to the ``entries`` collection.\n     *\n     * Args:\n     *     entry (RB.ReviewRequestPage.Entry):\n     *         The entry to add.\n     */\n    addEntry(entry) {\n        entry.set('page', this);\n        this.entries.add(entry);\n    },\n\n    /**\n     * Watch for updates to an entry.\n     *\n     * The entry will be checked for updates at least once every ``periodMS``\n     * milliseconds.\n     *\n     * Args:\n     *     entry (RB.ReviewRequestPage.Entry):\n     *         The entry being watched for updates.\n     *\n     *     periodMS (number):\n     *         The frequency at which the updates should be polled. Updates\n     *         will be checked at least this often.\n     */\n    watchEntryUpdates(entry, periodMS) {\n        /*\n         * If we already have a check in progress, and this new update\n         * request wants to check sooner than the current check is scheduled,\n         * then disconnect the old timer so we can reconnect it with the new\n         * delay.\n         */\n        if (this._watchedUpdatesPeriodMS === null ||\n            periodMS < this._watchedUpdatesPeriodMS) {\n            /*\n             * This is either the only update requested, or it's more frequent\n             * than other ones. Now we just need to check if we need to cancel\n             * any previous update checks that are scheduled later than the\n             * new check would be.\n             */\n            if (this._watchedUpdatesTimeout !== null &&\n                (Date.now() -\n                 this._watchedUpdatesLastScheduleTime) > periodMS) {\n                clearTimeout(this._watchedUpdatesTimeout);\n                this._watchedUpdatesTimeout = null;\n            }\n\n            this._watchedUpdatesPeriodMS = periodMS;\n        }\n\n        this._watchedEntries[entry.id] = {\n            entry: entry,\n            periodMS: periodMS,\n        };\n\n        /* We're watching new entries, so don't filter based on time. */\n        this._watchedUpdatesLastTimestamp = null;\n\n        this._scheduleCheckUpdates();\n    },\n\n    /**\n     * Stop watching for updates to an entry.\n     *\n     * Args:\n     *     entry (RB.ReviewRequestPage.Entry):\n     *         The entry being watched for updates.\n     */\n    stopWatchingEntryUpdates(entry) {\n        if (!this._watchedEntries.hasOwnProperty(entry.id)) {\n            return;\n        }\n\n        delete this._watchedEntries[entry.id];\n\n        /*\n         * We'll either be clearing this for now, or recomputing. Either way,\n         * we want this null for the next steps.\n         */\n        this._watchedUpdatesPeriodMS = null;\n\n        if (_.isEmpty(this._watchedEntries)) {\n            /*\n             * There's nothing left to watch, so cancel the timeout (if set)\n             * and clear state.\n             */\n            if (this._watchedUpdatesTimeout !== null) {\n                clearTimeout(this._watchedUpdatesTimeout);\n                this._watchedUpdatesTimeout = null;\n            }\n\n            this._watchedUpdatesLastScheduleTime = null;\n        } else {\n            /*\n             * There's still other entries being watched. We need to\n             * update state accordingly.\n             *\n             * We'll let any current timeouts continue as-is.\n             */\n            for (let key in this._watchedEntries) {\n                if (this._watchedEntries.hasOwnProperty(key)) {\n                    const periodMS = this._watchedEntries[key].periodMS;\n\n                    this._watchedUpdatesPeriodMS =\n                        (this._watchedUpdatesPeriodMS === null\n                         ? periodMS\n                         : Math.min(this._watchedUpdatesPeriodMS, periodMS));\n                }\n            }\n        }\n    },\n\n    /**\n     * Schedule the next updates check.\n     *\n     * The check will only be scheduled so long as there are still entries\n     * being watched. Any data returned in the check will trigger reloads\n     * of parts of the page.\n     */\n    _scheduleCheckUpdates() {\n        if (this._watchedUpdatesTimeout !== null ||\n            this._watchedUpdatesPeriodMS === null) {\n            return;\n        }\n\n        this._watchedUpdatesLastScheduleTime = Date.now();\n        this._watchedUpdatesTimeout = setTimeout(\n            () => {\n                this._watchedUpdatesTimeout = null;\n                this._loadUpdates({\n                    entries: _.pluck(this._watchedEntries, 'entry'),\n                    onDone: totalApplied => {\n                        if (totalApplied === 0) {\n                            /*\n                             * Apply a backoff multiplier for the next check.\n                             */\n                            this._watchedUpdatesPeriodMS = Math.round(Math.min(\n                                this.WATCH_UPDATED_POLL_CAP_MS,\n                                (this._watchedUpdatesPeriodMS *\n                                 this.WATCH_UPDATED_BACKOFF_MULTIPLIER)));\n                        }\n\n                        this._scheduleCheckUpdates();\n                    },\n                });\n            },\n            this._watchedUpdatesPeriodMS);\n    },\n\n    /**\n     * Load updates from the server.\n     *\n     * Args:\n     *     options (object, optional):\n     *         Options that control the types of updates loaded from the\n     *         server.\n     *\n     * Option Args:\n     *     entries (Array):\n     *         A list of entry models that need to be checked for updates.\n     *\n     *     onDone (function, optional):\n     *         Optional function to call after everything is loaded.\n     */\n    _loadUpdates(options={}) {\n        const updatesURL = this.get('updatesURL');\n        const allEntryIDs = {};\n        const entries = options.entries || [];\n\n        const urlQuery = [];\n\n        if (entries.length > 0) {\n            for (let i = 0; i < entries.length; i++) {\n                const entry = entries[i];\n                const typeID = entry.get('typeID');\n\n                if (!allEntryIDs.hasOwnProperty(typeID)) {\n                    allEntryIDs[typeID] = [];\n                }\n\n                allEntryIDs[typeID].push(entry.id);\n            }\n\n            const urlEntryTypeIDs = [];\n\n            for (let entryTypeID in allEntryIDs) {\n                if (allEntryIDs.hasOwnProperty(entryTypeID)) {\n                    /*\n                     * Sort the IDs numerically, so that we have a stable URL\n                     * for caching.\n                     */\n                    allEntryIDs[entryTypeID].sort((a, b) => a - b);\n\n                    const entryIDs = allEntryIDs[entryTypeID].join(',');\n                    urlEntryTypeIDs.push(`${entryTypeID}:${entryIDs}`);\n                }\n            }\n\n            urlQuery.push(`entries=${urlEntryTypeIDs.join(';')}`);\n        }\n\n        const timestamp = this._watchedUpdatesLastTimestamp;\n\n        if (timestamp !== null) {\n            urlQuery.push(`since=${timestamp.toISOString()}`);\n        }\n\n        /*\n         * Like above, sort the URL queries, so that we have a stable URL\n         * for caching.\n         */\n        urlQuery.sort();\n\n        const urlQueryStr = (urlQuery.length > 0\n                             ? `?${urlQuery.join('&')}`\n                             : '');\n\n        Backbone.sync(\n            'read',\n            this,\n            {\n                url: `${updatesURL}${urlQueryStr}`,\n                dataType: 'arraybuffer',\n                noActivityIndicator: true,\n                success: arrayBuffer => this._processUpdatesFromPayload(\n                    arrayBuffer, options.onDone),\n            });\n    },\n\n    /**\n     * Process an updates payload from the server.\n     *\n     * This will parse the payload and then update each of the entries\n     * or other parts of the UI referenced.\n     *\n     * Args:\n     *     arrayBuffer (ArrayBuffer):\n     *         The array buffer being parsed.\n     *\n     *     onDone (function, optional):\n     *         The function to call when all updates have been parsed and\n     *         applied.\n     */\n    _processUpdatesFromPayload(arrayBuffer, onDone) {\n        if (arrayBuffer.byteLength === 0) {\n            onDone(0);\n\n            return;\n        }\n\n        const dataView = new DataView(arrayBuffer);\n        const len = dataView.byteLength;\n        let pos = 0;\n        let totalUpdates = 0;\n        let totalApplied = 0;\n        let done = false;\n\n        const onUpdateLoaded = (metadata, html) => {\n            /*\n             * Based on the update, we can now start updating the UI, if\n             * we can find the matching entry or UI component.\n             */\n            if (metadata.type === 'entry') {\n                this._processEntryUpdate(metadata, html);\n            } else {\n                this._reloadFromUpdate(null, metadata, html);\n            }\n\n            if (metadata.hasOwnProperty('updatedTimestamp')) {\n                const newTimestamp =\n                    moment.utc(metadata.updatedTimestamp).toDate();\n                const lastTimestamp = this._watchedUpdatesLastTimestamp;\n\n                if (lastTimestamp === null || newTimestamp > lastTimestamp) {\n                    this._watchedUpdatesLastTimestamp = newTimestamp;\n                }\n            }\n\n            totalApplied++;\n\n            if (done && totalApplied === totalUpdates) {\n                this.trigger('updatesProcessed');\n\n                if (_.isFunction(onDone)) {\n                    onDone(totalApplied);\n                }\n            }\n        };\n\n        while (!done) {\n            const parsed = this._processUpdateFromPayload(arrayBuffer,\n                                                          dataView,\n                                                          pos);\n\n            totalUpdates++;\n            pos = parsed.pos;\n            done = (pos >= len);\n\n            parsed.load(onUpdateLoaded);\n        }\n    },\n\n    /**\n     * Process a single update from the updates payload.\n     *\n     * This will parse out the details for one update, loading in the metadata\n     * and HTML, and then apply that update.\n     *\n     * Args:\n     *     arrayBuffer (ArrayBuffer):\n     *         The array buffer being parsed.\n     *\n     *     dataView (DataView):\n     *         The data view on top of the array buffer, used to extract\n     *         information.\n     *\n     *     pos (number):\n     *         The current position within the array buffer.\n     *\n     * Returns:\n     *     object:\n     *     An object with two keys:\n     *\n     *     ``pos``:\n     *         The next position to parse.\n     *\n     *     ``load``:\n     *         A function for loading the update content. This takes a\n     *         callback function as an argument containing ``metadata`` and\n     *         ``html`` arguments.\n     */\n    _processUpdateFromPayload(arrayBuffer, dataView, pos) {\n        /* Read the length of the metadata. */\n        const metadataLen = dataView.getUint32(pos, true);\n        pos += 4;\n\n        /* Read the start position of the metadata content for later. */\n        const metadataStart = pos;\n        pos += metadataLen;\n\n        /* Read the length of the HTML content. */\n        const htmlLen = dataView.getUint32(pos, true);\n        pos += 4;\n\n        /* Read the start position of the HTML content for later. */\n        const htmlStart = pos;\n        pos += htmlLen;\n\n        return {\n            pos: pos,\n            load(cb) {\n                const metadataBlob = new Blob([\n                    arrayBuffer.slice(metadataStart,\n                                      metadataStart + metadataLen),\n                ]);\n                const htmlBlob = new Blob([\n                    arrayBuffer.slice(htmlStart, htmlStart + htmlLen),\n                ]);\n\n                RB.DataUtils.readManyBlobsAsStrings(\n                    [metadataBlob, htmlBlob],\n                    (metadata, html) => cb(JSON.parse(metadata), html));\n            },\n        };\n    },\n\n    /**\n     * Process the update to an entry.\n     *\n     * This will locate the existing entry on the page, check if it needs\n     * updating, and then update the entry's attributes and HTML.\n     *\n     * Args:\n     *     metadata (object):\n     *         The metadata for the entry update.\n     *\n     *     html (string):\n     *         The new HTML for the entry.\n     */\n    _processEntryUpdate(metadata, html) {\n        /*\n         * TODO: We'll eventually want to handle new entries we don't\n         *       know about. This would be part of a larger dynamic\n         *       page updates change.\n         */\n        const entry = this.entries.get(metadata.entryID);\n\n        if (!entry) {\n            return;\n        }\n\n        console.assert(entry.get('typeID') === metadata.entryType);\n\n        /* Only reload this entry if its updated timestamp has changed. */\n        if (entry.isUpdated(metadata)) {\n            this._reloadFromUpdate(entry, metadata, html);\n        }\n    },\n\n    /**\n     * Reload a component's attributes and HTML based on an update.\n     *\n     * This will update the attributes for a model, notifying listeners of\n     * each stage of the update so that models and views can react\n     * appropriately.\n     *\n     * If the model has ``beforeApplyUpdate`` and/or ``afterApplyUpdate``\n     * methods, they'll be called before and after any updates are made,\n     * respectively.\n     *\n     * Args:\n     *     model (Backbone.Model):\n     *         The model to update.\n     *\n     *     metadata (object):\n     *         The metadata for the update.\n     *\n     *     html (string):\n     *         The new HTML for the view.\n     */\n    _reloadFromUpdate(model, metadata, html) {\n        this.trigger(`applyingUpdate:${metadata.type}`, metadata, html);\n\n        if (model) {\n            this.trigger(`applyingUpdate:${metadata.type}:${model.id}`,\n                         metadata, html);\n\n            if (_.isFunction(model.beforeApplyUpdate)) {\n                model.beforeApplyUpdate(metadata);\n            }\n\n            /* Load any new model data, etags, or updated timestamps. */\n            model.set(model.parse(_.extend(\n                {},\n                model.attributes,\n                metadata.modelData,\n                {\n                    etag: metadata.etag,\n                    updatedTimestamp: metadata.updatedTimestamp,\n                })));\n\n            this.trigger(`appliedModelUpdate:${metadata.type}:${model.id}`,\n                         metadata, html);\n\n            if (_.isFunction(model.afterApplyUpdate)) {\n                model.afterApplyUpdate(metadata);\n            }\n\n            this.trigger(`appliedUpdate:${metadata.type}:${model.id}`,\n                         metadata, html);\n        }\n\n        this.trigger(`appliedUpdate:${metadata.type}`, metadata, html);\n    },\n});\n"],"mappings":"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","ignoreList":[]}