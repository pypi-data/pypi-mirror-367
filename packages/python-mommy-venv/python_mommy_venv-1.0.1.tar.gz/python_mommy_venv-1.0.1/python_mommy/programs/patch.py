from typing import Optional
from pathlib import Path
import stat
import logging
import subprocess
import sys


from ..utils import MOMMY, find_venv_dir


mommy_logger = logging.getLogger("mommy")
serious_logger = logging.getLogger("serious")


WRAPPER_TEMPLATE = """#!{inner_bin}
# -*- coding: utf-8 -*-

import sys, subprocess
from python_mommy import get_response


INTERPRETER = "{inner_bin}"
result = subprocess.run([INTERPRETER] + sys.argv[1:])
code = result.returncode

print()
print(get_response(code))
exit(code=code)
"""


PIP_HOOK = """# GENERATED BY MOMMY
    code = main()

    from pathlib import Path

    bin_path = Path(".venv", "bin")

    python_interpreter_wrappers = []
    for path in bin_path.iterdir():
        if path.is_symlink() and path.name.startswith("inner_"):
            python_interpreter_wrappers.append(path.name.replace("inner_", "", 1))

    for path in bin_path.iterdir():
        if path.is_symlink():
            continue
        if path.name in python_interpreter_wrappers:
            continue

        text: str
        with path.open("r") as f:
            text = f.read()

        first_line = text.split("\\n")[0]
        if not ("inner_" in first_line and first_line.startswith("#!")):
            continue

        print(f"mommifying " + str(path))

        text = text.replace("inner_", "", 1)
        with path.open("w") as f:
            f.write(text)

    sys.exit(code)"""


def _wrap_interpreter(path: Path, symlink_target: Path):
    mommy_logger.info("%s found a symlink to an interpreter~ %s", MOMMY.ROLE, str(path))
    serious_logger.info("interpreter symlink found at %s", str(path))

    inner_symlink = path.parent / ("inner_" + path.name)

    if inner_symlink.exists():
        raise Exception("inner symlink somehow already exists. This shouldn't happen because of prior checks")

    mommy_logger.info("%s shows %s %s where the interpreter is: %s -> %s", MOMMY.ROLE, MOMMY.PRONOUN, MOMMY.YOU, inner_symlink, symlink_target)
    serious_logger.info("creating symlink: %s -> %s", inner_symlink, symlink_target)
    inner_symlink.symlink_to(symlink_target)

    # remove original symlink
    mommy_logger.info("%s deletes the original interpreter~ %s", MOMMY.ROLE, path)
    serious_logger.info("deleting original symlink %s", path)
    path.unlink()

    # creating the wrapper string
    mommy_logger.info("%s writes %s wrapper script as %s", MOMMY.ROLE, MOMMY.PRONOUN, path)
    serious_logger.info("writing wrapper script at %s", path)
    with path.open("w") as f:
        f.write(WRAPPER_TEMPLATE.format(inner_bin=str(inner_symlink)))
    serious_logger.info("making wrapper script executable")
    path.chmod(path.stat().st_mode | stat.S_IEXEC)


def _install_pip_hook(path: Path):
    text: str
    with path.open("r") as f:
        text = f.read()

    if "# GENERATED BY MOMMY" in text:
        mommy_logger.info("%s already watches %s", MOMMY.ROLE, str(path))
        serious_logger.info("pip hook already installed at %s", str(path))
        return

    mommy_logger.info("%s needs to watch %s %s's pip~ %s", MOMMY.PRONOUN, MOMMY.YOU, MOMMY.ROLE, str(path))
    serious_logger.info("installing pip hook at %s", str(path))

    text = text.replace("sys.exit(main())", PIP_HOOK, 1)
    with path.open("w") as f:
        f.write(text)


def mommify_patch_venv(venv_dir: Optional[Path] = None):
    venv_dir = find_venv_dir(venv_dir=venv_dir)
    if venv_dir is None:
        mommy_logger.error("%s couldn't find a venv directory to mess up~", MOMMY.ROLE)
        serious_logger.error("couldn't find a venv directory")
        exit(1)
    bin_path = Path(sys.prefix, "bin").resolve()

    mommy_logger.info("%s looks in %s to mess %s %s system up~ <33", MOMMY.ROLE, MOMMY.PRONOUN, MOMMY.YOU, str(bin_path))
    serious_logger.info("scanning binary directory of venv at %s", str(bin_path))

    # resolving the symlinks before making edits to anything because else it will mess up the resolving
    # and link to the wrapper instead of the original script
    resolved_symlinks = {
        path.name: path.resolve()
        for path in bin_path.iterdir()
        if path.is_symlink()
    }
    serious_logger.debug("resolved symlinks:\n%s", "\n".join(
        f"\t{name} => {str(target)}"
        for name, target in resolved_symlinks.items()
    ))

    for path in list(bin_path.iterdir()):
        name = path.name

        if path.is_symlink():
            # could be python interpreter
            # check for both just to be more expressive
            if name.startswith("inner_"):
                continue
            
            RANDOM_RETURNCODE = 161
            if subprocess.run([str(path), '-c', f'exit({RANDOM_RETURNCODE})']).returncode != RANDOM_RETURNCODE:
                continue

            _wrap_interpreter(path, resolved_symlinks[path.name])

        else:
            # could be pip
            if not name.startswith("pip"):
                continue

            _install_pip_hook(path)
