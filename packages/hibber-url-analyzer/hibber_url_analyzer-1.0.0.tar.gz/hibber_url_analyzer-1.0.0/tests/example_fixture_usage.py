"""
Example test file demonstrating the use of enhanced test fixtures.

This file shows how to use the new base test classes and utility functions
to reduce code duplication and improve test maintainability.
"""

import unittest
from tests import (
    BaseURLAnalyzerTest,
    BaseSecurityTest,
    BaseIntegrationTest,
    generate_malicious_inputs,
    create_performance_test_urls,
    create_test_report_data
)


class ExampleURLAnalyzerTest(BaseURLAnalyzerTest):
    """
    Example test class showing how to use BaseURLAnalyzerTest.
    
    This class inherits all the common setup from BaseURLAnalyzerTest:
    - Configuration loading and pattern compilation
    - Temporary file management
    - Common test data
    - Cleanup handling
    """
    
    def test_configuration_loaded(self):
        """Test that configuration is properly loaded."""
        # Configuration is automatically loaded by BaseURLAnalyzerTest
        self.assertIsNotNone(self.config)
        self.assertIn('sensitive_patterns', self.config)
        self.assertIn('ugc_patterns', self.config)
    
    def test_test_data_available(self):
        """Test that test data is available."""
        # Test URLs are automatically created by BaseURLAnalyzerTest
        self.assertIsNotNone(self.test_urls)
        self.assertGreater(len(self.test_urls), 0)
        
        # Test CSV file is automatically created
        import os
        self.assertTrue(os.path.exists(self.test_csv_path))
    
    def test_patterns_compiled(self):
        """Test that patterns are compiled if classification module is available."""
        # Patterns are automatically compiled by BaseURLAnalyzerTest
        # This will be None if the classification module is not available
        if self.patterns is not None:
            self.assertIsInstance(self.patterns, dict)
    
    def test_temporary_files_created(self):
        """Test that temporary files are properly created."""
        import os
        
        # All these files are automatically created by BaseURLAnalyzerTest
        self.assertTrue(os.path.exists(self.config_path))
        self.assertTrue(os.path.exists(self.test_csv_path))
        self.assertTrue(os.path.exists(self.cache_path))
        self.assertTrue(os.path.exists(self.temp_dir))


class ExampleSecurityTest(BaseSecurityTest):
    """
    Example test class showing how to use BaseSecurityTest.
    
    This class inherits all the security-specific setup:
    - Malicious input patterns
    - Security test utilities
    - Temporary file management
    - Common security test scenarios
    """
    
    def test_malicious_inputs_generated(self):
        """Test that malicious inputs are properly generated."""
        # Malicious inputs are automatically generated by BaseSecurityTest
        self.assertIsNotNone(self.malicious_inputs)
        
        # Check that all expected categories are present
        expected_categories = [
            'sql_injection', 'xss', 'path_traversal', 
            'command_injection', 'large_input', 'special_chars',
            'protocol_attacks'
        ]
        
        for category in expected_categories:
            self.assertIn(category, self.malicious_inputs)
            self.assertGreater(len(self.malicious_inputs[category]), 0)
    
    def test_security_test_environment(self):
        """Test that security test environment is properly set up."""
        import os
        
        # All these are automatically created by BaseSecurityTest
        self.assertTrue(os.path.exists(self.temp_dir))
        self.assertTrue(os.path.exists(self.config_path))
        self.assertTrue(os.path.exists(self.cache_path))
        self.assertTrue(os.path.exists(self.input_file))
        self.assertTrue(os.path.exists(self.output_dir))
    
    def test_sql_injection_inputs(self):
        """Test SQL injection inputs are available."""
        sql_inputs = self.malicious_inputs['sql_injection']
        
        # Check that we have various SQL injection patterns
        self.assertGreater(len(sql_inputs), 0)
        
        # Check for common SQL injection patterns
        has_or_pattern = any("OR 1=1" in input_str for input_str in sql_inputs)
        has_drop_pattern = any("DROP TABLE" in input_str for input_str in sql_inputs)
        has_union_pattern = any("UNION SELECT" in input_str for input_str in sql_inputs)
        
        self.assertTrue(has_or_pattern)
        self.assertTrue(has_drop_pattern)
        self.assertTrue(has_union_pattern)


class ExampleIntegrationTest(BaseIntegrationTest):
    """
    Example test class showing how to use BaseIntegrationTest.
    
    This class inherits comprehensive integration test setup:
    - Multiple temporary files and directories
    - Mock services and APIs
    - Integration test data
    - Service lifecycle management
    """
    
    def test_integration_environment_setup(self):
        """Test that integration test environment is properly set up."""
        import os
        
        # All these are automatically created by BaseIntegrationTest
        self.assertTrue(os.path.exists(self.temp_dir))
        self.assertTrue(os.path.exists(self.config_path))
        self.assertTrue(os.path.exists(self.cache_path))
        self.assertTrue(os.path.exists(self.input_file))
        self.assertTrue(os.path.exists(self.output_dir))
        self.assertTrue(os.path.exists(self.reports_dir))
    
    def test_mock_services_available(self):
        """Test that mock services are properly initialized."""
        # Mock services are automatically created by BaseIntegrationTest
        self.assertIsNotNone(self.mock_api)
        self.assertIsNotNone(self.mock_cache)
        self.assertIsNotNone(self.mock_filesystem)
    
    def test_integration_test_data(self):
        """Test that integration test data is available."""
        # Test data is automatically created by BaseIntegrationTest
        self.assertIsNotNone(self.test_data)
        self.assertGreater(len(self.test_data), 0)
        
        # Check data structure
        for item in self.test_data:
            self.assertIn('url', item)
            self.assertIn('category', item)
            self.assertIn('is_sensitive', item)
    
    def test_mock_api_functionality(self):
        """Test that mock API works correctly."""
        # Test the mock API
        response = self.mock_api.call('test_endpoint', {'key': 'value'})
        self.assertIsNotNone(response)
    
    def test_mock_cache_functionality(self):
        """Test that mock cache works correctly."""
        # Test the mock cache
        self.mock_cache.set('test_key', 'test_value')
        value = self.mock_cache.get('test_key')
        self.assertEqual(value, 'test_value')


class ExampleUtilityFunctionsTest(unittest.TestCase):
    """
    Example test class showing how to use utility functions.
    
    This demonstrates the standalone utility functions that can be used
    in any test without inheriting from base classes.
    """
    
    def test_malicious_inputs_generation(self):
        """Test the generate_malicious_inputs utility function."""
        malicious_inputs = generate_malicious_inputs()
        
        self.assertIsInstance(malicious_inputs, dict)
        self.assertIn('sql_injection', malicious_inputs)
        self.assertIn('xss', malicious_inputs)
        self.assertIn('path_traversal', malicious_inputs)
    
    def test_performance_test_urls_generation(self):
        """Test the create_performance_test_urls utility function."""
        # Generate a small set for testing
        urls = create_performance_test_urls(count=10)
        
        self.assertEqual(len(urls), 10)
        
        # Check that all URLs are valid
        for url in urls:
            self.assertTrue(url.startswith('https://'))
            self.assertIn('.', url)  # Should have domain extension
    
    def test_report_data_generation(self):
        """Test the create_test_report_data utility function."""
        report_data = create_test_report_data()
        
        self.assertIsInstance(report_data, dict)
        self.assertIn('summary', report_data)
        self.assertIn('analysis_results', report_data)
        self.assertIn('metadata', report_data)
        
        # Check summary structure
        summary = report_data['summary']
        self.assertIn('total_urls', summary)
        self.assertIn('sensitive_urls', summary)
        self.assertIn('categories', summary)


if __name__ == '__main__':
    # Run the example tests
    unittest.main()