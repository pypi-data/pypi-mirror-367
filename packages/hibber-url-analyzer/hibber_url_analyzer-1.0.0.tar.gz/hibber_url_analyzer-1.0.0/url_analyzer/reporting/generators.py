"""
Report Generator Module

This module provides factory pattern implementations for report generation.
It defines an abstract ReportGenerator interface and concrete implementations
for different report formats.
"""

import os
import pandas as pd
from abc import ABC, abstractmethod
from typing import Dict, Any, Optional, List, Type

from url_analyzer.utils.logging import get_logger

# Create logger
logger = get_logger(__name__)


class ReportGenerator(ABC):
    """
    Abstract base class for report generators.
    
    This class defines the interface that all report generators must implement.
    """
    
    @abstractmethod
    def generate_report(self, df: pd.DataFrame, output_path: str, stats: Dict[str, Any]) -> str:
        """
        Generate a report from the provided data.
        
        Args:
            df: DataFrame containing URL data
            output_path: Path where to save the report
            stats: Dictionary of statistics for the report
            
        Returns:
            Path to the generated report
        """
        pass
    
    @abstractmethod
    def get_format(self) -> str:
        """
        Get the format of reports generated by this generator.
        
        Returns:
            Report format (e.g., 'html', 'csv', 'excel')
        """
        pass


class HTMLReportGenerator(ReportGenerator):
    """
    HTML report generator.
    
    This generator creates interactive HTML reports with charts and tables.
    """
    
    def __init__(self, template_name: Optional[str] = None):
        """
        Initialize the HTML report generator.
        
        Args:
            template_name: Optional name of the template to use
        """
        self.template_name = template_name
    
    def generate_report(self, df: pd.DataFrame, output_path: str, stats: Dict[str, Any]) -> str:
        """
        Generate an HTML report from the provided data.
        
        Args:
            df: DataFrame containing URL data
            output_path: Path where to save the HTML report
            stats: Dictionary of statistics for the report
            
        Returns:
            Path to the generated HTML report
        """
        from url_analyzer.reporting.html_report import generate_report_from_template, generate_html_report
        
        # Ensure the output path has the correct extension
        if not output_path.lower().endswith('.html'):
            output_path = f"{os.path.splitext(output_path)[0]}.html"
        
        # Generate the report using the appropriate function
        if self.template_name:
            logger.info(f"Generating HTML report using template: {self.template_name}")
            return generate_report_from_template(df, output_path, stats, self.template_name)
        else:
            logger.info("Generating HTML report using default template")
            return generate_html_report(df, output_path, stats)
    
    def get_format(self) -> str:
        """
        Get the format of reports generated by this generator.
        
        Returns:
            Report format ('html')
        """
        return 'html'


class CSVReportGenerator(ReportGenerator):
    """
    CSV report generator.
    
    This generator creates CSV reports with the processed data.
    """
    
    def generate_report(self, df: pd.DataFrame, output_path: str, stats: Dict[str, Any]) -> str:
        """
        Generate a CSV report from the provided data.
        
        Args:
            df: DataFrame containing URL data
            output_path: Path where to save the CSV report
            stats: Dictionary of statistics for the report
            
        Returns:
            Path to the generated CSV report
        """
        # Ensure the output path has the correct extension
        if not output_path.lower().endswith('.csv'):
            output_path = f"{os.path.splitext(output_path)[0]}.csv"
        
        # Create the directory if it doesn't exist
        os.makedirs(os.path.dirname(os.path.abspath(output_path)), exist_ok=True)
        
        # Save the DataFrame to CSV
        df.to_csv(output_path, index=False)
        
        # Also save the stats to a separate file
        stats_path = f"{os.path.splitext(output_path)[0]}_stats.csv"
        pd.DataFrame([stats]).to_csv(stats_path, index=False)
        
        logger.info(f"Generated CSV report: {output_path}")
        return output_path
    
    def get_format(self) -> str:
        """
        Get the format of reports generated by this generator.
        
        Returns:
            Report format ('csv')
        """
        return 'csv'


class ExcelReportGenerator(ReportGenerator):
    """
    Excel report generator.
    
    This generator creates Excel reports with multiple sheets for data and stats.
    """
    
    def generate_report(self, df: pd.DataFrame, output_path: str, stats: Dict[str, Any]) -> str:
        """
        Generate an Excel report from the provided data.
        
        Args:
            df: DataFrame containing URL data
            output_path: Path where to save the Excel report
            stats: Dictionary of statistics for the report
            
        Returns:
            Path to the generated Excel report
        """
        try:
            import openpyxl
        except ImportError:
            logger.warning("openpyxl not installed. Falling back to CSV report.")
            return CSVReportGenerator().generate_report(df, output_path, stats)
        
        # Ensure the output path has the correct extension
        if not output_path.lower().endswith(('.xlsx', '.xls')):
            output_path = f"{os.path.splitext(output_path)[0]}.xlsx"
        
        # Create the directory if it doesn't exist
        os.makedirs(os.path.dirname(os.path.abspath(output_path)), exist_ok=True)
        
        # Create a writer to save the Excel file
        with pd.ExcelWriter(output_path, engine='openpyxl') as writer:
            # Write the data to the 'Data' sheet
            df.to_excel(writer, sheet_name='Data', index=False)
            
            # Create a DataFrame from the stats and write it to the 'Stats' sheet
            stats_df = pd.DataFrame([stats])
            stats_df.to_excel(writer, sheet_name='Stats', index=False)
            
            # Create a sheet for category counts if available
            if 'category_counts' in stats:
                category_df = pd.DataFrame(list(stats['category_counts'].items()), 
                                          columns=['Category', 'Count'])
                category_df.to_excel(writer, sheet_name='Categories', index=False)
        
        logger.info(f"Generated Excel report: {output_path}")
        return output_path
    
    def get_format(self) -> str:
        """
        Get the format of reports generated by this generator.
        
        Returns:
            Report format ('excel')
        """
        return 'excel'


class JSONReportGenerator(ReportGenerator):
    """
    JSON report generator.
    
    This generator creates JSON reports with the processed data and stats.
    """
    
    def generate_report(self, df: pd.DataFrame, output_path: str, stats: Dict[str, Any]) -> str:
        """
        Generate a JSON report from the provided data.
        
        Args:
            df: DataFrame containing URL data
            output_path: Path where to save the JSON report
            stats: Dictionary of statistics for the report
            
        Returns:
            Path to the generated JSON report
        """
        # Ensure the output path has the correct extension
        if not output_path.lower().endswith('.json'):
            output_path = f"{os.path.splitext(output_path)[0]}.json"
        
        # Create the directory if it doesn't exist
        os.makedirs(os.path.dirname(os.path.abspath(output_path)), exist_ok=True)
        
        # Convert DataFrame to JSON and save
        result = {
            'data': df.to_dict(orient='records'),
            'stats': stats
        }
        
        import json
        with open(output_path, 'w', encoding='utf-8') as f:
            json.dump(result, f, indent=2)
        
        logger.info(f"Generated JSON report: {output_path}")
        return output_path
    
    def get_format(self) -> str:
        """
        Get the format of reports generated by this generator.
        
        Returns:
            Report format ('json')
        """
        return 'json'


class ReportGeneratorFactory:
    """
    Factory class for creating report generators.
    
    This class provides methods for creating appropriate report generators
    based on format or file extension.
    """
    
    # Dictionary to store built-in and plugin-based generators
    _generators = {
        'html': HTMLReportGenerator,
        'csv': CSVReportGenerator,
        'excel': ExcelReportGenerator,
        'json': JSONReportGenerator
    }
    
    # Dictionary to store file extension to format mappings
    _extension_mappings = {
        '.html': 'html',
        '.csv': 'csv',
        '.xlsx': 'excel',
        '.xls': 'excel',
        '.json': 'json'
    }
    
    @classmethod
    def register_generator(cls, format_name: str, generator_class: Type[ReportGenerator]) -> None:
        """
        Register a new report generator for a specific format.
        
        Args:
            format_name: Format name (e.g., 'html', 'csv', 'custom')
            generator_class: ReportGenerator class to register
            
        Raises:
            ValueError: If the format is already registered
        """
        format_name = format_name.lower()
        
        if format_name in cls._generators:
            raise ValueError(f"Format '{format_name}' is already registered")
        
        cls._generators[format_name] = generator_class
        logger.info(f"Registered report generator for format: {format_name}")
    
    @classmethod
    def register_extension_mapping(cls, extension: str, format_name: str) -> None:
        """
        Register a file extension to format mapping.
        
        Args:
            extension: File extension (e.g., '.html', '.csv', '.custom')
            format_name: Format name (e.g., 'html', 'csv', 'custom')
            
        Raises:
            ValueError: If the extension is already registered
        """
        extension = extension.lower()
        format_name = format_name.lower()
        
        if extension in cls._extension_mappings:
            raise ValueError(f"Extension '{extension}' is already registered")
        
        if format_name not in cls._generators:
            raise ValueError(f"Format '{format_name}' is not registered")
        
        cls._extension_mappings[extension] = format_name
        logger.info(f"Registered extension mapping: {extension} -> {format_name}")
    
    @classmethod
    def initialize_with_plugins(cls, plugin_registry: Any) -> None:
        """
        Initialize the factory with plugin-based generators from a plugin registry.
        
        Args:
            plugin_registry: Plugin registry containing report generator plugins
        """
        try:
            # Import the adapter module
            from url_analyzer.plugins.adapters import get_plugin_report_generators
            
            # Get plugin-based generators
            plugin_generators = get_plugin_report_generators(plugin_registry)
            
            # Register each plugin-based generator
            for generator in plugin_generators:
                format_name = generator.get_format()
                cls._generators[format_name] = generator.__class__
                logger.info(f"Registered plugin-based generator for format: {format_name}")
        except ImportError:
            logger.warning("Plugin system not available, using only built-in generators")
        except Exception as e:
            logger.error(f"Error initializing with plugins: {e}")
    
    @classmethod
    def create_generator(cls, format_name: str, template_name: Optional[str] = None) -> ReportGenerator:
        """
        Create a report generator for the specified format.
        
        Args:
            format_name: Format of the report ('html', 'csv', 'excel', 'json', etc.)
            template_name: Optional name of the template to use (for HTML reports)
            
        Returns:
            ReportGenerator instance
            
        Raises:
            ValueError: If the format is not supported
        """
        format_name = format_name.lower()
        
        if format_name not in cls._generators:
            raise ValueError(f"Unsupported report format: {format_name}")
        
        generator_class = cls._generators[format_name]
        
        # Handle special case for HTML generator with template
        if format_name == 'html' and template_name is not None:
            return generator_class(template_name)
        
        return generator_class()
    
    @classmethod
    def from_file_extension(cls, file_path: str) -> ReportGenerator:
        """
        Create a report generator based on the file extension.
        
        Args:
            file_path: Path to the output file
            
        Returns:
            ReportGenerator instance
            
        Raises:
            ValueError: If the file extension is not supported
        """
        ext = os.path.splitext(file_path)[1].lower()
        
        if ext in cls._extension_mappings:
            format_name = cls._extension_mappings[ext]
            return cls.create_generator(format_name)
        else:
            # Default to HTML if extension is not recognized
            logger.warning(f"Unrecognized file extension: {ext}. Using HTML report generator.")
            return cls.create_generator('html')
    
    @classmethod
    def list_available_formats(cls) -> List[str]:
        """
        List all available report formats.
        
        Returns:
            List of supported report formats
        """
        return list(cls._generators.keys())