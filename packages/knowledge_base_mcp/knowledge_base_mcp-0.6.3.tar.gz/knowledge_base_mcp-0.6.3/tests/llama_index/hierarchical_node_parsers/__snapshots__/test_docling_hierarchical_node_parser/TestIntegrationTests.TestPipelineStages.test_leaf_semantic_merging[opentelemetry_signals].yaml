- node_id: '0'
  node_depth: 0
  node_type: Node
  content_length: 5664
  content: "# Metrics\n\nA measurement captured at runtime.\n\nA metric is a measurement\
    \ of a service captured at runtime. The moment\nof capturing a measurements is\
    \ known as a metric event, which consists not\nonly of the measurement itself,\
    \ but also the time at which it was captured and\nassociated metadata.\n\nApplication\
    \ and request metrics are important indicators of availability and\nperformance.\
    \ Custom metrics can provide insights into how availability\nindicators impact\
    \ user experience or the business. Collected data can be used to\nalert of an\
    \ outage or trigger scheduling decisions to scale up a deployment\nautomatically\
    \ upon high demand.\n\nTo understand how metrics in OpenTelemetry works, let\u2019\
    s look at a list of\ncomponents that will play a part in instrumenting our code.\n\
    \n## Meter Provider\n\nA Meter Provider (sometimes called MeterProvider) is a\
    \ factory for Meters.\nIn most applications, a Meter Provider is initialized once\
    \ and its lifecycle\nmatches the application\u2019s lifecycle. Meter Provider\
    \ initializa..."
  metadata:
    docling_label: title
    docling_ref: '#/texts/0'
    headings:
    - '# Metrics'
  relationships:
    children:
    - '1'
    - '2'
    - '3'
    - '7'
    - '10'
    - '11'
- node_id: '1'
  node_depth: 1
  node_type: Node
  content_length: 765
  content: "# Metrics\n\nA measurement captured at runtime.\n\nA metric is a measurement\
    \ of a service captured at runtime. The moment\nof capturing a measurements is\
    \ known as a metric event, which consists not\nonly of the measurement itself,\
    \ but also the time at which it was captured and\nassociated metadata.\n\nApplication\
    \ and request metrics are important indicators of availability and\nperformance.\
    \ Custom metrics can provide insights into how availability\nindicators impact\
    \ user experience or the business. Collected data can be used to\nalert of an\
    \ outage or trigger scheduling decisions to scale up a deployment\nautomatically\
    \ upon high demand.\n\nTo understand how metrics in OpenTelemetry works, let\u2019\
    s look at a list of\ncomponents that will play a part in instrumenting our code."
  metadata:
    docling_label: title
    docling_ref: '#/texts/0'
    headings:
    - '# Metrics'
  relationships:
    next: '2'
    parent: '0'
- node_id: '2'
  node_depth: 1
  node_type: Node
  content_length: 793
  content: "## Meter Provider\n\nA Meter Provider (sometimes called MeterProvider)\
    \ is a factory for Meters.\nIn most applications, a Meter Provider is initialized\
    \ once and its lifecycle\nmatches the application\u2019s lifecycle. Meter Provider\
    \ initialization also includes\nResource and Exporter initialization. It is typically\
    \ the first step in metering\nwith OpenTelemetry. In some language SDKs, a global\
    \ Meter Provider is already\ninitialized for you.\n\n## Meter\n\nA Meter creates\
    \ metric instruments, capturing\nmeasurements about a service at runtime. Meters\
    \ are created from Meter\nProviders.\n\n## Metric Exporter\n\nMetric Exporters\
    \ send metric data to a consumer. This consumer can be standard\noutput for debugging\
    \ during development, the OpenTelemetry Collector, or any\nopen source or vendor\
    \ backend of your choice."
  metadata:
    docling_label: section_header
    docling_ref: '#/texts/5'
    headings:
    - '# Metrics'
    - '## Meter Provider'
  relationships:
    next: '3'
    parent: '0'
    previous: '1'
- node_id: '3'
  node_depth: 1
  node_type: Node
  content_length: 1740
  content: "## Metric Instruments\n\nIn OpenTelemetry measurements are captured by\
    \ metric instruments. A metric\ninstrument is defined by:\n\n- Name\n- Kind\n\
    - Unit (optional)\n- Description (optional)\n\nThe name, unit, and description\
    \ are chosen by the developer or defined via\nsemantic conventions for common\
    \ ones\nlike request and process metrics.\n\nThe instrument kind is one of the\
    \ following:\n\n- Counter: A value that accumulates over time \u2013 you can think\
    \ of this like\nan odometer on a car; it only ever goes up.\n- Asynchronous Counter:\
    \ Same as the Counter, but is collected once for\neach export. Could be used if\
    \ you don\u2019t have access to the continuous\nincrements, but only to the aggregated\
    \ value.\n- UpDownCounter: A value that accumulates over time, but can also go\
    \ down\nagain. An example could be a queue length, it will increase and decrease\
    \ with\nthe number of work items in the queue.\n- Asynchronous UpDownCounter:\
    \ Same as the UpDownCounter, but is\ncollected once for each export. Could be\
    \ used if you don\u2019t have..."
  metadata:
    docling_label: section_header
    docling_ref: '#/texts/11'
    headings:
    - '# Metrics'
    - '## Metric Instruments'
  relationships:
    children:
    - '4'
    - '5'
    - '6'
    next: '7'
    parent: '0'
    previous: '2'
- node_id: '4'
  node_depth: 2
  node_type: Node
  content_length: 374
  content: |-
    ## Metric Instruments

    In OpenTelemetry measurements are captured by metric instruments. A metric
    instrument is defined by:

    - Name
    - Kind
    - Unit (optional)
    - Description (optional)

    The name, unit, and description are chosen by the developer or defined via
    semantic conventions for common ones
    like request and process metrics.

    The instrument kind is one of the following:
  metadata:
    docling_label: section_header
    docling_ref: '#/texts/11'
    headings:
    - '# Metrics'
    - '## Metric Instruments'
  relationships:
    next: '5'
    parent: '3'
- node_id: '5'
  node_depth: 2
  node_type: Node
  content_length: 1230
  content: "- Counter: A value that accumulates over time \u2013 you can think of\
    \ this like\nan odometer on a car; it only ever goes up.\n- Asynchronous Counter:\
    \ Same as the Counter, but is collected once for\neach export. Could be used if\
    \ you don\u2019t have access to the continuous\nincrements, but only to the aggregated\
    \ value.\n- UpDownCounter: A value that accumulates over time, but can also go\
    \ down\nagain. An example could be a queue length, it will increase and decrease\
    \ with\nthe number of work items in the queue.\n- Asynchronous UpDownCounter:\
    \ Same as the UpDownCounter, but is\ncollected once for each export. Could be\
    \ used if you don\u2019t have access to the\ncontinuous changes, but only to the\
    \ aggregated value (e.g., current queue\nsize).\n- Gauge: Measures a current value\
    \ at the time it is read. An example would\nbe the fuel gauge in a vehicle. Gauges\
    \ are synchronous.\n- Asynchronous Gauge: Same as the Gauge, but is collected\
    \ once for each\nexport. Could be used if you don\u2019t have access to the continuous\
    \ changes, but..."
  metadata:
    docling_label: list
    docling_ref: '#/groups/1'
    headings:
    - '# Metrics'
    - '## Metric Instruments'
  relationships:
    next: '6'
    parent: '3'
    previous: '4'
- node_id: '6'
  node_depth: 2
  node_type: Node
  content_length: 132
  content: |-
    For more on synchronous and asynchronous instruments, and which kind is best
    suited for your use case, see
    Supplementary Guidelines.
  metadata:
    docling_label: text
    docling_ref: '#/texts/26'
    headings:
    - '# Metrics'
    - '## Metric Instruments'
  relationships:
    parent: '3'
    previous: '5'
- node_id: '7'
  node_depth: 1
  node_type: Node
  content_length: 1234
  content: |-
    ## Aggregation

    In addition to the metric instruments, the concept of aggregations is an
    important one to understand. An aggregation is a technique whereby a large
    number of measurements are combined into either exact or estimated statistics
    about metric events that took place during a time window. The OTLP protocol
    transports such aggregated metrics. The OpenTelemetry API provides a default
    aggregation for each instrument which can be overridden using the Views. The
    OpenTelemetry project aims to provide default aggregations that are supported by
    visualizers and telemetry backends.

    Unlike request tracing, which is intended to capture request
    lifecycles and provide context to the individual pieces of a request, metrics
    are intended to provide statistical information in aggregate. Some examples of
    use cases for metrics include:

    - Reporting the total number of bytes read by a service, per protocol type.
    - Reporting the total number of bytes read and the bytes per request.
    - Reporting th...
  metadata:
    docling_label: section_header
    docling_ref: '#/texts/27'
    headings:
    - '# Metrics'
    - '## Aggregation'
  relationships:
    children:
    - '8'
    - '9'
    next: '10'
    parent: '0'
    previous: '3'
- node_id: '8'
  node_depth: 2
  node_type: Node
  content_length: 838
  content: |-
    ## Aggregation

    In addition to the metric instruments, the concept of aggregations is an
    important one to understand. An aggregation is a technique whereby a large
    number of measurements are combined into either exact or estimated statistics
    about metric events that took place during a time window. The OTLP protocol
    transports such aggregated metrics. The OpenTelemetry API provides a default
    aggregation for each instrument which can be overridden using the Views. The
    OpenTelemetry project aims to provide default aggregations that are supported by
    visualizers and telemetry backends.

    Unlike request tracing, which is intended to capture request
    lifecycles and provide context to the individual pieces of a request, metrics
    are intended to provide statistical information in aggregate. Some examples of
    use cases for metrics include:
  metadata:
    docling_label: section_header
    docling_ref: '#/texts/27'
    headings:
    - '# Metrics'
    - '## Aggregation'
  relationships:
    next: '9'
    parent: '7'
- node_id: '9'
  node_depth: 2
  node_type: Node
  content_length: 394
  content: |-
    - Reporting the total number of bytes read by a service, per protocol type.
    - Reporting the total number of bytes read and the bytes per request.
    - Reporting the duration of a system call.
    - Reporting request sizes in order to determine a trend.
    - Reporting CPU or memory usage of a process.
    - Reporting average balance values from an account.
    - Reporting current active requests being handled.
  metadata:
    docling_label: list
    docling_ref: '#/groups/2'
    headings:
    - '# Metrics'
    - '## Aggregation'
  relationships:
    parent: '7'
    previous: '8'
- node_id: '10'
  node_depth: 1
  node_type: Node
  content_length: 516
  content: |-
    ## Views

    A view provides SDK users with the flexibility to customize the metrics output
    by the SDK. You can customize which metric instruments are to be processed or
    ignored. You can also customize aggregation and what attributes you want to
    report on metrics.

    ## Specification

    To learn more about metrics in OpenTelemetry, see the
    metrics specification.

    ## Feedback

    Was this page helpful?

    Thank you. Your feedback is appreciated!

    Please let us know how we can improve this page. Your feedback is appreciated!
  metadata:
    docling_label: section_header
    docling_ref: '#/texts/37'
    headings:
    - '# Metrics'
    - '## Views'
  relationships:
    next: '11'
    parent: '0'
    previous: '7'
- node_id: '11'
  node_depth: 1
  node_type: Node
  content_length: 606
  content: |-
    ## Language Support

    Metrics are a stable signal
    in the OpenTelemetry specification. For the individual language specific
    implementations of the Metrics API & SDK, the status is as follows:

    | Language      | Metrics     |
    |---------------|-------------|
    | C++           | Stable      |
    | C#/.NET       | Stable      |
    | Erlang/Elixir | Development |
    | Go            | Stable      |
    | Java          | Stable      |
    | JavaScript    | Stable      |
    | PHP           | Stable      |
    | Python        | Stable      |
    | Ruby          | Development |
    | Rust          | Beta        |
    | Swift         | Development |
  metadata:
    docling_label: section_header
    docling_ref: '#/texts/39'
    headings:
    - '# Metrics'
    - '## Language Support'
  relationships:
    children:
    - '12'
    parent: '0'
    previous: '10'
- node_id: '12'
  node_depth: 2
  node_type: Node
  content_length: 606
  content: |-
    ## Language Support

    Metrics are a stable signal
    in the OpenTelemetry specification. For the individual language specific
    implementations of the Metrics API & SDK, the status is as follows:

    | Language      | Metrics     |
    |---------------|-------------|
    | C++           | Stable      |
    | C#/.NET       | Stable      |
    | Erlang/Elixir | Development |
    | Go            | Stable      |
    | Java          | Stable      |
    | JavaScript    | Stable      |
    | PHP           | Stable      |
    | Python        | Stable      |
    | Ruby          | Development |
    | Rust          | Beta        |
    | Swift         | Development |
  metadata:
    docling_label: section_header
    docling_ref: '#/texts/39'
    headings:
    - '# Metrics'
    - '## Language Support'
  relationships:
    parent: '11'
