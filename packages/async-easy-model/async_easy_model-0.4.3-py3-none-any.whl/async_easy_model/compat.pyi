"""
Type stubs for the SQLAlchemy/SQLModel compatibility layer.
This helps IDEs provide better autocompletion and type checking.
"""

from typing import Type, TypeVar, Optional, Any, List, Dict, Union, Generic, overload, Literal
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.orm import Query
from sqlalchemy import select as sa_select, update as sa_update, delete as sa_delete
from sqlmodel import SQLModel
from contextlib import asynccontextmanager
from datetime import datetime

T = TypeVar("T", bound="EasyModel")

class SQLAlchemyCompatMixin:
    @classmethod
    @asynccontextmanager
    async def session(cls) -> AsyncSession: ...
    
    @classmethod
    def query(cls: Type[T]) -> AsyncQuery[T]: ...
    
    async def save(self, session: Optional[AsyncSession] = None) -> T: ...
    async def refresh(self, session: Optional[AsyncSession] = None) -> T: ...
    async def delete_instance(self, session: Optional[AsyncSession] = None) -> None: ...
    
    @classmethod
    async def create(cls: Type[T], **kwargs: Any) -> T: ...
    
    @classmethod
    async def find(cls: Type[T], id: Any) -> Optional[T]: ...
    
    @classmethod
    async def find_by(cls: Type[T], **kwargs: Any) -> Optional[T]: ...
    
    @classmethod
    async def find_all(cls: Type[T], **kwargs: Any) -> List[T]: ...
    
    @classmethod
    async def count(cls: Type[T], criteria: Optional[Dict[str, Any]] = None) -> int: ...
    
    @classmethod
    async def exists(cls: Type[T], **kwargs: Any) -> bool: ...
    
    @classmethod
    async def bulk_create(cls: Type[T], objects: List[Dict[str, Any]]) -> List[T]: ...
    
    @classmethod
    async def bulk_update(cls: Type[T], updates: List[Dict[str, Any]]) -> int: ...
    
    @classmethod
    def select_stmt(cls: Type[T]) -> sa_select: ...
    
    @classmethod
    def update_stmt(cls: Type[T]) -> sa_update: ...
    
    @classmethod
    def delete_stmt(cls: Type[T]) -> sa_delete: ...

class AsyncQuery(Generic[T]):
    model_class: Type[T]
    statement: sa_select
    
    def __init__(self, model_class: Type[T]) -> None: ...
    
    def filter(self, *criterion: Any) -> AsyncQuery[T]: ...
    def filter_by(self, **kwargs: Any) -> AsyncQuery[T]: ...
    def order_by(self, *columns: Any) -> AsyncQuery[T]: ...
    def limit(self, limit: int) -> AsyncQuery[T]: ...
    def offset(self, offset: int) -> AsyncQuery[T]: ...
    def options(self, *options: Any) -> AsyncQuery[T]: ...
    def join(self, *targets: Any, **kwargs: Any) -> AsyncQuery[T]: ...
    def outerjoin(self, *targets: Any, **kwargs: Any) -> AsyncQuery[T]: ...
    def group_by(self, *columns: Any) -> AsyncQuery[T]: ...
    def having(self, *criterion: Any) -> AsyncQuery[T]: ...
    
    async def all(self) -> List[T]: ...
    async def first(self) -> Optional[T]: ...
    async def one(self) -> T: ...
    async def one_or_none(self) -> Optional[T]: ...
    async def count(self) -> int: ...
    async def exists(self) -> bool: ...

# Re-export SQLAlchemy functions for convenience
select = sa_select
update = sa_update
delete = sa_delete

from sqlalchemy import and_ as and_, or_ as or_, func as func
from sqlalchemy.orm import selectinload as selectinload, joinedload as joinedload

__all__ = [
    'SQLAlchemyCompatMixin',
    'AsyncQuery',
    'select',
    'update', 
    'delete',
    'and_',
    'or_',
    'func',
    'selectinload',
    'joinedload'
]
