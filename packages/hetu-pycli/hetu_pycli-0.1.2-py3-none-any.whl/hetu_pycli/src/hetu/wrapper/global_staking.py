# GlobalStaking contract class generated from [ABI](contracts/GlobalStaking.abi)
# Do not edit this file directly, it is generated from the ABI.

from web3 import Web3

class GlobalStaking:
    def __init__(self, address, provider, abi):
        self.web3 = Web3(provider)
        self.contract = self.web3.eth.contract(address=address, abi=abi)

    def MIN_STAKE_TO_PARTICIPATE(self, ):
        """
        Call MIN_STAKE_TO_PARTICIPATE()
        :return: [{'internalType': 'uint256', 'name': '', 'type': 'uint256'}]
        """
        return self.contract.functions.MIN_STAKE_TO_PARTICIPATE().call()

    def MIN_SUBNET_ALLOCATION(self, ):
        """
        Call MIN_SUBNET_ALLOCATION()
        :return: [{'internalType': 'uint256', 'name': '', 'type': 'uint256'}]
        """
        return self.contract.functions.MIN_SUBNET_ALLOCATION().call()

    def addGlobalStake(self, amount):
        """
        Call addGlobalStake(amount)
        :param amount: uint256 (solidity name: 'amount')
        :return: []
        """
        return self.contract.functions.addGlobalStake(amount).call()

    def allocateToSubnet(self, netuid, amount):
        """
        Call allocateToSubnet(netuid, amount)
        :param netuid: uint16 (solidity name: 'netuid')
        :param amount: uint256 (solidity name: 'amount')
        :return: []
        """
        return self.contract.functions.allocateToSubnet(netuid, amount).call()

    def allocateToSubnetWithThreshold(self, user, netuid, amount, minThreshold):
        """
        Call allocateToSubnetWithThreshold(user, netuid, amount, minThreshold)
        :param user: address (solidity name: 'user')
        :param netuid: uint16 (solidity name: 'netuid')
        :param amount: uint256 (solidity name: 'amount')
        :param minThreshold: uint256 (solidity name: 'minThreshold')
        :return: []
        """
        return self.contract.functions.allocateToSubnetWithThreshold(user, netuid, amount, minThreshold).call()

    def authorizedCallers(self, arg0):
        """
        Call authorizedCallers(arg0)
        :param arg0: address (solidity name: 'arg0')
        :return: [{'internalType': 'bool', 'name': '', 'type': 'bool'}]
        """
        return self.contract.functions.authorizedCallers(arg0).call()

    def canBecomeNeuron(self, user, netuid, requiredAmount):
        """
        Call canBecomeNeuron(user, netuid, requiredAmount)
        :param user: address (solidity name: 'user')
        :param netuid: uint16 (solidity name: 'netuid')
        :param requiredAmount: uint256 (solidity name: 'requiredAmount')
        :return: [{'internalType': 'bool', 'name': '', 'type': 'bool'}]
        """
        return self.contract.functions.canBecomeNeuron(user, netuid, requiredAmount).call()

    def claimRewards(self, ):
        """
        Call claimRewards()
        :return: []
        """
        return self.contract.functions.claimRewards().call()

    def getAvailableStake(self, user, netuid):
        """
        Call getAvailableStake(user, netuid)
        :param user: address (solidity name: 'user')
        :param netuid: uint16 (solidity name: 'netuid')
        :return: [{'internalType': 'uint256', 'name': '', 'type': 'uint256'}]
        """
        return self.contract.functions.getAvailableStake(user, netuid).call()

    def getEffectiveStake(self, user, netuid):
        """
        Call getEffectiveStake(user, netuid)
        :param user: address (solidity name: 'user')
        :param netuid: uint16 (solidity name: 'netuid')
        :return: [{'internalType': 'uint256', 'name': '', 'type': 'uint256'}]
        """
        return self.contract.functions.getEffectiveStake(user, netuid).call()

    def getLockedStake(self, user, netuid):
        """
        Call getLockedStake(user, netuid)
        :param user: address (solidity name: 'user')
        :param netuid: uint16 (solidity name: 'netuid')
        :return: [{'internalType': 'uint256', 'name': '', 'type': 'uint256'}]
        """
        return self.contract.functions.getLockedStake(user, netuid).call()

    def getStakeInfo(self, user):
        """
        Call getStakeInfo(user)
        :param user: address (solidity name: 'user')
        :return: [{'components': [{'internalType': 'uint256', 'name': 'totalStaked', 'type': 'uint256'}, {'internalType': 'uint256', 'name': 'totalAllocated', 'type': 'uint256'}, {'internalType': 'uint256', 'name': 'availableForAllocation', 'type': 'uint256'}, {'internalType': 'uint256', 'name': 'lastUpdateBlock', 'type': 'uint256'}, {'internalType': 'uint256', 'name': 'pendingRewards', 'type': 'uint256'}], 'internalType': 'struct IGlobalStaking.StakeInfo', 'name': '', 'type': 'tuple'}]
        """
        return self.contract.functions.getStakeInfo(user).call()

    def getSubnetAllocation(self, user, netuid):
        """
        Call getSubnetAllocation(user, netuid)
        :param user: address (solidity name: 'user')
        :param netuid: uint16 (solidity name: 'netuid')
        :return: [{'components': [{'internalType': 'uint256', 'name': 'allocated', 'type': 'uint256'}, {'internalType': 'uint256', 'name': 'locked', 'type': 'uint256'}, {'internalType': 'uint256', 'name': 'lastUpdateBlock', 'type': 'uint256'}, {'internalType': 'bool', 'name': 'isActive', 'type': 'bool'}], 'internalType': 'struct IGlobalStaking.SubnetAllocation', 'name': '', 'type': 'tuple'}]
        """
        return self.contract.functions.getSubnetAllocation(user, netuid).call()

    def getTotalStaked(self, ):
        """
        Call getTotalStaked()
        :return: [{'internalType': 'uint256', 'name': '', 'type': 'uint256'}]
        """
        return self.contract.functions.getTotalStaked().call()

    def getUserStakeInfo(self, user):
        """
        Call getUserStakeInfo(user)
        :param user: address (solidity name: 'user')
        :return: [{'internalType': 'uint256', 'name': 'totalStaked_', 'type': 'uint256'}, {'internalType': 'uint256', 'name': 'availableForAllocation', 'type': 'uint256'}, {'internalType': 'uint16[]', 'name': 'allocatedSubnets', 'type': 'uint16[]'}]
        """
        return self.contract.functions.getUserStakeInfo(user).call()

    def hasParticipationEligibility(self, user):
        """
        Call hasParticipationEligibility(user)
        :param user: address (solidity name: 'user')
        :return: [{'internalType': 'bool', 'name': '', 'type': 'bool'}]
        """
        return self.contract.functions.hasParticipationEligibility(user).call()

    def hetuToken(self, ):
        """
        Call hetuToken()
        :return: [{'internalType': 'contract IERC20', 'name': '', 'type': 'address'}]
        """
        return self.contract.functions.hetuToken().call()

    def lockSubnetStake(self, user, netuid, amount):
        """
        Call lockSubnetStake(user, netuid, amount)
        :param user: address (solidity name: 'user')
        :param netuid: uint16 (solidity name: 'netuid')
        :param amount: uint256 (solidity name: 'amount')
        :return: []
        """
        return self.contract.functions.lockSubnetStake(user, netuid, amount).call()

    def lockedStake(self, arg0, arg1):
        """
        Call lockedStake(arg0, arg1)
        :param arg0: address (solidity name: 'arg0')
        :param arg1: uint16 (solidity name: 'arg1')
        :return: [{'internalType': 'uint256', 'name': '', 'type': 'uint256'}]
        """
        return self.contract.functions.lockedStake(arg0, arg1).call()

    def owner(self, ):
        """
        Call owner()
        :return: [{'internalType': 'address', 'name': '', 'type': 'address'}]
        """
        return self.contract.functions.owner().call()

    def removeGlobalStake(self, amount):
        """
        Call removeGlobalStake(amount)
        :param amount: uint256 (solidity name: 'amount')
        :return: []
        """
        return self.contract.functions.removeGlobalStake(amount).call()

    def renounceOwnership(self, ):
        """
        Call renounceOwnership()
        :return: []
        """
        return self.contract.functions.renounceOwnership().call()

    def setAuthorizedCaller(self, caller, authorized):
        """
        Call setAuthorizedCaller(caller, authorized)
        :param caller: address (solidity name: 'caller')
        :param authorized: bool (solidity name: 'authorized')
        :return: []
        """
        return self.contract.functions.setAuthorizedCaller(caller, authorized).call()

    def subnetTotalStake(self, arg0):
        """
        Call subnetTotalStake(arg0)
        :param arg0: uint16 (solidity name: 'arg0')
        :return: [{'internalType': 'uint256', 'name': '', 'type': 'uint256'}]
        """
        return self.contract.functions.subnetTotalStake(arg0).call()

    def subnetUserStake(self, arg0, arg1):
        """
        Call subnetUserStake(arg0, arg1)
        :param arg0: uint16 (solidity name: 'arg0')
        :param arg1: address (solidity name: 'arg1')
        :return: [{'internalType': 'uint256', 'name': '', 'type': 'uint256'}]
        """
        return self.contract.functions.subnetUserStake(arg0, arg1).call()

    def totalUserStake(self, arg0):
        """
        Call totalUserStake(arg0)
        :param arg0: address (solidity name: 'arg0')
        :return: [{'internalType': 'uint256', 'name': '', 'type': 'uint256'}]
        """
        return self.contract.functions.totalUserStake(arg0).call()

    def transferOwnership(self, newOwner):
        """
        Call transferOwnership(newOwner)
        :param newOwner: address (solidity name: 'newOwner')
        :return: []
        """
        return self.contract.functions.transferOwnership(newOwner).call()

    def unlockSubnetStake(self, user, netuid, amount):
        """
        Call unlockSubnetStake(user, netuid, amount)
        :param user: address (solidity name: 'user')
        :param netuid: uint16 (solidity name: 'netuid')
        :param amount: uint256 (solidity name: 'amount')
        :return: []
        """
        return self.contract.functions.unlockSubnetStake(user, netuid, amount).call()