import json
import typer
from web3 import Web3
from rich import print

contract_app = typer.Typer(help="Contract operations")


@contract_app.command()
def call(
    ctx: typer.Context,
    address: str = typer.Option(..., help="Contract address"),
    abi_path: str = typer.Option(..., help="ABI file path"),
    function: str = typer.Option(..., help="Contract method name"),
    args: str = typer.Option("", help="Method arguments, comma separated"),
    rpc: str = typer.Option(..., help="Hetu chain node RPC URL"),
):
    """Call contract view method"""
    config = ctx.obj
    rpc_url = rpc or (config.get("json_rpc") if config else None)
    if not rpc_url:
        print("[red]No RPC URL provided or found in config.")
        raise typer.Exit(1)
    import json

    w3 = Web3(Web3.HTTPProvider(rpc_url))
    with open(abi_path, "r") as f:
        abi = json.load(f)
    contract = w3.eth.contract(address=address, abi=abi)
    fn = getattr(contract.functions, function)
    arg_list = [eval(x) for x in args.split(",")] if args else []
    result = fn(*arg_list).call()
    print(f"[cyan]Return value: {result}")


@contract_app.command(name="abigen")
def generate_class(
    abi_path: str = typer.Option(..., help="ABI file path"),
    contract_name: str = typer.Option(..., help="Contract class name"),
    output: str = typer.Option(None, help="Output file path (optional)"),
):
    """Generate a Python contract class from ABI"""

    def generate_contract_class(abi, contract_name):
        import keyword
        from collections import defaultdict

        def safe_func_name(name):
            name = name.replace(" ", "_").replace("-", "_")
            if keyword.iskeyword(name):
                name = name + "_"
            return name

        def safe_param_name(name):
            if keyword.iskeyword(name):
                return name + "_"
            return name

        func_groups = defaultdict(list)
        for entry in abi:
            if entry.get("type") == "function":
                func_groups[entry["name"]].append(entry)

        methods = []
        for func_name, overloads in func_groups.items():
            py_name = safe_func_name(func_name)
            entry = overloads[0]
            inputs = entry.get("inputs", [])
            param_defs = []
            param_docs = []
            call_args = []
            for i, inp in enumerate(inputs):
                orig = inp["name"] or f"arg{i}"
                pyparam = safe_param_name(orig)
                param_defs.append(pyparam)
                param_docs.append(
                    f":param {pyparam}: {inp['type']} (solidity name: '{orig}')"
                )
                call_args.append(pyparam)
            params = ", ".join(param_defs)
            call_args_str = ", ".join(call_args)
            doc_lines = [
                f"Call {func_name}({params})",
                *param_docs,
                f":return: {entry.get('outputs', '')}",
            ]
            docstring = "\n        ".join(doc_lines)
            method = f'    def {py_name}(self, {params}):\n        """\n        {docstring}\n        """\n        return self.contract.functions.{func_name}({call_args_str}).call()'
            methods.append(method)
        
        class_code = (
            f"# {contract_name} contract class generated from [ABI]({abi_path})\n"
            f"# Do not edit this file directly, it is generated from the ABI.\n\n"
            f"from web3 import Web3\n\n"
            f"class {contract_name}:\n"
            f"    def __init__(self, address, provider, abi):\n"
            f"        self.web3 = Web3(provider)\n"
            f"        self.contract = self.web3.eth.contract(address=address, abi=abi)\n\n"
            + "\n\n".join(methods)
        )
        return class_code

    with open(abi_path, "r") as f:
        abi = json.load(f)
    class_code = generate_contract_class(abi, contract_name[:1].upper() + contract_name[1:])
    if output:
        with open(output, "w") as f:
            f.write(class_code)
        print(f"[green]Contract class written to {output}")
    else:
        print(class_code)
