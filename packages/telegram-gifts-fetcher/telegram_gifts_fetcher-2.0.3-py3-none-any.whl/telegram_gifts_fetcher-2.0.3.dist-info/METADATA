Metadata-Version: 2.4
Name: telegram-gifts-fetcher
Version: 2.0.3
Summary: A Python library to fetch Telegram gifts data
Author: Th3ryks
Project-URL: Homepage, https://github.com/Th3ryks/TelegramGiftsFetcher
Project-URL: Bug Reports, https://github.com/Th3ryks/TelegramGiftsFetcher/issues
Project-URL: Source, https://github.com/Th3ryks/TelegramGiftsFetcher
Classifier: Development Status :: 4 - Beta
Classifier: Intended Audience :: Developers
Classifier: License :: OSI Approved :: MIT License
Classifier: Operating System :: OS Independent
Classifier: Programming Language :: Python :: 3
Classifier: Programming Language :: Python :: 3.8
Classifier: Programming Language :: Python :: 3.9
Classifier: Programming Language :: Python :: 3.10
Classifier: Programming Language :: Python :: 3.11
Classifier: Programming Language :: Python :: 3.12
Requires-Python: >=3.8
Description-Content-Type: text/markdown
License-File: LICENSE
Requires-Dist: telethon==1.40.0
Requires-Dist: python-dotenv==1.0.0
Requires-Dist: colorama==0.4.6
Provides-Extra: dev
Requires-Dist: pytest>=6.0; extra == "dev"
Requires-Dist: pytest-asyncio; extra == "dev"
Requires-Dist: black; extra == "dev"
Requires-Dist: ruff; extra == "dev"
Dynamic: license-file

# ğŸ Telegram Gifts Fetcher

[![PyPI version](https://badge.fury.io/py/telegram-gifts-fetcher.svg)](https://badge.fury.io/py/telegram-gifts-fetcher)
[![Python 3.8+](https://img.shields.io/badge/python-3.8+-blue.svg)](https://www.python.org/downloads/)
[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)
[![GitHub](https://img.shields.io/badge/GitHub-Th3ryks-blue)](https://github.com/Th3ryks/TelegramGiftsFetcher)

**A powerful Python library to fetch and analyze Telegram Gifts! ğŸŒŸ**

This library provides a comprehensive solution for programmatically fetching, analyzing, and managing Telegram Gifts from user profiles using the official Telegram API.

## âœ¨ Features

- ğŸ **Complete Gift Support** - Handles all Telegram gift types (StarGift, StarGiftUnique, StarGiftRegular)
- ğŸ“Š **Advanced Analytics** - Detailed gift statistics, trends, and sender analysis
- ğŸš€ **Async/Await Ready** - Built with modern Python async patterns
- ğŸ›¡ï¸ **Robust Error Handling** - Comprehensive error management and type safety
- ğŸ“± **Developer Friendly** - Simple, intuitive API design
- ğŸ’¾ **Multiple Export Formats** - JSON, CSV, and custom data exports
- ğŸ” **Smart Filtering** - Advanced gift filtering by date, type, value, and more
- ğŸ§® **Statistical Tools** - Comprehensive gift statistics

## ğŸ“¦ Installation

```bash
pip install telegram-gifts-fetcher
```

## ğŸš€ Quick Start

### 1. Get Telegram API Credentials

1. Visit [my.telegram.org](https://my.telegram.org)
2. Log in with your phone number
3. Navigate to "API Development Tools"
4. Create a new application
5. Save your `API_ID` and `API_HASH`

### 2. Environment Setup (Recommended)

For security, it's recommended to use environment variables. You can create a `.env` file in your project root:

```env
API_ID=your_api_id_here
API_HASH=your_api_hash_here
```

Alternatively, you can pass credentials directly to the client or set them as system environment variables.

### 3. Basic Usage

```python
from telegram_gifts_fetcher import TelegramGiftsClient
import asyncio

async def main():
    # Create client instance
    client = TelegramGiftsClient()
    
    try:
        # Connect to Telegram
        if await client.connect():
            # Fetch gifts for a user
            result = await client.get_user_gifts('username')
            
            print(f"ğŸ“Š Found {result.count_gifts} gifts!")
            
            # Display recent gifts
            for gift in result.gifts[:5]:
                gift_type = gift.type or 'Unknown'
                print(f"ğŸ {gift_type} gift received")
    finally:
        await client.disconnect()

if __name__ == "__main__":
    asyncio.run(main())
```

## ğŸ“– API Reference

### `TelegramGiftsClient`

Main class for fetching and analyzing Telegram gifts.

```python
from telegram_gifts_fetcher import TelegramGiftsClient

client = TelegramGiftsClient()
```

#### `get_user_gifts(username, offset="", limit=100)`

Fetches Telegram Star Gifts for a specified user.

**Parameters:**
- `username` (str): Target username (without @)
- `offset` (str, optional): Pagination offset for large datasets
- `limit` (int, optional): Maximum gifts to fetch (default: 100)

**Returns:**
Returns a `GiftsResponse` object with the following attributes:
```python
result.gifts  # List of gift objects
result.count_gifts  # Total gifts found

# Each gift object has:
gift.received_date  # Unix timestamp
gift.type  # Gift type classification
gift.message  # Gift message (optional)
gift.name_hidden  # Whether sender name is hidden
gift.can_upgrade  # Upgrade availability
gift.pinned_to_top  # Whether gift is pinned
gift.name  # Gift name
gift.slug  # Gift slug
```

## ğŸ¯ Gift Types Supported

| Type | Constructor ID | Description |
|------|----------------|-------------|
| `StarGift` | `0x2cc73c8` | Regular gifts |
| `StarGiftUnique` | `0x5c62d151` | Unique/limited gifts |
| `StarGiftRegular` | `0x736b72c7` | Standard gifts |
| `Unknown` | Various | Future gift types |

## ğŸ”§ Advanced Usage

### Custom Gift Processing

```python
async def process_gifts(username):
    client = TelegramGiftsClient()
    
    try:
        if await client.connect():
            result = await client.get_user_gifts(username)
            
            # Filter by gift type
            unique_gifts = [g for g in result.gifts if g.type == 'StarGiftUnique']
            
            # Find most recent gift
            most_recent = max(result.gifts, key=lambda x: x.received_date or 0)
            
            return {
                'unique_count': len(unique_gifts),
                'most_recent': most_recent
            }
    finally:
        await client.disconnect()
```

### ğŸ“Š Advanced Features

#### Gift Statistics and Analysis

```python
import asyncio
from telegram_gifts_fetcher import TelegramGiftsClient
from collections import Counter

async def analyze_gifts():
    client = TelegramGiftsClient()
    
    try:
        if await client.connect():
            # Fetch gifts
            result = await client.get_user_gifts('username')
            
            # Basic statistics
            total_gifts = result.count_gifts
            anonymous_gifts = sum(1 for gift in result.gifts if gift.name_hidden)
            pinned_gifts = sum(1 for gift in result.gifts if gift.pinned_to_top)
            
            print(f"ğŸ“Š Total gifts: {total_gifts}")
            print(f"ğŸ­ Anonymous gifts: {anonymous_gifts}")
            print(f"ğŸ“Œ Pinned gifts: {pinned_gifts}")
            
            # Gift types distribution
            gift_types = Counter(gift.type for gift in result.gifts)
            for gift_type, count in gift_types.items():
                print(f"ğŸ {gift_type}: {count}")
    finally:
        await client.disconnect()

asyncio.run(analyze_gifts())
```

#### Gift Filtering and Export

```python
from telegram_gifts_fetcher import TelegramGiftsClient
from datetime import datetime, timedelta
import json

async def filter_and_export():
    client = TelegramGiftsClient()
    
    try:
        if await client.connect():
            # Fetch gifts
            result = await client.get_user_gifts('username')
            gifts = result.gifts
            
            # Filter recent gifts from last month
            cutoff_date = datetime.now() - timedelta(days=30)
            recent_gifts = [
                gift for gift in gifts 
                if datetime.fromtimestamp(gift.received_date) >= cutoff_date
            ]
            
            # Filter by gift type
            star_gifts = [gift for gift in gifts if gift.type == 'star_gift']
            
            # Filter pinned gifts
            pinned_gifts = [gift for gift in gifts if gift.pinned_to_top]
            
            # Export to JSON
            with open('recent_gifts.json', 'w') as f:
                json.dump([gift.to_dict() for gift in recent_gifts], f, indent=2)
            
            print(f"ğŸ“¤ Exported {len(recent_gifts)} recent gifts")
            print(f"ğŸ“¤ Found {len(star_gifts)} star gifts")
            print(f"ğŸ“Œ Found {len(pinned_gifts)} pinned gifts")
    finally:
        await client.disconnect()

asyncio.run(filter_and_export())
```

#### Trend and Sender Analysis

```python
from telegram_gifts_fetcher import TelegramGiftsClient
from datetime import datetime, timedelta
from collections import defaultdict

async def analyze_patterns():
    client = TelegramGiftsClient()
    
    try:
        if await client.connect():
            result = await client.get_user_gifts('username')
            gifts = result.gifts
            
            # Analyze weekly trends
            weekly_data = defaultdict(lambda: {'count': 0, 'unique': 0})
            
            for gift in gifts:
                gift_date = datetime.fromtimestamp(gift.received_date)
                week_start = gift_date - timedelta(days=gift_date.weekday())
                week_key = week_start.strftime('%Y-%m-%d')
                
                weekly_data[week_key]['count'] += 1
                if gift.type == 'StarGiftUnique':
                    weekly_data[week_key]['unique'] += 1
            
            print("ğŸ“ˆ Weekly Trends:")
            for week, data in sorted(weekly_data.items())[-4:]:  # Last 4 weeks
                print(f"  Week {week}: {data['count']} gifts, {data['unique']} unique")
            
            # Analyze gift patterns
            anonymous_count = sum(1 for gift in gifts if gift.name_hidden)
            pinned_count = sum(1 for gift in gifts if gift.pinned_to_top)
            
            print(f"\nğŸ“Š Gift Patterns:")
            print(f"  Anonymous gifts: {anonymous_count}/{len(gifts)}")
            print(f"  Pinned gifts: {pinned_count}/{len(gifts)}")
            print(f"  Gift types: {len(set(g.type for g in gifts))} different types")
    finally:
        await client.disconnect()

asyncio.run(analyze_patterns())
```

### Dependency Error Handler ğŸ› ï¸

The library includes an automatic dependency error handler that detects and fixes circular dependencies:

```python
from telegram_gifts_fetcher import (
    handle_dependency_errors,
    check_circular_dependencies,
    fix_circular_dependencies,
    DependencyError
)

# Automatic error handling
try:
    handle_dependency_errors()
except DependencyError as e:
    print(f"Dependency error: {e}")

# Manual checking
if check_circular_dependencies("telegram-gifts-fetcher"):
    print("Circular dependencies detected!")
    fix_circular_dependencies("telegram-gifts-fetcher")
```

**Features of the dependency handler:**
- ğŸ” **Automatic Detection** - Scans setup.py, pyproject.toml, and requirements.txt
- ğŸ”§ **Auto-Fix** - Removes circular dependencies automatically
- ğŸ“ **Detailed Logging** - Comprehensive logging with loguru
- âš¡ **Fast Processing** - Efficient file parsing and modification

### ğŸ›¡ï¸ Error Handling

```python
from telegram_gifts_fetcher import TelegramGiftsClient
from telethon.errors import RPCError

async def safe_fetch():
    client = TelegramGiftsClient()
    
    try:
        if await client.connect():
            result = await client.get_user_gifts('username')
            print(f"âœ… Successfully fetched {result.count_gifts} gifts")
        else:
            print("âŒ Failed to connect to Telegram")
    except RPCError as e:
        print(f"âŒ Telegram API error: {e}")
    except RuntimeError as e:
        print(f"âŒ Client error: {e}")
    except Exception as e:
        print(f"ğŸ’¥ Unexpected error: {e}")
    finally:
        await client.disconnect()

asyncio.run(safe_fetch())
```

## ğŸ“Š Gift Data Structure

The `get_user_gifts` function returns a `GiftsResponse` object with the following structure:

```python
{
    'gifts': [
        {
            'received_date': int,           # Unix timestamp
            'constructor_id': str,          # Telegram constructor ID
            'message': str,                 # Gift message (if any)
            'msg_id': int,                  # Message ID
            'saved_id': str,                # Saved gift ID (if any)
            'name_hidden': bool,            # Whether sender name is hidden
            'unsaved': bool,                # Whether gift is unsaved
            'refunded': bool,               # Whether gift was refunded
            'can_upgrade': bool,            # Whether gift can be upgraded
            'pinned_to_top': bool,          # Whether gift is pinned
            'type': str,                    # Gift type classification
            'raw_data': str,                # Raw Telegram object data
            'name': str,                    # Gift name
            'slug': str,                    # Gift slug
        }
    ],
    'count_gifts': int,                     # Total number of gifts
}
```

## ğŸ” Supported Gift Types

- **StarGift**: Regular gifts
- **StarGiftUnique**: Unique gifts
- **StarGiftRegular**: Standard gifts (newly supported)
- **Unknown**: Unrecognized gift types (logged for debugging)

## ğŸ› Debugging

The library includes comprehensive logging. To enable debug output:

```python
from loguru import logger
logger.add("debug.log", level="DEBUG")
```

## ğŸ¤ Contributing

Contributions are welcome! Please feel free to submit a Pull Request.

## ğŸ“„ License

This project is licensed under the MIT License.

## ğŸ™ Acknowledgments

- Based on the original `telegram_gift_fetcher` library
- Enhanced to support additional gift types and provide better debugging
