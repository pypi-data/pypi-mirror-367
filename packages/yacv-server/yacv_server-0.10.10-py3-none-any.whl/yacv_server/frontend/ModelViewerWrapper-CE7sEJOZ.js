import{a9 as Xe,V as z,aa as We,L as G,h as At,ab as wt,S as Ze,d as ot,B as J,ac as tn,ad as en,ae as nn,af as _e,M as Ae,ag as sn,ah as rn,j as on,ai as cn,aj as Se,r as Q,l as an,ak as ln,al as un,am as fn,an as pn,ao as dn,ap as yn,aq as Me,a8 as et,p as nt,Q as Ut,x as Dt,ar as mn,as as Ce,at as hn,au as xn,av as wn,$ as gn,t as An,aw as Rt,a7 as Tn}from"./index-Cs0xcLWZ.js";const Ye=0,bn=1,Bn=2,Le=2,te=1.25,ze=1,Lt=32,Ot=65535,vn=Math.pow(2,-24),ee=Symbol("SKIP_GENERATION");function Pn(n){return n.index?n.index.count:n.attributes.position.count}function Tt(n){return Pn(n)/3}function _n(n,e=ArrayBuffer){return n>65535?new Uint32Array(new e(4*n)):new Uint16Array(new e(2*n))}function Sn(n,e){if(!n.index){const t=n.attributes.position.count,s=e.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer,i=_n(t,s);n.setIndex(new Xe(i,1));for(let a=0;a<t;a++)i[a]=a}}function Ke(n,e){const t=Tt(n),s=e||n.drawRange,i=s.start/3,a=(s.start+s.count)/3,r=Math.max(0,i),c=Math.min(t,a)-r;return[{offset:Math.floor(r),count:Math.floor(c)}]}function Qe(n,e){if(!n.groups||!n.groups.length)return Ke(n,e);const t=[],s=new Set,i=e||n.drawRange,a=i.start/3,r=(i.start+i.count)/3;for(const o of n.groups){const p=o.start/3,u=(o.start+o.count)/3;s.add(Math.max(a,p)),s.add(Math.min(r,u))}const c=Array.from(s.values()).sort((o,p)=>o-p);for(let o=0;o<c.length-1;o++){const p=c[o],u=c[o+1];t.push({offset:Math.floor(p),count:Math.floor(u-p)})}return t}function Mn(n,e){const t=Tt(n),s=Qe(n,e).sort((r,c)=>r.offset-c.offset),i=s[s.length-1];i.count=Math.min(t-i.offset,i.count);let a=0;return s.forEach(({count:r})=>a+=r),t!==a}function ne(n,e,t,s,i){let a=1/0,r=1/0,c=1/0,o=-1/0,p=-1/0,u=-1/0,f=1/0,l=1/0,d=1/0,A=-1/0,T=-1/0,h=-1/0;for(let m=e*6,y=(e+t)*6;m<y;m+=6){const x=n[m+0],w=n[m+1],g=x-w,B=x+w;g<a&&(a=g),B>o&&(o=B),x<f&&(f=x),x>A&&(A=x);const b=n[m+2],P=n[m+3],_=b-P,M=b+P;_<r&&(r=_),M>p&&(p=M),b<l&&(l=b),b>T&&(T=b);const C=n[m+4],S=n[m+5],v=C-S,L=C+S;v<c&&(c=v),L>u&&(u=L),C<d&&(d=C),C>h&&(h=C)}s[0]=a,s[1]=r,s[2]=c,s[3]=o,s[4]=p,s[5]=u,i[0]=f,i[1]=l,i[2]=d,i[3]=A,i[4]=T,i[5]=h}function Cn(n,e=null,t=null,s=null){const i=n.attributes.position,a=n.index?n.index.array:null,r=Tt(n),c=i.normalized;let o;e===null?(o=new Float32Array(r*6),t=0,s=r):(o=e,t=t||0,s=s||r);const p=i.array,u=i.offset||0;let f=3;i.isInterleavedBufferAttribute&&(f=i.data.stride);const l=["getX","getY","getZ"];for(let d=t;d<t+s;d++){const A=d*3,T=d*6;let h=A+0,m=A+1,y=A+2;a&&(h=a[h],m=a[m],y=a[y]),c||(h=h*f+u,m=m*f+u,y=y*f+u);for(let x=0;x<3;x++){let w,g,B;c?(w=i[l[x]](h),g=i[l[x]](m),B=i[l[x]](y)):(w=p[h+x],g=p[m+x],B=p[y+x]);let b=w;g<b&&(b=g),B<b&&(b=B);let P=w;g>P&&(P=g),B>P&&(P=B);const _=(P-b)/2,M=x*2;o[T+M+0]=b+_,o[T+M+1]=_+(Math.abs(b)+_)*vn}}return o}function F(n,e,t){return t.min.x=e[n],t.min.y=e[n+1],t.min.z=e[n+2],t.max.x=e[n+3],t.max.y=e[n+4],t.max.z=e[n+5],t}function Ue(n){let e=-1,t=-1/0;for(let s=0;s<3;s++){const i=n[s+3]-n[s];i>t&&(t=i,e=s)}return e}function De(n,e){e.set(n)}function Re(n,e,t){let s,i;for(let a=0;a<3;a++){const r=a+3;s=n[a],i=e[a],t[a]=s<i?s:i,s=n[r],i=e[r],t[r]=s>i?s:i}}function Ft(n,e,t){for(let s=0;s<3;s++){const i=e[n+2*s],a=e[n+2*s+1],r=i-a,c=i+a;r<t[s]&&(t[s]=r),c>t[s+3]&&(t[s+3]=c)}}function bt(n){const e=n[3]-n[0],t=n[4]-n[1],s=n[5]-n[2];return 2*(e*t+t*s+s*e)}const O=32,Ln=(n,e)=>n.candidate-e.candidate,st=new Array(O).fill().map(()=>({count:0,bounds:new Float32Array(6),rightCacheBounds:new Float32Array(6),leftCacheBounds:new Float32Array(6),candidate:0})),Et=new Float32Array(6);function zn(n,e,t,s,i,a){let r=-1,c=0;if(a===Ye)r=Ue(e),r!==-1&&(c=(e[r]+e[r+3])/2);else if(a===bn)r=Ue(n),r!==-1&&(c=Un(t,s,i,r));else if(a===Bn){const o=bt(n);let p=te*i;const u=s*6,f=(s+i)*6;for(let l=0;l<3;l++){const d=e[l],h=(e[l+3]-d)/O;if(i<O/4){const m=[...st];m.length=i;let y=0;for(let w=u;w<f;w+=6,y++){const g=m[y];g.candidate=t[w+2*l],g.count=0;const{bounds:B,leftCacheBounds:b,rightCacheBounds:P}=g;for(let _=0;_<3;_++)P[_]=1/0,P[_+3]=-1/0,b[_]=1/0,b[_+3]=-1/0,B[_]=1/0,B[_+3]=-1/0;Ft(w,t,B)}m.sort(Ln);let x=i;for(let w=0;w<x;w++){const g=m[w];for(;w+1<x&&m[w+1].candidate===g.candidate;)m.splice(w+1,1),x--}for(let w=u;w<f;w+=6){const g=t[w+2*l];for(let B=0;B<x;B++){const b=m[B];g>=b.candidate?Ft(w,t,b.rightCacheBounds):(Ft(w,t,b.leftCacheBounds),b.count++)}}for(let w=0;w<x;w++){const g=m[w],B=g.count,b=i-g.count,P=g.leftCacheBounds,_=g.rightCacheBounds;let M=0;B!==0&&(M=bt(P)/o);let C=0;b!==0&&(C=bt(_)/o);const S=ze+te*(M*B+C*b);S<p&&(r=l,p=S,c=g.candidate)}}else{for(let x=0;x<O;x++){const w=st[x];w.count=0,w.candidate=d+h+x*h;const g=w.bounds;for(let B=0;B<3;B++)g[B]=1/0,g[B+3]=-1/0}for(let x=u;x<f;x+=6){let B=~~((t[x+2*l]-d)/h);B>=O&&(B=O-1);const b=st[B];b.count++,Ft(x,t,b.bounds)}const m=st[O-1];De(m.bounds,m.rightCacheBounds);for(let x=O-2;x>=0;x--){const w=st[x],g=st[x+1];Re(w.bounds,g.rightCacheBounds,w.rightCacheBounds)}let y=0;for(let x=0;x<O-1;x++){const w=st[x],g=w.count,B=w.bounds,P=st[x+1].rightCacheBounds;g!==0&&(y===0?De(B,Et):Re(B,Et,Et)),y+=g;let _=0,M=0;y!==0&&(_=bt(Et)/o);const C=i-y;C!==0&&(M=bt(P)/o);const S=ze+te*(_*y+M*C);S<p&&(r=l,p=S,c=w.candidate)}}}}else console.warn(`MeshBVH: Invalid build strategy value ${a} used.`);return{axis:r,pos:c}}function Un(n,e,t,s){let i=0;for(let a=e,r=e+t;a<r;a++)i+=n[a*6+s*2];return i/t}class se{constructor(){this.boundingData=new Float32Array(6)}}function Dn(n,e,t,s,i,a){let r=s,c=s+i-1;const o=a.pos,p=a.axis*2;for(;;){for(;r<=c&&t[r*6+p]<o;)r++;for(;r<=c&&t[c*6+p]>=o;)c--;if(r<c){for(let u=0;u<3;u++){let f=e[r*3+u];e[r*3+u]=e[c*3+u],e[c*3+u]=f}for(let u=0;u<6;u++){let f=t[r*6+u];t[r*6+u]=t[c*6+u],t[c*6+u]=f}r++,c--}else return r}}function Rn(n,e,t,s,i,a){let r=s,c=s+i-1;const o=a.pos,p=a.axis*2;for(;;){for(;r<=c&&t[r*6+p]<o;)r++;for(;r<=c&&t[c*6+p]>=o;)c--;if(r<c){let u=n[r];n[r]=n[c],n[c]=u;for(let f=0;f<6;f++){let l=t[r*6+f];t[r*6+f]=t[c*6+f],t[c*6+f]=l}r++,c--}else return r}}function I(n,e){return e[n+15]===65535}function q(n,e){return e[n+6]}function $(n,e){return e[n+14]}function H(n){return n+8}function j(n,e){return e[n+6]}function Je(n,e){return e[n+7]}let Oe,Ct,Qt,Ge;const Fn=Math.pow(2,32);function fe(n){return"count"in n?1:1+fe(n.left)+fe(n.right)}function En(n,e,t){return Oe=new Float32Array(t),Ct=new Uint32Array(t),Qt=new Uint16Array(t),Ge=new Uint8Array(t),pe(n,e)}function pe(n,e){const t=n/4,s=n/2,i="count"in e,a=e.boundingData;for(let r=0;r<6;r++)Oe[t+r]=a[r];if(i)if(e.buffer){const r=e.buffer;Ge.set(new Uint8Array(r),n);for(let c=n,o=n+r.byteLength;c<o;c+=Lt){const p=c/2;I(p,Qt)||(Ct[c/4+6]+=t)}return n+r.byteLength}else{const r=e.offset,c=e.count;return Ct[t+6]=r,Qt[s+14]=c,Qt[s+15]=Ot,n+Lt}else{const r=e.left,c=e.right,o=e.splitAxis;let p;if(p=pe(n+Lt,r),p/4>Fn)throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");return Ct[t+6]=p/4,p=pe(p,c),Ct[t+7]=o,p}}function Vn(n,e){const t=(n.index?n.index.count:n.attributes.position.count)/3,s=t>2**16,i=s?4:2,a=e?new SharedArrayBuffer(t*i):new ArrayBuffer(t*i),r=s?new Uint32Array(a):new Uint16Array(a);for(let c=0,o=r.length;c<o;c++)r[c]=c;return r}function Nn(n,e,t,s,i){const{maxDepth:a,verbose:r,maxLeafTris:c,strategy:o,onProgress:p,indirect:u}=i,f=n._indirectBuffer,l=n.geometry,d=l.index?l.index.array:null,A=u?Rn:Dn,T=Tt(l),h=new Float32Array(6);let m=!1;const y=new se;return ne(e,t,s,y.boundingData,h),w(y,t,s,h),y;function x(g){p&&p(g/T)}function w(g,B,b,P=null,_=0){if(!m&&_>=a&&(m=!0,r&&(console.warn(`MeshBVH: Max depth of ${a} reached when generating BVH. Consider increasing maxDepth.`),console.warn(l))),b<=c||_>=a)return x(B+b),g.offset=B,g.count=b,g;const M=zn(g.boundingData,P,e,B,b,o);if(M.axis===-1)return x(B+b),g.offset=B,g.count=b,g;const C=A(f,d,e,B,b,M);if(C===B||C===B+b)x(B+b),g.offset=B,g.count=b;else{g.splitAxis=M.axis;const S=new se,v=B,L=C-B;g.left=S,ne(e,v,L,S.boundingData,h),w(S,v,L,h,_+1);const D=new se,U=C,N=b-L;g.right=D,ne(e,U,N,D.boundingData,h),w(D,U,N,h,_+1)}return g}}function kn(n,e){const t=n.geometry;e.indirect&&(n._indirectBuffer=Vn(t,e.useSharedArrayBuffer),Mn(t,e.range)&&!e.verbose&&console.warn('MeshBVH: Provided geometry contains groups or a range that do not fully span the vertex contents while using the "indirect" option. BVH may incorrectly report intersections on unrendered portions of the geometry.')),n._indirectBuffer||Sn(t,e);const s=e.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer,i=Cn(t),a=e.indirect?Ke(t,e.range):Qe(t,e.range);n._roots=a.map(r=>{const c=Nn(n,i,r.offset,r.count,e),o=fe(c),p=new s(Lt*o);return En(0,c,p),p})}class tt{constructor(){this.min=1/0,this.max=-1/0}setFromPointsField(e,t){let s=1/0,i=-1/0;for(let a=0,r=e.length;a<r;a++){const o=e[a][t];s=o<s?o:s,i=o>i?o:i}this.min=s,this.max=i}setFromPoints(e,t){let s=1/0,i=-1/0;for(let a=0,r=t.length;a<r;a++){const c=t[a],o=e.dot(c);s=o<s?o:s,i=o>i?o:i}this.min=s,this.max=i}isSeparated(e){return this.min>e.max||e.min>this.max}}tt.prototype.setFromBox=function(){const n=new z;return function(t,s){const i=s.min,a=s.max;let r=1/0,c=-1/0;for(let o=0;o<=1;o++)for(let p=0;p<=1;p++)for(let u=0;u<=1;u++){n.x=i.x*o+a.x*(1-o),n.y=i.y*p+a.y*(1-p),n.z=i.z*u+a.z*(1-u);const f=t.dot(n);r=Math.min(f,r),c=Math.max(f,c)}this.min=r,this.max=c}}();const In=function(){const n=new z,e=new z,t=new z;return function(i,a,r){const c=i.start,o=n,p=a.start,u=e;t.subVectors(c,p),n.subVectors(i.end,i.start),e.subVectors(a.end,a.start);const f=t.dot(u),l=u.dot(o),d=u.dot(u),A=t.dot(o),h=o.dot(o)*d-l*l;let m,y;h!==0?m=(f*l-A*d)/h:m=0,y=(f+m*l)/d,r.x=m,r.y=y}}(),Te=function(){const n=new At,e=new z,t=new z;return function(i,a,r,c){In(i,a,n);let o=n.x,p=n.y;if(o>=0&&o<=1&&p>=0&&p<=1){i.at(o,r),a.at(p,c);return}else if(o>=0&&o<=1){p<0?a.at(0,c):a.at(1,c),i.closestPointToPoint(c,!0,r);return}else if(p>=0&&p<=1){o<0?i.at(0,r):i.at(1,r),a.closestPointToPoint(r,!0,c);return}else{let u;o<0?u=i.start:u=i.end;let f;p<0?f=a.start:f=a.end;const l=e,d=t;if(i.closestPointToPoint(f,!0,e),a.closestPointToPoint(u,!0,t),l.distanceToSquared(f)<=d.distanceToSquared(u)){r.copy(l),c.copy(f);return}else{r.copy(u),c.copy(d);return}}}}(),qn=function(){const n=new z,e=new z,t=new We,s=new G;return function(a,r){const{radius:c,center:o}=a,{a:p,b:u,c:f}=r;if(s.start=p,s.end=u,s.closestPointToPoint(o,!0,n).distanceTo(o)<=c||(s.start=p,s.end=f,s.closestPointToPoint(o,!0,n).distanceTo(o)<=c)||(s.start=u,s.end=f,s.closestPointToPoint(o,!0,n).distanceTo(o)<=c))return!0;const T=r.getPlane(t);if(Math.abs(T.distanceToPoint(o))<=c){const m=T.projectPoint(o,e);if(r.containsPoint(m))return!0}return!1}}(),$n=1e-15;function ie(n){return Math.abs(n)<$n}class Z extends wt{constructor(...e){super(...e),this.isExtendedTriangle=!0,this.satAxes=new Array(4).fill().map(()=>new z),this.satBounds=new Array(4).fill().map(()=>new tt),this.points=[this.a,this.b,this.c],this.sphere=new Ze,this.plane=new We,this.needsUpdate=!0}intersectsSphere(e){return qn(e,this)}update(){const e=this.a,t=this.b,s=this.c,i=this.points,a=this.satAxes,r=this.satBounds,c=a[0],o=r[0];this.getNormal(c),o.setFromPoints(c,i);const p=a[1],u=r[1];p.subVectors(e,t),u.setFromPoints(p,i);const f=a[2],l=r[2];f.subVectors(t,s),l.setFromPoints(f,i);const d=a[3],A=r[3];d.subVectors(s,e),A.setFromPoints(d,i),this.sphere.setFromPoints(this.points),this.plane.setFromNormalAndCoplanarPoint(c,e),this.needsUpdate=!1}}Z.prototype.closestPointToSegment=function(){const n=new z,e=new z,t=new G;return function(i,a=null,r=null){const{start:c,end:o}=i,p=this.points;let u,f=1/0;for(let l=0;l<3;l++){const d=(l+1)%3;t.start.copy(p[l]),t.end.copy(p[d]),Te(t,i,n,e),u=n.distanceToSquared(e),u<f&&(f=u,a&&a.copy(n),r&&r.copy(e))}return this.closestPointToPoint(c,n),u=c.distanceToSquared(n),u<f&&(f=u,a&&a.copy(n),r&&r.copy(c)),this.closestPointToPoint(o,n),u=o.distanceToSquared(n),u<f&&(f=u,a&&a.copy(n),r&&r.copy(o)),Math.sqrt(f)}}();Z.prototype.intersectsTriangle=function(){const n=new Z,e=new Array(3),t=new Array(3),s=new tt,i=new tt,a=new z,r=new z,c=new z,o=new z,p=new z,u=new G,f=new G,l=new G,d=new z;function A(T,h,m){const y=T.points;let x=0,w=-1;for(let g=0;g<3;g++){const{start:B,end:b}=u;B.copy(y[g]),b.copy(y[(g+1)%3]),u.delta(r);const P=ie(h.distanceToPoint(B));if(ie(h.normal.dot(r))&&P){m.copy(u),x=2;break}const _=h.intersectLine(u,d);if(!_&&P&&d.copy(B),(_||P)&&!ie(d.distanceTo(b))){if(x<=1)(x===1?m.start:m.end).copy(d),P&&(w=x);else if(x>=2){(w===1?m.start:m.end).copy(d),x=2;break}if(x++,x===2&&w===-1)break}}return x}return function(h,m=null,y=!1){this.needsUpdate&&this.update(),h.isExtendedTriangle?h.needsUpdate&&h.update():(n.copy(h),n.update(),h=n);const x=this.plane,w=h.plane;if(Math.abs(x.normal.dot(w.normal))>1-1e-10){const g=this.satBounds,B=this.satAxes;t[0]=h.a,t[1]=h.b,t[2]=h.c;for(let _=0;_<4;_++){const M=g[_],C=B[_];if(s.setFromPoints(C,t),M.isSeparated(s))return!1}const b=h.satBounds,P=h.satAxes;e[0]=this.a,e[1]=this.b,e[2]=this.c;for(let _=0;_<4;_++){const M=b[_],C=P[_];if(s.setFromPoints(C,e),M.isSeparated(s))return!1}for(let _=0;_<4;_++){const M=B[_];for(let C=0;C<4;C++){const S=P[C];if(a.crossVectors(M,S),s.setFromPoints(a,e),i.setFromPoints(a,t),s.isSeparated(i))return!1}}return m&&(y||console.warn("ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0."),m.start.set(0,0,0),m.end.set(0,0,0)),!0}else{const g=A(this,w,f);if(g===1&&h.containsPoint(f.end))return m&&(m.start.copy(f.end),m.end.copy(f.end)),!0;if(g!==2)return!1;const B=A(h,x,l);if(B===1&&this.containsPoint(l.end))return m&&(m.start.copy(l.end),m.end.copy(l.end)),!0;if(B!==2)return!1;if(f.delta(c),l.delta(o),c.dot(o)<0){let v=l.start;l.start=l.end,l.end=v}const b=f.start.dot(c),P=f.end.dot(c),_=l.start.dot(c),M=l.end.dot(c),C=P<_,S=b<M;return b!==M&&_!==P&&C===S?!1:(m&&(p.subVectors(f.start,l.start),p.dot(c)>0?m.start.copy(f.start):m.start.copy(l.start),p.subVectors(f.end,l.end),p.dot(c)<0?m.end.copy(f.end):m.end.copy(l.end)),!0)}}}();Z.prototype.distanceToPoint=function(){const n=new z;return function(t){return this.closestPointToPoint(t,n),t.distanceTo(n)}}();Z.prototype.distanceToTriangle=function(){const n=new z,e=new z,t=["a","b","c"],s=new G,i=new G;return function(r,c=null,o=null){const p=c||o?s:null;if(this.intersectsTriangle(r,p))return(c||o)&&(c&&p.getCenter(c),o&&p.getCenter(o)),0;let u=1/0;for(let f=0;f<3;f++){let l;const d=t[f],A=r[d];this.closestPointToPoint(A,n),l=A.distanceToSquared(n),l<u&&(u=l,c&&c.copy(n),o&&o.copy(A));const T=this[d];r.closestPointToPoint(T,n),l=T.distanceToSquared(n),l<u&&(u=l,c&&c.copy(T),o&&o.copy(n))}for(let f=0;f<3;f++){const l=t[f],d=t[(f+1)%3];s.set(this[l],this[d]);for(let A=0;A<3;A++){const T=t[A],h=t[(A+1)%3];i.set(r[T],r[h]),Te(s,i,n,e);const m=n.distanceToSquared(e);m<u&&(u=m,c&&c.copy(n),o&&o.copy(e))}}return Math.sqrt(u)}}();class k{constructor(e,t,s){this.isOrientedBox=!0,this.min=new z,this.max=new z,this.matrix=new ot,this.invMatrix=new ot,this.points=new Array(8).fill().map(()=>new z),this.satAxes=new Array(3).fill().map(()=>new z),this.satBounds=new Array(3).fill().map(()=>new tt),this.alignedSatBounds=new Array(3).fill().map(()=>new tt),this.needsUpdate=!1,e&&this.min.copy(e),t&&this.max.copy(t),s&&this.matrix.copy(s)}set(e,t,s){this.min.copy(e),this.max.copy(t),this.matrix.copy(s),this.needsUpdate=!0}copy(e){this.min.copy(e.min),this.max.copy(e.max),this.matrix.copy(e.matrix),this.needsUpdate=!0}}k.prototype.update=function(){return function(){const e=this.matrix,t=this.min,s=this.max,i=this.points;for(let p=0;p<=1;p++)for(let u=0;u<=1;u++)for(let f=0;f<=1;f++){const l=1*p|2*u|4*f,d=i[l];d.x=p?s.x:t.x,d.y=u?s.y:t.y,d.z=f?s.z:t.z,d.applyMatrix4(e)}const a=this.satBounds,r=this.satAxes,c=i[0];for(let p=0;p<3;p++){const u=r[p],f=a[p],l=1<<p,d=i[l];u.subVectors(c,d),f.setFromPoints(u,i)}const o=this.alignedSatBounds;o[0].setFromPointsField(i,"x"),o[1].setFromPointsField(i,"y"),o[2].setFromPointsField(i,"z"),this.invMatrix.copy(this.matrix).invert(),this.needsUpdate=!1}}();k.prototype.intersectsBox=function(){const n=new tt;return function(t){this.needsUpdate&&this.update();const s=t.min,i=t.max,a=this.satBounds,r=this.satAxes,c=this.alignedSatBounds;if(n.min=s.x,n.max=i.x,c[0].isSeparated(n)||(n.min=s.y,n.max=i.y,c[1].isSeparated(n))||(n.min=s.z,n.max=i.z,c[2].isSeparated(n)))return!1;for(let o=0;o<3;o++){const p=r[o],u=a[o];if(n.setFromBox(p,t),u.isSeparated(n))return!1}return!0}}();k.prototype.intersectsTriangle=function(){const n=new Z,e=new Array(3),t=new tt,s=new tt,i=new z;return function(r){this.needsUpdate&&this.update(),r.isExtendedTriangle?r.needsUpdate&&r.update():(n.copy(r),n.update(),r=n);const c=this.satBounds,o=this.satAxes;e[0]=r.a,e[1]=r.b,e[2]=r.c;for(let l=0;l<3;l++){const d=c[l],A=o[l];if(t.setFromPoints(A,e),d.isSeparated(t))return!1}const p=r.satBounds,u=r.satAxes,f=this.points;for(let l=0;l<3;l++){const d=p[l],A=u[l];if(t.setFromPoints(A,f),d.isSeparated(t))return!1}for(let l=0;l<3;l++){const d=o[l];for(let A=0;A<4;A++){const T=u[A];if(i.crossVectors(d,T),t.setFromPoints(i,e),s.setFromPoints(i,f),t.isSeparated(s))return!1}}return!0}}();k.prototype.closestPointToPoint=function(){return function(e,t){return this.needsUpdate&&this.update(),t.copy(e).applyMatrix4(this.invMatrix).clamp(this.min,this.max).applyMatrix4(this.matrix),t}}();k.prototype.distanceToPoint=function(){const n=new z;return function(t){return this.closestPointToPoint(t,n),t.distanceTo(n)}}();k.prototype.distanceToBox=function(){const n=["x","y","z"],e=new Array(12).fill().map(()=>new G),t=new Array(12).fill().map(()=>new G),s=new z,i=new z;return function(r,c=0,o=null,p=null){if(this.needsUpdate&&this.update(),this.intersectsBox(r))return(o||p)&&(r.getCenter(i),this.closestPointToPoint(i,s),r.closestPointToPoint(s,i),o&&o.copy(s),p&&p.copy(i)),0;const u=c*c,f=r.min,l=r.max,d=this.points;let A=1/0;for(let h=0;h<8;h++){const m=d[h];i.copy(m).clamp(f,l);const y=m.distanceToSquared(i);if(y<A&&(A=y,o&&o.copy(m),p&&p.copy(i),y<u))return Math.sqrt(y)}let T=0;for(let h=0;h<3;h++)for(let m=0;m<=1;m++)for(let y=0;y<=1;y++){const x=(h+1)%3,w=(h+2)%3,g=m<<x|y<<w,B=1<<h|m<<x|y<<w,b=d[g],P=d[B];e[T].set(b,P);const M=n[h],C=n[x],S=n[w],v=t[T],L=v.start,D=v.end;L[M]=f[M],L[C]=m?f[C]:l[C],L[S]=y?f[S]:l[C],D[M]=l[M],D[C]=m?f[C]:l[C],D[S]=y?f[S]:l[C],T++}for(let h=0;h<=1;h++)for(let m=0;m<=1;m++)for(let y=0;y<=1;y++){i.x=h?l.x:f.x,i.y=m?l.y:f.y,i.z=y?l.z:f.z,this.closestPointToPoint(i,s);const x=i.distanceToSquared(s);if(x<A&&(A=x,o&&o.copy(s),p&&p.copy(i),x<u))return Math.sqrt(x)}for(let h=0;h<12;h++){const m=e[h];for(let y=0;y<12;y++){const x=t[y];Te(m,x,s,i);const w=s.distanceToSquared(i);if(w<A&&(A=w,o&&o.copy(s),p&&p.copy(i),w<u))return Math.sqrt(w)}}return Math.sqrt(A)}}();class be{constructor(e){this._getNewPrimitive=e,this._primitives=[]}getPrimitive(){const e=this._primitives;return e.length===0?this._getNewPrimitive():e.pop()}releasePrimitive(e){this._primitives.push(e)}}class Hn extends be{constructor(){super(()=>new Z)}}const X=new Hn;class jn{constructor(){this.float32Array=null,this.uint16Array=null,this.uint32Array=null;const e=[];let t=null;this.setBuffer=s=>{t&&e.push(t),t=s,this.float32Array=new Float32Array(s),this.uint16Array=new Uint16Array(s),this.uint32Array=new Uint32Array(s)},this.clearBuffer=()=>{t=null,this.float32Array=null,this.uint16Array=null,this.uint32Array=null,e.length!==0&&this.setBuffer(e.pop())}}}const R=new jn;let rt,gt;const ft=[],Vt=new be(()=>new J);function Xn(n,e,t,s,i,a){rt=Vt.getPrimitive(),gt=Vt.getPrimitive(),ft.push(rt,gt),R.setBuffer(n._roots[e]);const r=de(0,n.geometry,t,s,i,a);R.clearBuffer(),Vt.releasePrimitive(rt),Vt.releasePrimitive(gt),ft.pop(),ft.pop();const c=ft.length;return c>0&&(gt=ft[c-1],rt=ft[c-2]),r}function de(n,e,t,s,i=null,a=0,r=0){const{float32Array:c,uint16Array:o,uint32Array:p}=R;let u=n*2;if(I(u,o)){const l=q(n,p),d=$(u,o);return F(n,c,rt),s(l,d,!1,r,a+n,rt)}else{let M=function(S){const{uint16Array:v,uint32Array:L}=R;let D=S*2;for(;!I(D,v);)S=H(S),D=S*2;return q(S,L)},C=function(S){const{uint16Array:v,uint32Array:L}=R;let D=S*2;for(;!I(D,v);)S=j(S,L),D=S*2;return q(S,L)+$(D,v)};const l=H(n),d=j(n,p);let A=l,T=d,h,m,y,x;if(i&&(y=rt,x=gt,F(A,c,y),F(T,c,x),h=i(y),m=i(x),m<h)){A=d,T=l;const S=h;h=m,m=S,y=x}y||(y=rt,F(A,c,y));const w=I(A*2,o),g=t(y,w,h,r+1,a+A);let B;if(g===Le){const S=M(A),L=C(A)-S;B=s(S,L,!0,r+1,a+A,y)}else B=g&&de(A,e,t,s,i,a,r+1);if(B)return!0;x=gt,F(T,c,x);const b=I(T*2,o),P=t(x,b,m,r+1,a+T);let _;if(P===Le){const S=M(T),L=C(T)-S;_=s(S,L,!0,r+1,a+T,x)}else _=P&&de(T,e,t,s,i,a,r+1);return!!_}}const Bt=new z,re=new z;function Wn(n,e,t={},s=0,i=1/0){const a=s*s,r=i*i;let c=1/0,o=null;if(n.shapecast({boundsTraverseOrder:u=>(Bt.copy(e).clamp(u.min,u.max),Bt.distanceToSquared(e)),intersectsBounds:(u,f,l)=>l<c&&l<r,intersectsTriangle:(u,f)=>{u.closestPointToPoint(e,Bt);const l=e.distanceToSquared(Bt);return l<c&&(re.copy(Bt),c=l,o=f),l<a}}),c===1/0)return null;const p=Math.sqrt(c);return t.point?t.point.copy(re):t.point=re.clone(),t.distance=p,t.faceIndex=o,t}const Zn=parseInt(nn)>=169,at=new z,lt=new z,ut=new z,Nt=new At,kt=new At,It=new At,Fe=new z,Ee=new z,Ve=new z,vt=new z;function Yn(n,e,t,s,i,a,r,c){let o;if(a===tn?o=n.intersectTriangle(s,t,e,!0,i):o=n.intersectTriangle(e,t,s,a!==en,i),o===null)return null;const p=n.origin.distanceTo(i);return p<r||p>c?null:{distance:p,point:i.clone()}}function Kn(n,e,t,s,i,a,r,c,o,p,u){at.fromBufferAttribute(e,a),lt.fromBufferAttribute(e,r),ut.fromBufferAttribute(e,c);const f=Yn(n,at,lt,ut,vt,o,p,u);if(f){const l=new z;wt.getBarycoord(vt,at,lt,ut,l),s&&(Nt.fromBufferAttribute(s,a),kt.fromBufferAttribute(s,r),It.fromBufferAttribute(s,c),f.uv=wt.getInterpolation(vt,at,lt,ut,Nt,kt,It,new At)),i&&(Nt.fromBufferAttribute(i,a),kt.fromBufferAttribute(i,r),It.fromBufferAttribute(i,c),f.uv1=wt.getInterpolation(vt,at,lt,ut,Nt,kt,It,new At)),t&&(Fe.fromBufferAttribute(t,a),Ee.fromBufferAttribute(t,r),Ve.fromBufferAttribute(t,c),f.normal=wt.getInterpolation(vt,at,lt,ut,Fe,Ee,Ve,new z),f.normal.dot(n.direction)>0&&f.normal.multiplyScalar(-1));const d={a,b:r,c,normal:new z,materialIndex:0};wt.getNormal(at,lt,ut,d.normal),f.face=d,f.faceIndex=a,Zn&&(f.barycoord=l)}return f}function Gt(n,e,t,s,i,a,r){const c=s*3;let o=c+0,p=c+1,u=c+2;const f=n.index;n.index&&(o=f.getX(o),p=f.getX(p),u=f.getX(u));const{position:l,normal:d,uv:A,uv1:T}=n.attributes,h=Kn(t,l,d,A,T,o,p,u,e,a,r);return h?(h.faceIndex=s,i&&i.push(h),h):null}function E(n,e,t,s){const i=n.a,a=n.b,r=n.c;let c=e,o=e+1,p=e+2;t&&(c=t.getX(c),o=t.getX(o),p=t.getX(p)),i.x=s.getX(c),i.y=s.getY(c),i.z=s.getZ(c),a.x=s.getX(o),a.y=s.getY(o),a.z=s.getZ(o),r.x=s.getX(p),r.y=s.getY(p),r.z=s.getZ(p)}function Qn(n,e,t,s,i,a,r,c){const{geometry:o,_indirectBuffer:p}=n;for(let u=s,f=s+i;u<f;u++)Gt(o,e,t,u,a,r,c)}function Jn(n,e,t,s,i,a,r){const{geometry:c,_indirectBuffer:o}=n;let p=1/0,u=null;for(let f=s,l=s+i;f<l;f++){let d;d=Gt(c,e,t,f,null,a,r),d&&d.distance<p&&(u=d,p=d.distance)}return u}function On(n,e,t,s,i,a,r){const{geometry:c}=t,{index:o}=c,p=c.attributes.position;for(let u=n,f=e+n;u<f;u++){let l;if(l=u,E(r,l*3,o,p),r.needsUpdate=!0,s(r,l,i,a))return!0}return!1}function Gn(n,e=null){e&&Array.isArray(e)&&(e=new Set(e));const t=n.geometry,s=t.index?t.index.array:null,i=t.attributes.position;let a,r,c,o,p=0;const u=n._roots;for(let l=0,d=u.length;l<d;l++)a=u[l],r=new Uint32Array(a),c=new Uint16Array(a),o=new Float32Array(a),f(0,p),p+=a.byteLength;function f(l,d,A=!1){const T=l*2;if(c[T+15]===Ot){const m=r[l+6],y=c[T+14];let x=1/0,w=1/0,g=1/0,B=-1/0,b=-1/0,P=-1/0;for(let _=3*m,M=3*(m+y);_<M;_++){let C=s[_];const S=i.getX(C),v=i.getY(C),L=i.getZ(C);S<x&&(x=S),S>B&&(B=S),v<w&&(w=v),v>b&&(b=v),L<g&&(g=L),L>P&&(P=L)}return o[l+0]!==x||o[l+1]!==w||o[l+2]!==g||o[l+3]!==B||o[l+4]!==b||o[l+5]!==P?(o[l+0]=x,o[l+1]=w,o[l+2]=g,o[l+3]=B,o[l+4]=b,o[l+5]=P,!0):!1}else{const m=l+8,y=r[l+6],x=m+d,w=y+d;let g=A,B=!1,b=!1;e?g||(B=e.has(x),b=e.has(w),g=!B&&!b):(B=!0,b=!0);const P=g||B,_=g||b;let M=!1;P&&(M=f(m,d,g));let C=!1;_&&(C=f(y,d,g));const S=M||C;if(S)for(let v=0;v<3;v++){const L=m+v,D=y+v,U=o[L],N=o[L+3],Y=o[D],K=o[D+3];o[l+v]=U<Y?U:Y,o[l+v+3]=N>K?N:K}return S}}}function ct(n,e,t,s,i){let a,r,c,o,p,u;const f=1/t.direction.x,l=1/t.direction.y,d=1/t.direction.z,A=t.origin.x,T=t.origin.y,h=t.origin.z;let m=e[n],y=e[n+3],x=e[n+1],w=e[n+3+1],g=e[n+2],B=e[n+3+2];return f>=0?(a=(m-A)*f,r=(y-A)*f):(a=(y-A)*f,r=(m-A)*f),l>=0?(c=(x-T)*l,o=(w-T)*l):(c=(w-T)*l,o=(x-T)*l),a>o||c>r||((c>a||isNaN(a))&&(a=c),(o<r||isNaN(r))&&(r=o),d>=0?(p=(g-h)*d,u=(B-h)*d):(p=(B-h)*d,u=(g-h)*d),a>u||p>r)?!1:((p>a||a!==a)&&(a=p),(u<r||r!==r)&&(r=u),a<=i&&r>=s)}function ts(n,e,t,s,i,a,r,c){const{geometry:o,_indirectBuffer:p}=n;for(let u=s,f=s+i;u<f;u++){let l=p?p[u]:u;Gt(o,e,t,l,a,r,c)}}function es(n,e,t,s,i,a,r){const{geometry:c,_indirectBuffer:o}=n;let p=1/0,u=null;for(let f=s,l=s+i;f<l;f++){let d;d=Gt(c,e,t,o?o[f]:f,null,a,r),d&&d.distance<p&&(u=d,p=d.distance)}return u}function ns(n,e,t,s,i,a,r){const{geometry:c}=t,{index:o}=c,p=c.attributes.position;for(let u=n,f=e+n;u<f;u++){let l;if(l=t.resolveTriangleIndex(u),E(r,l*3,o,p),r.needsUpdate=!0,s(r,l,i,a))return!0}return!1}function ss(n,e,t,s,i,a,r){R.setBuffer(n._roots[e]),ye(0,n,t,s,i,a,r),R.clearBuffer()}function ye(n,e,t,s,i,a,r){const{float32Array:c,uint16Array:o,uint32Array:p}=R,u=n*2;if(I(u,o)){const l=q(n,p),d=$(u,o);Qn(e,t,s,l,d,i,a,r)}else{const l=H(n);ct(l,c,s,a,r)&&ye(l,e,t,s,i,a,r);const d=j(n,p);ct(d,c,s,a,r)&&ye(d,e,t,s,i,a,r)}}const is=["x","y","z"];function rs(n,e,t,s,i,a){R.setBuffer(n._roots[e]);const r=me(0,n,t,s,i,a);return R.clearBuffer(),r}function me(n,e,t,s,i,a){const{float32Array:r,uint16Array:c,uint32Array:o}=R;let p=n*2;if(I(p,c)){const f=q(n,o),l=$(p,c);return Jn(e,t,s,f,l,i,a)}else{const f=Je(n,o),l=is[f],A=s.direction[l]>=0;let T,h;A?(T=H(n),h=j(n,o)):(T=j(n,o),h=H(n));const y=ct(T,r,s,i,a)?me(T,e,t,s,i,a):null;if(y){const g=y.point[l];if(A?g<=r[h+f]:g>=r[h+f+3])return y}const w=ct(h,r,s,i,a)?me(h,e,t,s,i,a):null;return y&&w?y.distance<=w.distance?y:w:y||w||null}}const qt=new J,pt=new Z,dt=new Z,Pt=new ot,Ne=new k,$t=new k;function os(n,e,t,s){R.setBuffer(n._roots[e]);const i=he(0,n,t,s);return R.clearBuffer(),i}function he(n,e,t,s,i=null){const{float32Array:a,uint16Array:r,uint32Array:c}=R;let o=n*2;if(i===null&&(t.boundingBox||t.computeBoundingBox(),Ne.set(t.boundingBox.min,t.boundingBox.max,s),i=Ne),I(o,r)){const u=e.geometry,f=u.index,l=u.attributes.position,d=t.index,A=t.attributes.position,T=q(n,c),h=$(o,r);if(Pt.copy(s).invert(),t.boundsTree)return F(n,a,$t),$t.matrix.copy(Pt),$t.needsUpdate=!0,t.boundsTree.shapecast({intersectsBounds:y=>$t.intersectsBox(y),intersectsTriangle:y=>{y.a.applyMatrix4(s),y.b.applyMatrix4(s),y.c.applyMatrix4(s),y.needsUpdate=!0;for(let x=T*3,w=(h+T)*3;x<w;x+=3)if(E(dt,x,f,l),dt.needsUpdate=!0,y.intersectsTriangle(dt))return!0;return!1}});for(let m=T*3,y=(h+T)*3;m<y;m+=3){E(pt,m,f,l),pt.a.applyMatrix4(Pt),pt.b.applyMatrix4(Pt),pt.c.applyMatrix4(Pt),pt.needsUpdate=!0;for(let x=0,w=d.count;x<w;x+=3)if(E(dt,x,d,A),dt.needsUpdate=!0,pt.intersectsTriangle(dt))return!0}}else{const u=n+8,f=c[n+6];return F(u,a,qt),!!(i.intersectsBox(qt)&&he(u,e,t,s,i)||(F(f,a,qt),i.intersectsBox(qt)&&he(f,e,t,s,i)))}}const Ht=new ot,oe=new k,_t=new k,cs=new z,as=new z,ls=new z,us=new z;function fs(n,e,t,s={},i={},a=0,r=1/0){e.boundingBox||e.computeBoundingBox(),oe.set(e.boundingBox.min,e.boundingBox.max,t),oe.needsUpdate=!0;const c=n.geometry,o=c.attributes.position,p=c.index,u=e.attributes.position,f=e.index,l=X.getPrimitive(),d=X.getPrimitive();let A=cs,T=as,h=null,m=null;i&&(h=ls,m=us);let y=1/0,x=null,w=null;return Ht.copy(t).invert(),_t.matrix.copy(Ht),n.shapecast({boundsTraverseOrder:g=>oe.distanceToBox(g),intersectsBounds:(g,B,b)=>b<y&&b<r?(B&&(_t.min.copy(g.min),_t.max.copy(g.max),_t.needsUpdate=!0),!0):!1,intersectsRange:(g,B)=>{if(e.boundsTree)return e.boundsTree.shapecast({boundsTraverseOrder:P=>_t.distanceToBox(P),intersectsBounds:(P,_,M)=>M<y&&M<r,intersectsRange:(P,_)=>{for(let M=P,C=P+_;M<C;M++){E(d,3*M,f,u),d.a.applyMatrix4(t),d.b.applyMatrix4(t),d.c.applyMatrix4(t),d.needsUpdate=!0;for(let S=g,v=g+B;S<v;S++){E(l,3*S,p,o),l.needsUpdate=!0;const L=l.distanceToTriangle(d,A,h);if(L<y&&(T.copy(A),m&&m.copy(h),y=L,x=S,w=M),L<a)return!0}}}});{const b=Tt(e);for(let P=0,_=b;P<_;P++){E(d,3*P,f,u),d.a.applyMatrix4(t),d.b.applyMatrix4(t),d.c.applyMatrix4(t),d.needsUpdate=!0;for(let M=g,C=g+B;M<C;M++){E(l,3*M,p,o),l.needsUpdate=!0;const S=l.distanceToTriangle(d,A,h);if(S<y&&(T.copy(A),m&&m.copy(h),y=S,x=M,w=P),S<a)return!0}}}}}),X.releasePrimitive(l),X.releasePrimitive(d),y===1/0?null:(s.point?s.point.copy(T):s.point=T.clone(),s.distance=y,s.faceIndex=x,i&&(i.point?i.point.copy(m):i.point=m.clone(),i.point.applyMatrix4(Ht),T.applyMatrix4(Ht),i.distance=T.sub(i.point).length(),i.faceIndex=w),s)}function ps(n,e=null){e&&Array.isArray(e)&&(e=new Set(e));const t=n.geometry,s=t.index?t.index.array:null,i=t.attributes.position;let a,r,c,o,p=0;const u=n._roots;for(let l=0,d=u.length;l<d;l++)a=u[l],r=new Uint32Array(a),c=new Uint16Array(a),o=new Float32Array(a),f(0,p),p+=a.byteLength;function f(l,d,A=!1){const T=l*2;if(c[T+15]===Ot){const m=r[l+6],y=c[T+14];let x=1/0,w=1/0,g=1/0,B=-1/0,b=-1/0,P=-1/0;for(let _=m,M=m+y;_<M;_++){const C=3*n.resolveTriangleIndex(_);for(let S=0;S<3;S++){let v=C+S;v=s?s[v]:v;const L=i.getX(v),D=i.getY(v),U=i.getZ(v);L<x&&(x=L),L>B&&(B=L),D<w&&(w=D),D>b&&(b=D),U<g&&(g=U),U>P&&(P=U)}}return o[l+0]!==x||o[l+1]!==w||o[l+2]!==g||o[l+3]!==B||o[l+4]!==b||o[l+5]!==P?(o[l+0]=x,o[l+1]=w,o[l+2]=g,o[l+3]=B,o[l+4]=b,o[l+5]=P,!0):!1}else{const m=l+8,y=r[l+6],x=m+d,w=y+d;let g=A,B=!1,b=!1;e?g||(B=e.has(x),b=e.has(w),g=!B&&!b):(B=!0,b=!0);const P=g||B,_=g||b;let M=!1;P&&(M=f(m,d,g));let C=!1;_&&(C=f(y,d,g));const S=M||C;if(S)for(let v=0;v<3;v++){const L=m+v,D=y+v,U=o[L],N=o[L+3],Y=o[D],K=o[D+3];o[l+v]=U<Y?U:Y,o[l+v+3]=N>K?N:K}return S}}}function ds(n,e,t,s,i,a,r){R.setBuffer(n._roots[e]),xe(0,n,t,s,i,a,r),R.clearBuffer()}function xe(n,e,t,s,i,a,r){const{float32Array:c,uint16Array:o,uint32Array:p}=R,u=n*2;if(I(u,o)){const l=q(n,p),d=$(u,o);ts(e,t,s,l,d,i,a,r)}else{const l=H(n);ct(l,c,s,a,r)&&xe(l,e,t,s,i,a,r);const d=j(n,p);ct(d,c,s,a,r)&&xe(d,e,t,s,i,a,r)}}const ys=["x","y","z"];function ms(n,e,t,s,i,a){R.setBuffer(n._roots[e]);const r=we(0,n,t,s,i,a);return R.clearBuffer(),r}function we(n,e,t,s,i,a){const{float32Array:r,uint16Array:c,uint32Array:o}=R;let p=n*2;if(I(p,c)){const f=q(n,o),l=$(p,c);return es(e,t,s,f,l,i,a)}else{const f=Je(n,o),l=ys[f],A=s.direction[l]>=0;let T,h;A?(T=H(n),h=j(n,o)):(T=j(n,o),h=H(n));const y=ct(T,r,s,i,a)?we(T,e,t,s,i,a):null;if(y){const g=y.point[l];if(A?g<=r[h+f]:g>=r[h+f+3])return y}const w=ct(h,r,s,i,a)?we(h,e,t,s,i,a):null;return y&&w?y.distance<=w.distance?y:w:y||w||null}}const jt=new J,yt=new Z,mt=new Z,St=new ot,ke=new k,Xt=new k;function hs(n,e,t,s){R.setBuffer(n._roots[e]);const i=ge(0,n,t,s);return R.clearBuffer(),i}function ge(n,e,t,s,i=null){const{float32Array:a,uint16Array:r,uint32Array:c}=R;let o=n*2;if(i===null&&(t.boundingBox||t.computeBoundingBox(),ke.set(t.boundingBox.min,t.boundingBox.max,s),i=ke),I(o,r)){const u=e.geometry,f=u.index,l=u.attributes.position,d=t.index,A=t.attributes.position,T=q(n,c),h=$(o,r);if(St.copy(s).invert(),t.boundsTree)return F(n,a,Xt),Xt.matrix.copy(St),Xt.needsUpdate=!0,t.boundsTree.shapecast({intersectsBounds:y=>Xt.intersectsBox(y),intersectsTriangle:y=>{y.a.applyMatrix4(s),y.b.applyMatrix4(s),y.c.applyMatrix4(s),y.needsUpdate=!0;for(let x=T,w=h+T;x<w;x++)if(E(mt,3*e.resolveTriangleIndex(x),f,l),mt.needsUpdate=!0,y.intersectsTriangle(mt))return!0;return!1}});for(let m=T,y=h+T;m<y;m++){const x=e.resolveTriangleIndex(m);E(yt,3*x,f,l),yt.a.applyMatrix4(St),yt.b.applyMatrix4(St),yt.c.applyMatrix4(St),yt.needsUpdate=!0;for(let w=0,g=d.count;w<g;w+=3)if(E(mt,w,d,A),mt.needsUpdate=!0,yt.intersectsTriangle(mt))return!0}}else{const u=n+8,f=c[n+6];return F(u,a,jt),!!(i.intersectsBox(jt)&&ge(u,e,t,s,i)||(F(f,a,jt),i.intersectsBox(jt)&&ge(f,e,t,s,i)))}}const Wt=new ot,ce=new k,Mt=new k,xs=new z,ws=new z,gs=new z,As=new z;function Ts(n,e,t,s={},i={},a=0,r=1/0){e.boundingBox||e.computeBoundingBox(),ce.set(e.boundingBox.min,e.boundingBox.max,t),ce.needsUpdate=!0;const c=n.geometry,o=c.attributes.position,p=c.index,u=e.attributes.position,f=e.index,l=X.getPrimitive(),d=X.getPrimitive();let A=xs,T=ws,h=null,m=null;i&&(h=gs,m=As);let y=1/0,x=null,w=null;return Wt.copy(t).invert(),Mt.matrix.copy(Wt),n.shapecast({boundsTraverseOrder:g=>ce.distanceToBox(g),intersectsBounds:(g,B,b)=>b<y&&b<r?(B&&(Mt.min.copy(g.min),Mt.max.copy(g.max),Mt.needsUpdate=!0),!0):!1,intersectsRange:(g,B)=>{if(e.boundsTree){const b=e.boundsTree;return b.shapecast({boundsTraverseOrder:P=>Mt.distanceToBox(P),intersectsBounds:(P,_,M)=>M<y&&M<r,intersectsRange:(P,_)=>{for(let M=P,C=P+_;M<C;M++){const S=b.resolveTriangleIndex(M);E(d,3*S,f,u),d.a.applyMatrix4(t),d.b.applyMatrix4(t),d.c.applyMatrix4(t),d.needsUpdate=!0;for(let v=g,L=g+B;v<L;v++){const D=n.resolveTriangleIndex(v);E(l,3*D,p,o),l.needsUpdate=!0;const U=l.distanceToTriangle(d,A,h);if(U<y&&(T.copy(A),m&&m.copy(h),y=U,x=v,w=M),U<a)return!0}}}})}else{const b=Tt(e);for(let P=0,_=b;P<_;P++){E(d,3*P,f,u),d.a.applyMatrix4(t),d.b.applyMatrix4(t),d.c.applyMatrix4(t),d.needsUpdate=!0;for(let M=g,C=g+B;M<C;M++){const S=n.resolveTriangleIndex(M);E(l,3*S,p,o),l.needsUpdate=!0;const v=l.distanceToTriangle(d,A,h);if(v<y&&(T.copy(A),m&&m.copy(h),y=v,x=M,w=P),v<a)return!0}}}}}),X.releasePrimitive(l),X.releasePrimitive(d),y===1/0?null:(s.point?s.point.copy(T):s.point=T.clone(),s.distance=y,s.faceIndex=x,i&&(i.point?i.point.copy(m):i.point=m.clone(),i.point.applyMatrix4(Wt),T.applyMatrix4(Wt),i.distance=T.sub(i.point).length(),i.faceIndex=w),s)}function bs(){return typeof SharedArrayBuffer<"u"}const zt=new R.constructor,Jt=new R.constructor,it=new be(()=>new J),ht=new J,xt=new J,ae=new J,le=new J;let ue=!1;function Bs(n,e,t,s){if(ue)throw new Error("MeshBVH: Recursive calls to bvhcast not supported.");ue=!0;const i=n._roots,a=e._roots;let r,c=0,o=0;const p=new ot().copy(t).invert();for(let u=0,f=i.length;u<f;u++){zt.setBuffer(i[u]),o=0;const l=it.getPrimitive();F(0,zt.float32Array,l),l.applyMatrix4(p);for(let d=0,A=a.length;d<A&&(Jt.setBuffer(a[d]),r=W(0,0,t,p,s,c,o,0,0,l),Jt.clearBuffer(),o+=a[d].length,!r);d++);if(it.releasePrimitive(l),zt.clearBuffer(),c+=i[u].length,r)break}return ue=!1,r}function W(n,e,t,s,i,a=0,r=0,c=0,o=0,p=null,u=!1){let f,l;u?(f=Jt,l=zt):(f=zt,l=Jt);const d=f.float32Array,A=f.uint32Array,T=f.uint16Array,h=l.float32Array,m=l.uint32Array,y=l.uint16Array,x=n*2,w=e*2,g=I(x,T),B=I(w,y);let b=!1;if(B&&g)u?b=i(q(e,m),$(e*2,y),q(n,A),$(n*2,T),o,r+e,c,a+n):b=i(q(n,A),$(n*2,T),q(e,m),$(e*2,y),c,a+n,o,r+e);else if(B){const P=it.getPrimitive();F(e,h,P),P.applyMatrix4(t);const _=H(n),M=j(n,A);F(_,d,ht),F(M,d,xt);const C=P.intersectsBox(ht),S=P.intersectsBox(xt);b=C&&W(e,_,s,t,i,r,a,o,c+1,P,!u)||S&&W(e,M,s,t,i,r,a,o,c+1,P,!u),it.releasePrimitive(P)}else{const P=H(e),_=j(e,m);F(P,h,ae),F(_,h,le);const M=p.intersectsBox(ae),C=p.intersectsBox(le);if(M&&C)b=W(n,P,t,s,i,a,r,c,o+1,p,u)||W(n,_,t,s,i,a,r,c,o+1,p,u);else if(M)if(g)b=W(n,P,t,s,i,a,r,c,o+1,p,u);else{const S=it.getPrimitive();S.copy(ae).applyMatrix4(t);const v=H(n),L=j(n,A);F(v,d,ht),F(L,d,xt);const D=S.intersectsBox(ht),U=S.intersectsBox(xt);b=D&&W(P,v,s,t,i,r,a,o,c+1,S,!u)||U&&W(P,L,s,t,i,r,a,o,c+1,S,!u),it.releasePrimitive(S)}else if(C)if(g)b=W(n,_,t,s,i,a,r,c,o+1,p,u);else{const S=it.getPrimitive();S.copy(le).applyMatrix4(t);const v=H(n),L=j(n,A);F(v,d,ht),F(L,d,xt);const D=S.intersectsBox(ht),U=S.intersectsBox(xt);b=D&&W(_,v,s,t,i,r,a,o,c+1,S,!u)||U&&W(_,L,s,t,i,r,a,o,c+1,S,!u),it.releasePrimitive(S)}}return b}const Zt=new k,Ie=new J,vs={strategy:Ye,maxDepth:40,maxLeafTris:10,useSharedArrayBuffer:!1,setBoundingBox:!0,onProgress:null,indirect:!1,verbose:!0,range:null};class Be{static serialize(e,t={}){t={cloneBuffers:!0,...t};const s=e.geometry,i=e._roots,a=e._indirectBuffer,r=s.getIndex();let c;return t.cloneBuffers?c={roots:i.map(o=>o.slice()),index:r?r.array.slice():null,indirectBuffer:a?a.slice():null}:c={roots:i,index:r?r.array:null,indirectBuffer:a},c}static deserialize(e,t,s={}){s={setIndex:!0,indirect:!!e.indirectBuffer,...s};const{index:i,roots:a,indirectBuffer:r}=e,c=new Be(t,{...s,[ee]:!0});if(c._roots=a,c._indirectBuffer=r||null,s.setIndex){const o=t.getIndex();if(o===null){const p=new Xe(e.index,1,!1);t.setIndex(p)}else o.array!==i&&(o.array.set(i),o.needsUpdate=!0)}return c}get indirect(){return!!this._indirectBuffer}constructor(e,t={}){if(e.isBufferGeometry){if(e.index&&e.index.isInterleavedBufferAttribute)throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.")}else throw new Error("MeshBVH: Only BufferGeometries are supported.");if(t=Object.assign({...vs,[ee]:!1},t),t.useSharedArrayBuffer&&!bs())throw new Error("MeshBVH: SharedArrayBuffer is not available.");this.geometry=e,this._roots=null,this._indirectBuffer=null,t[ee]||(kn(this,t),!e.boundingBox&&t.setBoundingBox&&(e.boundingBox=this.getBoundingBox(new J))),this.resolveTriangleIndex=t.indirect?s=>this._indirectBuffer[s]:s=>s}refit(e=null){return(this.indirect?ps:Gn)(this,e)}traverse(e,t=0){const s=this._roots[t],i=new Uint32Array(s),a=new Uint16Array(s);r(0);function r(c,o=0){const p=c*2,u=a[p+15]===Ot;if(u){const f=i[c+6],l=a[p+14];e(o,u,new Float32Array(s,c*4,6),f,l)}else{const f=c+Lt/4,l=i[c+6],d=i[c+7];e(o,u,new Float32Array(s,c*4,6),d)||(r(f,o+1),r(l,o+1))}}}raycast(e,t=_e,s=0,i=1/0){const a=this._roots,r=this.geometry,c=[],o=t.isMaterial,p=Array.isArray(t),u=r.groups,f=o?t.side:t,l=this.indirect?ds:ss;for(let d=0,A=a.length;d<A;d++){const T=p?t[u[d].materialIndex].side:f,h=c.length;if(l(this,d,T,e,c,s,i),p){const m=u[d].materialIndex;for(let y=h,x=c.length;y<x;y++)c[y].face.materialIndex=m}}return c}raycastFirst(e,t=_e,s=0,i=1/0){const a=this._roots,r=this.geometry,c=t.isMaterial,o=Array.isArray(t);let p=null;const u=r.groups,f=c?t.side:t,l=this.indirect?ms:rs;for(let d=0,A=a.length;d<A;d++){const T=o?t[u[d].materialIndex].side:f,h=l(this,d,T,e,s,i);h!=null&&(p==null||h.distance<p.distance)&&(p=h,o&&(h.face.materialIndex=u[d].materialIndex))}return p}intersectsGeometry(e,t){let s=!1;const i=this._roots,a=this.indirect?hs:os;for(let r=0,c=i.length;r<c&&(s=a(this,r,e,t),!s);r++);return s}shapecast(e){const t=X.getPrimitive(),s=this.indirect?ns:On;let{boundsTraverseOrder:i,intersectsBounds:a,intersectsRange:r,intersectsTriangle:c}=e;if(r&&c){const f=r;r=(l,d,A,T,h)=>f(l,d,A,T,h)?!0:s(l,d,this,c,A,T,t)}else r||(c?r=(f,l,d,A)=>s(f,l,this,c,d,A,t):r=(f,l,d)=>d);let o=!1,p=0;const u=this._roots;for(let f=0,l=u.length;f<l;f++){const d=u[f];if(o=Xn(this,f,a,r,i,p),o)break;p+=d.byteLength}return X.releasePrimitive(t),o}bvhcast(e,t,s){let{intersectsRanges:i,intersectsTriangles:a}=s;const r=X.getPrimitive(),c=this.geometry.index,o=this.geometry.attributes.position,p=this.indirect?A=>{const T=this.resolveTriangleIndex(A);E(r,T*3,c,o)}:A=>{E(r,A*3,c,o)},u=X.getPrimitive(),f=e.geometry.index,l=e.geometry.attributes.position,d=e.indirect?A=>{const T=e.resolveTriangleIndex(A);E(u,T*3,f,l)}:A=>{E(u,A*3,f,l)};if(a){const A=(T,h,m,y,x,w,g,B)=>{for(let b=m,P=m+y;b<P;b++){d(b),u.a.applyMatrix4(t),u.b.applyMatrix4(t),u.c.applyMatrix4(t),u.needsUpdate=!0;for(let _=T,M=T+h;_<M;_++)if(p(_),r.needsUpdate=!0,a(r,u,_,b,x,w,g,B))return!0}return!1};if(i){const T=i;i=function(h,m,y,x,w,g,B,b){return T(h,m,y,x,w,g,B,b)?!0:A(h,m,y,x,w,g,B,b)}}else i=A}return Bs(this,e,t,i)}intersectsBox(e,t){return Zt.set(e.min,e.max,t),Zt.needsUpdate=!0,this.shapecast({intersectsBounds:s=>Zt.intersectsBox(s),intersectsTriangle:s=>Zt.intersectsTriangle(s)})}intersectsSphere(e){return this.shapecast({intersectsBounds:t=>e.intersectsBox(t),intersectsTriangle:t=>t.intersectsSphere(e)})}closestPointToGeometry(e,t,s={},i={},a=0,r=1/0){return(this.indirect?Ts:fs)(this,e,t,s,i,a,r)}closestPointToPoint(e,t={},s=0,i=1/0){return Wn(this,e,t,s,i)}getBoundingBox(e){return e.makeEmpty(),this._roots.forEach(s=>{F(0,new Float32Array(s),Ie),e.union(Ie)}),e}}function qe(n,e,t){return n===null?null:(n.point.applyMatrix4(e.matrixWorld),n.distance=n.point.distanceTo(t.ray.origin),n.object=e,n)}const Yt=new rn,$e=new z,He=new ot,Ps=Ae.prototype.raycast,_s=sn.prototype.raycast,je=new z,V=new Ae,Kt=[];function Ss(n,e){this.isBatchedMesh?Ms.call(this,n,e):Cs.call(this,n,e)}function Ms(n,e){if(this.boundsTrees){const t=this.boundsTrees,s=this._drawInfo||this._instanceInfo,i=this._drawRanges||this._geometryInfo,a=this.matrixWorld;V.material=this.material,V.geometry=this.geometry;const r=V.geometry.boundsTree,c=V.geometry.drawRange;V.geometry.boundingSphere===null&&(V.geometry.boundingSphere=new Ze);for(let o=0,p=s.length;o<p;o++){if(!this.getVisibleAt(o))continue;const u=s[o].geometryIndex;if(V.geometry.boundsTree=t[u],this.getMatrixAt(o,V.matrixWorld).premultiply(a),!V.geometry.boundsTree){this.getBoundingBoxAt(u,V.geometry.boundingBox),this.getBoundingSphereAt(u,V.geometry.boundingSphere);const f=i[u];V.geometry.setDrawRange(f.start,f.count)}V.raycast(n,Kt);for(let f=0,l=Kt.length;f<l;f++){const d=Kt[f];d.object=this,d.batchId=o,e.push(d)}Kt.length=0}V.geometry.boundsTree=r,V.geometry.drawRange=c,V.material=null,V.geometry=null}else _s.call(this,n,e)}function Cs(n,e){if(this.geometry.boundsTree){if(this.material===void 0)return;He.copy(this.matrixWorld).invert(),Yt.copy(n.ray).applyMatrix4(He),je.setFromMatrixScale(this.matrixWorld),$e.copy(Yt.direction).multiply(je);const t=$e.length(),s=n.near/t,i=n.far/t,a=this.geometry.boundsTree;if(n.firstHitOnly===!0){const r=qe(a.raycastFirst(Yt,this.material,s,i),this,n);r&&e.push(r)}else{const r=a.raycast(Yt,this.material,s,i);for(let c=0,o=r.length;c<o;c++){const p=qe(r[c],this,n);p&&e.push(p)}}}else Ps.call(this,n,e)}function Ls(n={}){return this.boundsTree=new Be(this,n),this.boundsTree}function zs(){this.boundsTree=null}const Us=["ar","ar-modes","environment-image","exposure","autoplay","orbit-sensitivity","pan-sensitivity","poster","shadow-intensity","skybox-image","src","zoom-sensitivity"],Ds={class:"overlay-svg-wrapper"},Rs=["x1","x2","y1","y2"],Fs={key:0},Es=["height","width","x","y"],Vs=["x","y"],Ns=on({__name:"ModelViewerWrapper",props:{src:{}},setup(n,{expose:e}){cn.modelCacheSize=0,Se.prototype.computeBoundsTree=Ls,Se.prototype.disposeBoundsTree=zs,Ae.prototype.raycast=Ss;const t=n,s=Q(null),i=Q(null),a=Q(null),r=Q(null),c=Q(null);(async()=>c.value=await an)();let o,p,u=t.src.toString(),f=!1;ln(()=>{s.value&&(f||(f=!0,s.value.addEventListener("before-render",()=>{s.value&&(i.value=s.value[un],a.value=s.value[fn],r.value=s.value[pn],o&&(i.value.setTarget(-o.x,-o.y,-o.z),i.value.jumpToGoal()),(async()=>{let v=0;for(;v++<25&&!(!p||!s.value?.getCameraOrbit()?.radius);){let L=p-s.value.getCameraOrbit().radius;if(Math.abs(L)<.001)break;s.value.zoom(-Math.sign(L)*(Math.pow(Math.abs(L)+1,.9)-1)),s.value.jumpCameraToGoal(),await s.value.updateComplete}u=t.src.toString()})())}),s.value.addEventListener("camera-change",l),s.value.addEventListener("progress",v=>h(v.detail.totalProgress)),dn(s.value)))});function l(){i.value&&t.src.toString()==u&&(o=i.value.target.position.clone(),p=s.value?.getCameraOrbit()?.radius);for(let v in w.value)_(v)}const d=Q(null),A=Q(null);let T=null;const h=v=>{!d.value||!A.value||(d.value.style.display="block",d.value.style.opacity="1",A.value.style.width=`${v*100}%`,T&&clearTimeout(T),T=setTimeout(()=>{d.value&&(d.value.style.opacity="0",setTimeout(()=>{d.value&&(d.value.style.display="none")},300))},1e3))},m=Q(""),y=v=>{m.value="data:image/svg+xml;charset=utf-8;base64,"+btoa('<svg width="800" height="600" xmlns="http://www.w3.org/2000/svg" fill="gray"><text x="50%" y="0%" dominant-baseline="middle" text-anchor="middle" font-size="48px">'+v+"</text></svg>")};y("Loading...");let x=1,w=Q({});function g(v){return v.x+" "+v.y+" "+v.z}function B(v,L,D,U={"stroke-width":"2",stroke:"red"}){if(!i.value||!s.value?.shadowRoot)return null;let N=x++,Y="line"+N+"_start",K="line"+N+"_end";return i.value.addHotspot(new Rt({name:Y,position:g(v)})),i.value.addHotspot(new Rt({name:K,position:g(L)})),w.value[N]={startHotspot:s.value.shadowRoot.querySelector('slot[name="'+Y+'"]').parentElement,endHotspot:s.value.shadowRoot.querySelector('slot[name="'+K+'"]').parentElement,start2D:[-1e3,-1e3],end2D:[-1e3,-1e3],centerText:D,centerTextSize:[0,0],lineAttrs:U},i.value.queueRender(),requestIdleCallback(()=>_(N),{timeout:100}),N}function b(v){return!i.value||!(v in w.value)?!1:(i.value.removeHotspot(new Rt({name:"line"+v+"_start"})),w.value[v].startHotspot.parentElement?.remove(),i.value.removeHotspot(new Rt({name:"line"+v+"_end"})),w.value[v].endHotspot.parentElement?.remove(),delete w.value[v],i.value.queueRender(),!0)}let P=Q(null);function _(v){if(!(v in w.value)||!s.value)return;let{x:L,y:D}=s.value.getBoundingClientRect(),{x:U,y:N}=w.value[v].startHotspot.getBoundingClientRect();w.value[v].start2D=[U-L,N-D];let{x:Y,y:K}=w.value[v].endHotspot.getBoundingClientRect();if(w.value[v].end2D=[Y-L,K-D],P.value&&w.value[v].centerText&&w.value[v].centerTextSize[0]===0){let ve=P.value.getElementsByClassName("line"+v+"_text")[0];if(ve){let Pe=ve.getBBox();w.value[v].centerTextSize=[Pe.width,Pe.height]}}}function M(v){s.value?v(s.value):Me(()=>s.value,L=>{L&&v(L)})}function C(v){return Object.entries(v)}e({elem:s,onElemReady:M,scene:i,renderer:a,controls:r,addLine3D:B,removeLine3D:b,onProgress:h,setPosterText:y});let{disableTap:S}=yn("disableTap");return Me(S,v=>{s.value&&(s.value.disableTap=v)}),(v,L)=>(nt(),et(Ce,null,[c.value!=null?(nt(),et("model-viewer",{key:0,ref_key:"elem",ref:s,ar:c.value.arModes.length>0,"ar-modes":c.value.arModes,"environment-image":c.value.environment,exposure:c.value.exposure,autoplay:c.value.autoplay,"orbit-sensitivity":c.value.orbitSensitivity,"pan-sensitivity":c.value.panSensitivity,poster:m.value,"shadow-intensity":c.value.shadowIntensity,"skybox-image":c.value.skybox,src:t.src,"zoom-sensitivity":c.value.zoomSensitivity,alt:"The 3D model(s)","camera-controls":"","camera-orbit":"45deg 45deg auto","interaction-prompt":"none","max-camera-orbit":"Infinity 180deg auto","min-camera-orbit":"-Infinity 0deg 5%",style:{width:"100%",height:"100%"}},[mn(v.$slots,"default",{},void 0,!0),Dt("div",{ref_key:"progressBar",ref:d,slot:"progress-bar",class:"progress-bar"},[Dt("div",{ref_key:"updateBar",ref:A,class:"update-bar"},null,512)],512)],8,Us)):Ut("",!0),Dt("div",Ds,[(nt(),et("svg",{ref_key:"svg",ref:P,class:"overlay-svg",height:"100%",width:"100%",xmlns:"http://www.w3.org/2000/svg"},[(nt(!0),et(Ce,null,hn(C(An(w)),([D,U])=>(nt(),et("g",{key:D},[Dt("line",xn({x1:U.start2D[0],x2:U.end2D[0],y1:U.start2D[1],y2:U.end2D[1]},{ref_for:!0},U.lineAttrs),null,16,Rs),U.centerText!==void 0?(nt(),et("g",Fs,[U.centerText?(nt(),et("rect",{key:0,height:U.centerTextSize[1]+4,width:U.centerTextSize[0]+8,x:(U.start2D[0]+U.end2D[0])/2-U.centerTextSize[0]/2-4,y:(U.start2D[1]+U.end2D[1])/2-U.centerTextSize[1]/2-2,fill:"gray","fill-opacity":"0.75",rx:"4",ry:"4",stroke:"black"},null,8,Es)):Ut("",!0),U.centerText?(nt(),et("text",{key:1,class:wn("line"+D+"_text"),x:(U.start2D[0]+U.end2D[0])/2,y:(U.start2D[1]+U.end2D[1])/2,"dominant-baseline":"middle",fill:"black","font-size":"16","text-anchor":"middle"},gn(U.centerText),11,Vs)):Ut("",!0)])):Ut("",!0)]))),128))],512))])],64))}}),Is=Tn(Ns,[["__scopeId","data-v-df83f4d1"]]);export{Is as default};
//# sourceMappingURL=ModelViewerWrapper-CE7sEJOZ.js.map
