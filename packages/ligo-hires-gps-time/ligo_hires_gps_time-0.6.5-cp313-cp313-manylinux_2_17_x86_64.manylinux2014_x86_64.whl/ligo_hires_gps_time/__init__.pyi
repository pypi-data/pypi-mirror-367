# This file is automatically generated by pyo3_stub_gen
# ruff: noqa: E501, F401

import builtins
import typing

class PipDuration:
    def __sub__(self, other: PipDuration) -> PipDuration: ...
    def __add__(self, other: typing.Any) -> typing.Any:
        r"""
        Add a duration to get a combined duration
        or Add a instant to get a new instant
        """
    def __mul__(self, other: typing.Any) -> typing.Any:
        r"""
        Multiply by a number to get a scaled duration
        """
    def __rmul__(self, other: typing.Any) -> typing.Any: ...
    def __truediv__(self, other: typing.Any) -> typing.Any:
        r"""
        Divide by a float or number to get a scaled duration
        Divide by a duration to get a ratio.
        """
    def __floordiv__(self, other: typing.Any) -> typing.Any:
        r"""
        Divide by a float or number to get a scaled duration
        Divide by a duration to get a ratio
        """
    def __mod__(self, other: typing.Any) -> typing.Any:
        r"""
        Get the remainder from an equivalent integer division
        """
    def __neg__(self) -> typing.Any: ...
    def __pos__(self) -> typing.Any: ...
    def __abs__(self) -> typing.Any: ...
    @staticmethod
    def freq_hz_to_period(rate_hz: builtins.float) -> PipDuration:
        r"""
        Convert a frequency as Hz into a duration that represents the corresponding period.
        """
    def period_to_freq_hz(self) -> builtins.float:
        r"""
        Convert a duration that represents a period into the corresponding frequency as Hz.
        """
    @staticmethod
    def from_seconds(seconds: builtins.float) -> PipDuration:
        r"""
        Create a duration given the length in seconds.
        """
    def to_seconds(self) -> builtins.float:
        r"""
        Return the length of the duration as seconds.
        """
    @staticmethod
    def from_sec(seconds: builtins.int) -> PipDuration:
        r"""
        Create a duration given the length in seconds.
        """
    def to_sec(self) -> builtins.int:
        r"""
        Round the duration to the nearest second.

        Return 0 for negative durations.
        """
    @staticmethod
    def from_nanoseconds(nanoseconds: builtins.int) -> PipDuration:
        r"""
        Create a duration given the length in nanoseconds.
        """
    def to_nanoseconds(self) -> builtins.int:
        r"""
        Return the length to the nearest nanosecond,
        but return zero if the duration is negative.
        """
    def to_seconds_nanoseconds(self) -> tuple[builtins.int, builtins.int]:
        r"""
        Return the length as seconds and nanoseconds
        """
    @staticmethod
    def from_pips(pips: builtins.int) -> PipDuration:
        r"""
        Create  a duration object from a numerical value of the same units.
        """
    @staticmethod
    def from_seconds_nanoseconds(
        seconds: builtins.int, nano: builtins.int
    ) -> PipDuration:
        r"""
        Create a duration given the length as seconds and nanoseconds
        """
    def to_pips(self) -> builtins.int:
        r"""
        Return duration in units of the type..
        """
    def is_empty(self) -> builtins.bool:
        r"""
        True if the length of the duration is zero.
        """
    def abs(self) -> PipDuration:
        r"""
        Return a non-negative duration of the same magnitude.
        """
    def snap_to_step(self, step: PipDuration) -> PipDuration:
        r"""
        Snap to the nearest integer multiple of a step size.
        """
    def snap_down_to_step(self, step: PipDuration) -> PipDuration:
        r"""
        Snap to the largest integer <= self that's a multiple of a step size.

        Like snap_to_step, but takes the floor rather than the nearest.
        """
    def snap_up_to_step(self, step: PipDuration) -> PipDuration:
        r"""
        Snap to the smallest integer >= self that's a multiple of a step size.

        Like snap_to_step, but takes the ceiling rather than the nearest.
        """
    @staticmethod
    def rate_hz() -> builtins.int:
        r"""
        Return the rate of the units in Hz
        """

class PipInstant:
    def __add__(self, other: PipDuration) -> PipInstant: ...
    def __sub__(self, other: typing.Any) -> typing.Any:
        r"""
        Subtract a duration to get an instant,
        or subtract a instant to get the difference as a duration.
        """
    @staticmethod
    def now() -> PipInstant:
        r"""
        return the current time
        """
    def to_gpst_pips(self) -> builtins.int:
        r"""
        Return the number of steps since the GPS epoch.
        """
    def to_gpst_seconds_nanoseconds(self) -> tuple[builtins.int, builtins.int]:
        r"""
        Return the nearest nanosecond since the GPS epoch.
        """
    def to_gpst_nanoseconds(self) -> builtins.int:
        r"""
        If positive, return nanoseconds since the GPS epoch, otherwise zero.
        """
    def to_gpst_sec(self) -> builtins.int:
        r"""
        Return the seconds since GPS epoch rounded down to the latest second
        earlier than or coincident with the instant.

        Returns 0 for instants before the GPS epoch.
        """
    def to_gpst_seconds(self) -> builtins.float:
        r"""
        Return the number of seconds since the GPS epoch.
        """
    @staticmethod
    def from_gpst_seconds_nanoseconds(
        seconds: builtins.int, nano: builtins.int
    ) -> PipInstant:
        r"""
        Create an instant given seconds + nanoseconds since the GPS epoch.
        """
    @staticmethod
    def from_gpst_nanoseconds(nano: builtins.int) -> PipInstant:
        r"""
        Create an instant given nanoseconds since the GPS epoch.
        """
    @staticmethod
    def from_gpst_seconds(seconds: builtins.float) -> PipInstant:
        r"""
        Create an instant given seconds since the GPS epoch.
        """
    @staticmethod
    def gpst_epoch() -> PipInstant:
        r"""
        Create an instant at Midnight UTC, Jan 6 1980,
        the reference epoch for the GPS time system.
        """
    @staticmethod
    def from_gpst_sec(seconds: builtins.int) -> PipInstant:
        r"""
        Create an instant given whole seconds since the GPS epoch.
        """
    @staticmethod
    def from_gpst_pips(pips: builtins.int) -> PipInstant:
        r"""
        Create an instant given steps since the GPS epoch.
        """
    def snap_to_step(self, step: PipDuration) -> PipInstant:
        r"""
        Snap to the nearest integer multiple of a step size.
        """
    def snap_down_to_step(self, step: PipDuration) -> PipInstant:
        r"""
        Snap to the largest integer <= self that's a multiple of a step size.

        Like snap_to_step, but takes the floor rather than the nearest.
        """
    def snap_up_to_step(self, step: PipDuration) -> PipInstant:
        r"""
        Snap to the smallest integer >= self that's a multiple of a step size.

        Like snap_to_step, but takes the ceiling rather than the nearest.
        """
    @staticmethod
    def rate_hz() -> builtins.int:
        r"""
        Return the rate of the units in Hz
        """

class ThumpDuration:
    def __sub__(self, other: ThumpDuration) -> ThumpDuration: ...
    def __add__(self, other: typing.Any) -> typing.Any:
        r"""
        Add a duration to get a combined duration
        or Add a instant to get a new instant
        """
    def __mul__(self, other: typing.Any) -> typing.Any:
        r"""
        Multiply by a number to get a scaled duration
        """
    def __rmul__(self, other: typing.Any) -> typing.Any: ...
    def __truediv__(self, other: typing.Any) -> typing.Any:
        r"""
        Divide by a float or number to get a scaled duration
        Divide by a duration to get a ratio.
        """
    def __floordiv__(self, other: typing.Any) -> typing.Any:
        r"""
        Divide by a float or number to get a scaled duration
        Divide by a duration to get a ratio
        """
    def __mod__(self, other: typing.Any) -> typing.Any:
        r"""
        Get the remainder from an equivalent integer division
        """
    def __neg__(self) -> typing.Any: ...
    def __pos__(self) -> typing.Any: ...
    def __abs__(self) -> typing.Any: ...
    @staticmethod
    def freq_hz_to_period(rate_hz: builtins.float) -> ThumpDuration:
        r"""
        Convert a frequency as Hz into a duration that represents the corresponding period.
        """
    def period_to_freq_hz(self) -> builtins.float:
        r"""
        Convert a duration that represents a period into the corresponding frequency as Hz.
        """
    @staticmethod
    def from_seconds(seconds: builtins.float) -> ThumpDuration:
        r"""
        Create a duration given the length in seconds.
        """
    def to_seconds(self) -> builtins.float:
        r"""
        Return the length of the duration as seconds.
        """
    @staticmethod
    def from_sec(seconds: builtins.int) -> ThumpDuration:
        r"""
        Create a duration given the length in seconds.
        """
    def to_sec(self) -> builtins.int:
        r"""
        Round the duration to the nearest second.

        Return 0 for negative durations.
        """
    @staticmethod
    def from_nanoseconds(nanoseconds: builtins.int) -> ThumpDuration:
        r"""
        Create a duration given the length in nanoseconds.
        """
    def to_nanoseconds(self) -> builtins.int:
        r"""
        Return the length to the nearest nanosecond,
        but return zero if the duration is negative.
        """
    def to_seconds_nanoseconds(self) -> tuple[builtins.int, builtins.int]:
        r"""
        Return the length as seconds and nanoseconds
        """
    @staticmethod
    def from_thumps(thumps: builtins.int) -> ThumpDuration:
        r"""
        Create  a duration object from a numerical value of the same units.
        """
    @staticmethod
    def from_seconds_nanoseconds(
        seconds: builtins.int, nano: builtins.int
    ) -> ThumpDuration:
        r"""
        Create a duration given the length as seconds and nanoseconds
        """
    def to_thumps(self) -> builtins.int:
        r"""
        Return duration in units of the type..
        """
    def is_empty(self) -> builtins.bool:
        r"""
        True if the length of the duration is zero.
        """
    def abs(self) -> ThumpDuration:
        r"""
        Return a non-negative duration of the same magnitude.
        """
    def snap_to_step(self, step: ThumpDuration) -> ThumpDuration:
        r"""
        Snap to the nearest integer multiple of a step size.
        """
    def snap_down_to_step(self, step: ThumpDuration) -> ThumpDuration:
        r"""
        Snap to the largest integer <= self that's a multiple of a step size.

        Like snap_to_step, but takes the floor rather than the nearest.
        """
    def snap_up_to_step(self, step: ThumpDuration) -> ThumpDuration:
        r"""
        Snap to the smallest integer >= self that's a multiple of a step size.

        Like snap_to_step, but takes the ceiling rather than the nearest.
        """
    @staticmethod
    def rate_hz() -> builtins.int:
        r"""
        Return the rate of the units in Hz
        """

class ThumpInstant:
    def __add__(self, other: ThumpDuration) -> ThumpInstant: ...
    def __sub__(self, other: typing.Any) -> typing.Any:
        r"""
        Subtract a duration to get an instant,
        or subtract a instant to get the difference as a duration.
        """
    @staticmethod
    def now() -> ThumpInstant:
        r"""
        return the current time
        """
    def to_gpst_thumps(self) -> builtins.int:
        r"""
        Return the number of steps since the GPS epoch.
        """
    def to_gpst_seconds_nanoseconds(self) -> tuple[builtins.int, builtins.int]:
        r"""
        Return the nearest nanosecond since the GPS epoch.
        """
    def to_gpst_nanoseconds(self) -> builtins.int:
        r"""
        If positive, return nanoseconds since the GPS epoch, otherwise zero.
        """
    def to_gpst_sec(self) -> builtins.int:
        r"""
        Return the seconds since GPS epoch rounded down to the latest second
        earlier than or coincident with the instant.

        Returns 0 for instants before the GPS epoch.
        """
    def to_gpst_seconds(self) -> builtins.float:
        r"""
        Return the number of seconds since the GPS epoch.
        """
    @staticmethod
    def from_gpst_seconds_nanoseconds(
        seconds: builtins.int, nano: builtins.int
    ) -> ThumpInstant:
        r"""
        Create an instant given seconds + nanoseconds since the GPS epoch.
        """
    @staticmethod
    def from_gpst_nanoseconds(nano: builtins.int) -> ThumpInstant:
        r"""
        Create an instant given nanoseconds since the GPS epoch.
        """
    @staticmethod
    def from_gpst_seconds(seconds: builtins.float) -> ThumpInstant:
        r"""
        Create an instant given seconds since the GPS epoch.
        """
    @staticmethod
    def gpst_epoch() -> ThumpInstant:
        r"""
        Create an instant at Midnight UTC, Jan 6 1980,
        the reference epoch for the GPS time system.
        """
    @staticmethod
    def from_gpst_sec(seconds: builtins.int) -> ThumpInstant:
        r"""
        Create an instant given whole seconds since the GPS epoch.
        """
    @staticmethod
    def from_gpst_thumps(thumps: builtins.int) -> ThumpInstant:
        r"""
        Create an instant given steps since the GPS epoch.
        """
    def snap_to_step(self, step: ThumpDuration) -> ThumpInstant:
        r"""
        Snap to the nearest integer multiple of a step size.
        """
    def snap_down_to_step(self, step: ThumpDuration) -> ThumpInstant:
        r"""
        Snap to the largest integer <= self that's a multiple of a step size.

        Like snap_to_step, but takes the floor rather than the nearest.
        """
    def snap_up_to_step(self, step: ThumpDuration) -> ThumpInstant:
        r"""
        Snap to the smallest integer >= self that's a multiple of a step size.

        Like snap_to_step, but takes the ceiling rather than the nearest.
        """
    @staticmethod
    def rate_hz() -> builtins.int:
        r"""
        Return the rate of the units in Hz
        """
