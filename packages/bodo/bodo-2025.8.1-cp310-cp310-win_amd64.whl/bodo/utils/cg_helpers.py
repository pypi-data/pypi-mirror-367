"""helper functions for code generation with llvmlite"""

import llvmlite.binding as ll
from llvmlite import ir as lir
from numba.core import cgutils, types
from numba.extending import intrinsic

import bodo

# NOTE: importing hdist is necessary for MPI initialization before array_ext
from bodo.libs import array_ext, hdist  # noqa: F401

ll.add_symbol("array_getitem", array_ext.array_getitem)
ll.add_symbol("seq_getitem", array_ext.seq_getitem)
ll.add_symbol("list_check", array_ext.list_check)
ll.add_symbol("dict_keys", array_ext.dict_keys)
ll.add_symbol("dict_values", array_ext.dict_values)
ll.add_symbol("dict_merge_from_seq2", array_ext.dict_merge_from_seq2)
ll.add_symbol("is_na_value", array_ext.is_na_value)


def set_bitmap_bit(builder, null_bitmap_ptr, ind, val):
    """set bit number 'ind' of bitmap array 'null_bitmap_ptr' to val"""
    byte_ind = builder.lshr(ind, lir.Constant(lir.IntType(64), 3))
    bit_ind = builder.urem(ind, lir.Constant(lir.IntType(64), 8))
    byte_ptr = builder.gep(null_bitmap_ptr, [byte_ind], inbounds=True)
    byte = builder.load(byte_ptr)
    ll_typ_mask = lir.ArrayType(lir.IntType(8), 8)
    mask_tup = cgutils.alloca_once_value(
        builder, lir.Constant(ll_typ_mask, (1, 2, 4, 8, 16, 32, 64, 128))
    )
    mask = builder.load(
        builder.gep(
            mask_tup, [lir.Constant(lir.IntType(64), 0), bit_ind], inbounds=True
        )
    )
    if val:
        # set masked bit
        builder.store(builder.or_(byte, mask), byte_ptr)
    else:
        # flip all bits of mask e.g. 11111101
        mask = builder.xor(mask, lir.Constant(lir.IntType(8), -1))
        # unset masked bit
        builder.store(builder.and_(byte, mask), byte_ptr)


def get_bitmap_bit(builder, null_bitmap_ptr, ind):
    """get bit number 'ind' of bitmap array 'null_bitmap_ptr'"""
    # (null_bitmap[i / 8] & kBitmask[i % 8])
    byte_ind = builder.lshr(ind, lir.Constant(lir.IntType(64), 3))
    bit_ind = builder.urem(ind, lir.Constant(lir.IntType(64), 8))
    byte = builder.load(builder.gep(null_bitmap_ptr, [byte_ind], inbounds=True))
    ll_typ_mask = lir.ArrayType(lir.IntType(8), 8)
    mask_tup = cgutils.alloca_once_value(
        builder, lir.Constant(ll_typ_mask, (1, 2, 4, 8, 16, 32, 64, 128))
    )
    mask = builder.load(
        builder.gep(
            mask_tup, [lir.Constant(lir.IntType(64), 0), bit_ind], inbounds=True
        )
    )
    return builder.and_(byte, mask)


@intrinsic
def set_bit_to(typingctx, null_bitmap_ptr_t, ind_t, val_t):
    """intrinsic equivalent of SetBitTo() in C++. Sets bitmap array's bit to value.

    Args:
        typingctx: Numba typing context
        null_bitmap_ptr_t (uint8_t*): bitmap array's pointer
        ind_t (int64): index in bitmap array
        val_t (bool): value to set
    """

    # C++ function:
    # inline void SetBitTo(uint8_t* bits, int64_t i, bool bit_is_set) {
    #     bits[i / 8] ^=
    #         static_cast<uint8_t>(-static_cast<uint8_t>(bit_is_set) ^ bits[i / 8]) &
    #         kBitmask[i % 8];
    # }

    # LLVM IR generated by "clang -O3 -S -emit-llvm"
    # define void @_Z8SetBitToPhxb(i8* nocapture %0, i64 %1, i1 zeroext %2) local_unnamed_addr #0 {
    #     %4 = sext i1 %2 to i8
    #     %5 = sdiv i64 %1, 8
    #     %6 = getelementptr inbounds i8, i8* %0, i64 %5
    #     %7 = load i8, i8* %6, align 1, !tbaa !4
    #     %8 = xor i8 %7, %4
    #     %9 = srem i64 %1, 8
    #     %10 = getelementptr inbounds [8 x i8], [8 x i8]* @_ZL8kBitmask, i64 0, i64 %9
    #     %11 = load i8, i8* %10, align 1, !tbaa !4
    #     %12 = and i8 %8, %11
    #     %13 = xor i8 %12, %7
    #     store i8 %13, i8* %6, align 1, !tbaa !4
    #     ret void
    # }

    def codegen(context, builder, sig, args):
        null_bitmap_ptr, ind, val = args

        val = builder.sext(val, lir.IntType(8))
        byte_ind = builder.lshr(ind, lir.Constant(lir.IntType(64), 3))
        bit_ind = builder.urem(ind, lir.Constant(lir.IntType(64), 8))
        byte_ptr = builder.gep(null_bitmap_ptr, [byte_ind], inbounds=True)
        byte = builder.load(byte_ptr)
        ll_typ_mask = lir.ArrayType(lir.IntType(8), 8)
        mask_tup = cgutils.alloca_once_value(
            builder, lir.Constant(ll_typ_mask, (1, 2, 4, 8, 16, 32, 64, 128))
        )
        mask = builder.load(
            builder.gep(
                mask_tup, [lir.Constant(lir.IntType(64), 0), bit_ind], inbounds=True
            )
        )
        b_xor_val = builder.xor(byte, val)
        out = builder.xor(builder.and_(b_xor_val, mask), byte)
        builder.store(out, byte_ptr)

    return types.void(types.voidptr, types.int64, types.bool_), codegen


def pyarray_check(builder, context, obj):
    """check if obj is a Numpy array"""

    pyobj = context.get_argument_type(types.pyobject)
    arr_check_fnty = lir.FunctionType(lir.IntType(32), [pyobj])
    arr_check_fn = cgutils.get_or_insert_function(
        builder.module, arr_check_fnty, name="is_np_array"
    )
    return builder.call(arr_check_fn, [obj])


def pyarray_getitem(builder, context, arr_obj, ind):
    """getitem of 1D Numpy array"""
    pyobj = context.get_argument_type(types.pyobject)
    py_ssize_t = context.get_value_type(types.intp)
    arr_get_fnty = lir.FunctionType(lir.IntType(8).as_pointer(), [pyobj, py_ssize_t])
    arr_get_fn = cgutils.get_or_insert_function(
        builder.module, arr_get_fnty, name="array_getptr1"
    )
    arr_getitem_fnty = lir.FunctionType(pyobj, [pyobj, lir.IntType(8).as_pointer()])
    arr_getitem_fn = cgutils.get_or_insert_function(
        builder.module, arr_getitem_fnty, name="array_getitem"
    )
    arr_ptr = builder.call(arr_get_fn, [arr_obj, ind])
    return builder.call(arr_getitem_fn, [arr_obj, arr_ptr])


def pyarray_setitem(builder, context, arr_obj, ind, val_obj):
    """setitem of 1D Numpy array"""
    pyobj = context.get_argument_type(types.pyobject)
    py_ssize_t = context.get_value_type(types.intp)
    arr_get_fnty = lir.FunctionType(lir.IntType(8).as_pointer(), [pyobj, py_ssize_t])
    arr_get_fn = cgutils.get_or_insert_function(
        builder.module, arr_get_fnty, name="array_getptr1"
    )
    arr_setitem_fnty = lir.FunctionType(
        lir.VoidType(), [pyobj, lir.IntType(8).as_pointer(), pyobj]
    )
    arr_setitem_fn = cgutils.get_or_insert_function(
        builder.module, arr_setitem_fnty, name="array_setitem"
    )
    arr_ptr = builder.call(arr_get_fn, [arr_obj, ind])
    builder.call(arr_setitem_fn, [arr_obj, arr_ptr, val_obj])


def seq_getitem(builder, context, obj, ind):
    """getitem for a sequence object (e.g. list/array)"""
    pyobj = context.get_argument_type(types.pyobject)
    py_ssize_t = context.get_value_type(types.intp)
    getitem_fnty = lir.FunctionType(pyobj, [pyobj, py_ssize_t])
    getitem_fn = cgutils.get_or_insert_function(
        builder.module, getitem_fnty, name="seq_getitem"
    )
    return builder.call(getitem_fn, [obj, ind])


def is_na_value(builder, context, val, C_NA):
    """check if Python object 'val' is an NA value (None, or np.nan or pd.NA).
    passing pd.NA in as C_NA to avoid getattr overheads inside loops.
    """
    pyobj = context.get_argument_type(types.pyobject)
    arr_isna_fnty = lir.FunctionType(lir.IntType(32), [pyobj, pyobj])
    arr_isna_fn = cgutils.get_or_insert_function(
        builder.module, arr_isna_fnty, name="is_na_value"
    )
    return builder.call(arr_isna_fn, [val, C_NA])


def list_check(builder, context, obj):
    """check if Python object 'obj' is a list"""
    pyobj = context.get_argument_type(types.pyobject)
    int32_type = context.get_value_type(types.int32)
    fnty = lir.FunctionType(int32_type, [pyobj])
    fn = cgutils.get_or_insert_function(builder.module, fnty, name="list_check")
    return builder.call(fn, [obj])


def dict_keys(builder, context, obj):
    """call PyDict_Keys"""
    pyobj = context.get_argument_type(types.pyobject)
    fnty = lir.FunctionType(pyobj, [pyobj])
    fn = cgutils.get_or_insert_function(builder.module, fnty, name="dict_keys")
    return builder.call(fn, [obj])


def dict_values(builder, context, obj):
    """call PyDict_Values"""
    pyobj = context.get_argument_type(types.pyobject)
    fnty = lir.FunctionType(pyobj, [pyobj])
    fn = cgutils.get_or_insert_function(builder.module, fnty, name="dict_values")
    return builder.call(fn, [obj])


def dict_merge_from_seq2(builder, context, dict_obj, seq2_obj):
    """call PyDict_MergeFromSeq2()"""
    pyobj = context.get_argument_type(types.pyobject)
    fnty = lir.FunctionType(lir.VoidType(), [pyobj, pyobj])
    fn = cgutils.get_or_insert_function(
        builder.module, fnty, name="dict_merge_from_seq2"
    )
    builder.call(fn, [dict_obj, seq2_obj])


def to_arr_obj_if_list_obj(c, context, builder, val, typ):
    """convert object 'val' to array if it is a list to enable proper unboxing"""
    if not (isinstance(typ, types.List) or bodo.utils.utils.is_array_typ(typ, False)):
        return val

    # convert val to array if it is a list (list_check is needed since converting
    # pd arrays like IntegerArray can cause errors)
    # if isinstance(val, list):
    #   val = np.array(val)
    val_ptr = cgutils.alloca_once_value(builder, val)
    is_list = list_check(builder, context, val)
    is_list_cond = builder.icmp_unsigned("!=", is_list, lir.Constant(is_list.type, 0))
    with builder.if_then(is_list_cond):
        # tz-aware datetime list should be converted to Pandas array for proper unboxing
        if isinstance(typ, bodo.DatetimeArrayType):
            # get pd.array to convert list items to Pandas array
            mod_name = context.insert_const_string(builder.module, "pandas")
            pd_mod_obj = c.pyapi.import_module(mod_name)

            old_obj = builder.load(val_ptr)
            new_obj = c.pyapi.call_method(pd_mod_obj, "array", (old_obj,))
            # TODO: this decref causes crashes for some reason in test_array_item_array.py
            # needs to be investigated to avoid object leaks
            # c.pyapi.decref(old_obj)
            builder.store(new_obj, val_ptr)
            c.pyapi.decref(pd_mod_obj)
        else:
            # get np.array to convert list items to array
            mod_name = context.insert_const_string(builder.module, "numpy")
            np_mod_obj = c.pyapi.import_module(mod_name)
            dtype_str = "object_"
            # float lists become float arrays, but others are object arrays
            # (see _value_to_array in boxing.py)
            if isinstance(typ, types.Array) or isinstance(typ.dtype, types.Float):
                dtype_str = str(typ.dtype)
            if dtype_str == "datetime64[ns]":
                dtype_obj = c.pyapi.string_from_constant_string("datetime64[ns]")
            else:
                dtype_obj = c.pyapi.object_getattr_string(np_mod_obj, dtype_str)

            old_obj = builder.load(val_ptr)
            new_obj = c.pyapi.call_method(np_mod_obj, "asarray", (old_obj, dtype_obj))
            # TODO: this decref causes crashes for some reason in test_array_item_array.py
            # needs to be investigated to avoid object leaks
            # c.pyapi.decref(old_obj)
            builder.store(new_obj, val_ptr)
            c.pyapi.decref(np_mod_obj)
            c.pyapi.decref(dtype_obj)

    val = builder.load(val_ptr)
    return val


def get_array_elem_counts(c, builder, context, arr_obj, typ):
    """count elements of array for upfront allocation (called recursively).
    For example, [[1, None, 3], [3], None, [4, None, 2]] return (4, 7).
    A recursive example: [[[1, None, 3], [2]], [[3], [4, 5]], None, [[4, None, 2]]]
    returns (4, 5, 10).
    """
    from bodo.libs.array_item_arr_ext import ArrayItemArrayType
    from bodo.libs.map_arr_ext import MapArrayType
    from bodo.libs.str_arr_ext import get_utf8_size, string_array_type
    from bodo.libs.struct_arr_ext import StructArrayType, StructType
    from bodo.libs.tuple_arr_ext import TupleArrayType

    # get utf8 character count for strings
    if typ == bodo.string_type:
        str_item = c.pyapi.to_native_value(bodo.string_type, arr_obj).value
        _is_error, n_chars = c.pyapi.call_jit_code(
            lambda a: get_utf8_size(a), types.int64(bodo.string_type), [str_item]
        )
        context.nrt.decref(builder, typ, str_item)
        return cgutils.pack_array(builder, [n_chars])

    # get counts for struct value (e.g. counts for strings or array items in struct)
    if isinstance(typ, (StructType, types.BaseTuple)):
        # get pd.NA object to check for new NA kind
        mod_name = context.insert_const_string(builder.module, "pandas")
        pd_mod_obj = c.pyapi.import_module(mod_name)
        C_NA = c.pyapi.object_getattr_string(pd_mod_obj, "NA")

        n_nested_count = bodo.utils.transform.get_type_alloc_counts(typ)
        counts_val = context.make_tuple(
            builder,
            types.Tuple(n_nested_count * [types.int64]),
            n_nested_count * [context.get_constant(types.int64, 0)],
        )
        counts = cgutils.alloca_once_value(builder, counts_val)
        curr_count_ind = 0
        data_types = typ.data if isinstance(typ, StructType) else typ.types
        for i, t in enumerate(data_types):
            n_nested_count_t = bodo.utils.transform.get_type_alloc_counts(t)
            if n_nested_count_t == 0:
                continue
            if isinstance(typ, StructType):
                val_obj = c.pyapi.dict_getitem_string(arr_obj, typ.names[i])
            else:
                val_obj = c.pyapi.tuple_getitem(arr_obj, i)
            # check for NA
            is_na = is_na_value(builder, context, val_obj, C_NA)
            not_na_cond = builder.icmp_unsigned(
                "!=", is_na, lir.Constant(is_na.type, 1)
            )
            with builder.if_then(not_na_cond):
                counts_val = builder.load(counts)
                n_vals_inner = get_array_elem_counts(c, builder, context, val_obj, t)
                for i in range(n_nested_count_t):
                    total_count = builder.extract_value(counts_val, curr_count_ind + i)
                    curr_count = builder.extract_value(n_vals_inner, i)
                    counts_val = builder.insert_value(
                        counts_val,
                        builder.add(total_count, curr_count),
                        curr_count_ind + i,
                    )
                builder.store(counts_val, counts)
            # no need to decref val_obj, dict_getitem_string returns borrowed ref
            curr_count_ind += n_nested_count_t

        c.pyapi.decref(pd_mod_obj)
        c.pyapi.decref(C_NA)
        return builder.load(counts)

    # return empty tuple for non-arrays
    if not bodo.utils.utils.is_array_typ(typ, False):
        return cgutils.pack_array(builder, [], lir.IntType(64))

    n = bodo.utils.utils.object_length(c, arr_obj)

    # return (n,) for non-nested arrays
    if not (
        isinstance(
            typ, (ArrayItemArrayType, StructArrayType, TupleArrayType, MapArrayType)
        )
        or typ == string_array_type
    ):
        return cgutils.pack_array(builder, [n])

    # get pd.NA object to check for new NA kind
    mod_name = context.insert_const_string(builder.module, "pandas")
    pd_mod_obj = c.pyapi.import_module(mod_name)
    C_NA = c.pyapi.object_getattr_string(pd_mod_obj, "NA")

    # create a tuple for nested counts
    n_nested_count = bodo.utils.transform.get_type_alloc_counts(typ)
    counts_val = context.make_tuple(
        builder,
        types.Tuple(n_nested_count * [types.int64]),
        [n] + (n_nested_count - 1) * [context.get_constant(types.int64, 0)],
    )
    counts = cgutils.alloca_once_value(builder, counts_val)

    # pseudocode for code generation:
    # counts = (n, 0, 0, ...)  # tuple of nested counts
    # for i in range(len(A)):
    #   arr_item_obj = A[i]
    #   if not isna(arr_item_obj):
    #     counts[1:] += get_array_elem_counts(arr_item_obj)

    # for each array
    with cgutils.for_range(builder, n) as loop:
        array_ind = loop.index
        # arr_item_obj = A[i]
        arr_item_obj = seq_getitem(builder, context, arr_obj, array_ind)
        # check for NA
        is_na = is_na_value(builder, context, arr_item_obj, C_NA)
        not_na_cond = builder.icmp_unsigned("!=", is_na, lir.Constant(is_na.type, 1))
        with builder.if_then(not_na_cond):
            if isinstance(typ, ArrayItemArrayType) or typ == string_array_type:
                counts_val = builder.load(counts)
                # if nested, call recursively and add values
                n_vals_inner = get_array_elem_counts(
                    c, builder, context, arr_item_obj, typ.dtype
                )
                # counts[1:] += get_array_elem_counts(arr_item_obj)
                for i in range(n_nested_count - 1):
                    total_count = builder.extract_value(counts_val, i + 1)
                    curr_count = builder.extract_value(n_vals_inner, i)
                    counts_val = builder.insert_value(
                        counts_val, builder.add(total_count, curr_count), i + 1
                    )
                builder.store(counts_val, counts)
            elif isinstance(typ, (StructArrayType, TupleArrayType)):
                curr_count_ind = 1  # skip total array length
                for i, t in enumerate(typ.data):
                    n_nested_count_t = bodo.utils.transform.get_type_alloc_counts(
                        t.dtype
                    )
                    if n_nested_count_t == 0:
                        continue
                    if isinstance(typ, TupleArrayType):
                        val_obj = c.pyapi.tuple_getitem(arr_item_obj, i)
                    else:
                        val_obj = c.pyapi.dict_getitem_string(
                            arr_item_obj, typ.names[i]
                        )
                    # check for NA
                    is_na = is_na_value(builder, context, val_obj, C_NA)
                    not_na_cond = builder.icmp_unsigned(
                        "!=", is_na, lir.Constant(is_na.type, 1)
                    )
                    with builder.if_then(not_na_cond):
                        counts_val = builder.load(counts)
                        n_vals_inner = get_array_elem_counts(
                            c, builder, context, val_obj, t.dtype
                        )
                        for i in range(n_nested_count_t):
                            total_count = builder.extract_value(
                                counts_val, curr_count_ind + i
                            )
                            curr_count = builder.extract_value(n_vals_inner, i)
                            counts_val = builder.insert_value(
                                counts_val,
                                builder.add(total_count, curr_count),
                                curr_count_ind + i,
                            )
                        builder.store(counts_val, counts)
                    # no need to decref val_obj, dict_getitem_string returns borrowed ref
                    curr_count_ind += n_nested_count_t
            else:
                assert isinstance(typ, MapArrayType), typ
                # add nested counts from dict key and value lists
                # NOTE: length of array(item) is counted from the length of key list and
                # should not be counted again from the value list
                counts_val = builder.load(counts)
                key_list = dict_keys(builder, context, arr_item_obj)
                value_list = dict_values(builder, context, arr_item_obj)
                # if nested, call recursively and add values
                n_keys_inner = get_array_elem_counts(
                    c, builder, context, key_list, typ.key_arr_type
                )
                n_key_nested_count = bodo.utils.transform.get_type_alloc_counts(
                    typ.key_arr_type
                )
                # counts[1:n_keys+1] += get_array_elem_counts(key_list)
                for i in range(1, n_key_nested_count + 1):
                    total_count = builder.extract_value(counts_val, i)
                    curr_count = builder.extract_value(n_keys_inner, i - 1)
                    counts_val = builder.insert_value(
                        counts_val, builder.add(total_count, curr_count), i
                    )
                n_values_inner = get_array_elem_counts(
                    c, builder, context, value_list, typ.value_arr_type
                )
                # counts[n_keys+1:] += get_array_elem_counts(value_list)[1:]
                for i in range(n_key_nested_count + 1, n_nested_count):
                    total_count = builder.extract_value(counts_val, i)
                    curr_count = builder.extract_value(
                        n_values_inner, i - n_key_nested_count
                    )
                    counts_val = builder.insert_value(
                        counts_val, builder.add(total_count, curr_count), i
                    )
                builder.store(counts_val, counts)
                c.pyapi.decref(key_list)
                c.pyapi.decref(value_list)
        c.pyapi.decref(arr_item_obj)

    c.pyapi.decref(pd_mod_obj)
    c.pyapi.decref(C_NA)
    return builder.load(counts)


def gen_allocate_array(context, builder, arr_type, n_elems, dict_arr_ref, c=None):
    """gen array allocation for type 'arr_type'.
    'n_elems' is a tuple of all counts needed for allocation, e.g. (3, 5) for array item
    that has 3 arrays and 5 primitive elements.
    'dict_arr_ref' is the reference array for allocating dictionary-encoded arrays if
    available (otherwise None).
    'c' is boxing/unboxing context and can be None if not in boxing/unboxing steps.
    When in boxing/unboxing, 'call_jit_code' is used to handle Python error model.
    """
    n_counts = n_elems.type.count
    assert n_counts >= 1, "gen_allocate_array(): invalid n_elems count"
    length = builder.extract_value(n_elems, 0)

    # if nested counts are provided, pack a new tuple for them
    if n_counts != 1:
        n_nested_elems = cgutils.pack_array(
            builder, [builder.extract_value(n_elems, i) for i in range(1, n_counts)]
        )
        nested_counts_typ = types.Tuple([types.int64] * (n_counts - 1))
    else:
        n_nested_elems = context.get_dummy_value()
        nested_counts_typ = types.none

    # call alloc_type
    t_ref = types.TypeRef(arr_type)
    dict_arr_ref_typ = types.none if dict_arr_ref is None else arr_type
    dict_arr_ref_val = (
        context.get_dummy_value() if dict_arr_ref is None else dict_arr_ref
    )
    sig = arr_type(types.int64, t_ref, nested_counts_typ, dict_arr_ref_typ)
    args = [length, context.get_dummy_value(), n_nested_elems, dict_arr_ref_val]
    impl = lambda n, t, s, dict_arr_ref: bodo.utils.utils.alloc_type(
        n, t, s, dict_arr_ref
    )
    if c:
        _is_error, out_arr = c.pyapi.call_jit_code(impl, sig, args)
    else:
        out_arr = context.compile_internal(builder, impl, sig, args)
    return out_arr


def gen_alloc_meminfo(context, builder, length, dtype):
    """Allocate a meminfo for 'length' elements of type 'dtype'.
    Implementation similar to bodo.utils.utils._empty_nd_impl.

    Args:
        context (BaseContext): codegen context
        builder (IRBuilder): codegen builder
        length (lir.IntType): number of element
        dtype (types.Type): element types

    Returns:
        ll_voidptr: allocated meminfo
    """

    ll_type = context.get_data_type(dtype)
    itemsize = context.get_constant(types.intp, context.get_abi_sizeof(ll_type))

    # Check overflow, numpy also does this after checking order
    allocsize_mult = builder.smul_with_overflow(length, itemsize)
    allocsize = builder.extract_value(allocsize_mult, 0)
    overflow = builder.extract_value(allocsize_mult, 1)

    with builder.if_then(overflow, likely=False):
        cgutils.printf(
            builder,
            (
                "meminfo is too big; `length * itemsize` is larger than"
                " the maximum possible size."
            ),
        )

    align_val = context.get_preferred_array_alignment(dtype)
    align = context.get_constant(types.uint32, align_val)
    meminfo = context.nrt.meminfo_alloc_aligned(builder, size=allocsize, align=align)
    return meminfo


def meminfo_to_np_arr(context, builder, meminfo, meminfo_offset, length, arrtype):
    """Wrap meminfo in a Numpy array of type 'arrtype'.
    Implementation similar to bodo.utils.utils._empty_nd_impl.

    Args:
        context (BaseContext): codegen context
        builder (IRBuilder): codegen builder
        meminfo (ll_voidptr): input meminfo
        meminfo_offset (lir.IntType): data pointer offset from meminfo data pointer
        length (lir.IntType): number of element
        arrtype (types.Type): Numpy array type to wrap

    Returns:
        lir.LiteralStructType: Numpy array that wraps meminfo
    """

    from numba.np.arrayobj import get_itemsize, populate_array

    assert arrtype.ndim == 1 and arrtype.layout == "C", (
        "meminfo_to_np_arr: 1D array type with C layout expected"
    )

    arr = context.make_array(arrtype)(context, builder)

    datatype = context.get_data_type(arrtype.dtype)
    itemsize = context.get_constant(types.intp, get_itemsize(context, arrtype))

    meminfo_ptr = context.nrt.meminfo_data(builder, meminfo)
    data = builder.inttoptr(
        builder.add(builder.ptrtoint(meminfo_ptr, lir.IntType(64)), meminfo_offset),
        lir.IntType(8).as_pointer(),
    )
    intp_t = context.get_value_type(types.intp)
    shape_array = cgutils.pack_array(builder, (length,), ty=intp_t)
    strides_array = cgutils.pack_array(builder, (itemsize,), ty=intp_t)

    populate_array(
        arr,
        data=builder.bitcast(data, datatype.as_pointer()),
        shape=shape_array,
        strides=strides_array,
        itemsize=itemsize,
        meminfo=meminfo,
    )

    return arr._getvalue()


def is_ll_eq(builder, val1, val2):
    """
    Compare equality of two llvm values.
    Generalizes icmp_unsigned("==", ...) to handle aggregate types (Struct/Array).
    'val1' & 'val2' are pointer to llvm values.
    """
    t1 = val1.type.pointee
    t2 = val2.type.pointee
    assert t1 == t2, "invalid llvm value comparison"

    # compare individual elements for aggregate types
    if isinstance(t1, (lir.BaseStructType, lir.ArrayType)):
        n_elems = len(t1.elements) if isinstance(t1, lir.BaseStructType) else t1.count
        eq = lir.Constant(lir.IntType(1), 1)
        for i in range(n_elems):
            # NOTE: aggregate types need an extra 0 index for accessing elements in LLVM
            # e.g. gep(A, 0, 4) gives the 4th element
            ll_0 = lir.IntType(32)(0)
            ll_i = lir.IntType(32)(i)
            new_val1 = builder.gep(val1, [ll_0, ll_i], inbounds=True)
            new_val2 = builder.gep(val2, [ll_0, ll_i], inbounds=True)
            eq = builder.and_(eq, is_ll_eq(builder, new_val1, new_val2))
        return eq

    v1 = builder.load(val1)
    v2 = builder.load(val2)

    # some values may be float which we cast to int for basic equality check
    # see test_describe_many_columns
    if v1.type in (lir.FloatType(), lir.DoubleType()):
        n_bits = 32 if v1.type == lir.FloatType() else 64
        v1 = builder.bitcast(v1, lir.IntType(n_bits))
        v2 = builder.bitcast(v2, lir.IntType(n_bits))

    # integer or pointer values
    return builder.icmp_unsigned("==", v1, v2)
