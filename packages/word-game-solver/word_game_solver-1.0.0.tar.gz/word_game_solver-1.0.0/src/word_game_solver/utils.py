import os
import pathlib
from pathlib import Path
import subprocess
import getpass
import datetime
import platform


"""
Various utilities.

This module has several utilities, useful for importing into other modules.
In this case specifically for the cli.py module, where I will keep everything
centered on the interface with the minimum logic possible, to keep the cli.py
module as clean as possible. In turn, some functions are general and could
be used for other modules, but others are specifically designed to serve the
cli.py module, which is the graphical interface of this project.

All functions, classes and methods are subject to their own documentation.
"""


__all__: list[str] = ["clean_console", "username", "user_datetime", "all_paths", 
                      "Logs", "UserHistory", "user_help", "about"]


def clean_console()-> None:
    """
    Clear the shell screen.

    Args:
        None

    Returns:
        None
    """
    if os.name == "posix":
        os.system("clear")
    elif os.name == "nt":
        os.system("cls")


def username()-> str:
    """
    Logged in username.

    Args:
        None

    Returns:
        str: Logged in username.
    """
    return getpass.getuser() + "\n"


def user_datetime()-> str:
    """
    Current date and time of the equipment.

    Args:
        None

    Returns:
        result (str): Current date and time of the equipment
    """
    date: str
    time: str
    date, time = datetime.datetime.today().__str__().split()
    result: str = date + " " + ''.join(time.split(".")[0:-1])
    return result


def all_paths(get_path: str)-> Path:
    """
    All the necessary paths.

    A dictionary that will have keywords in its key, and the path of that
    keyword in its value, and if it does not exist, a KeyError type
    exception is raised. The base path is obtained with the path of
    the current file by searching exactly for the root where the file
    is located, and all other paths are built based on this root.

    Args:
        get_path (str): Keyword, which is searched for in the dict, 
            and if it exists, the path will be returned.
    
    Returns:
        result (Path): Path found in the dict based on the keyword.
    """
    project_base_path: Path = pathlib.Path(__file__).resolve().parent
    user_history_path: Path = project_base_path / "info"
    logs_path: Path = project_base_path / "info"
    project_data_path: Path = project_base_path / "word_files"
    help_path: Path = project_base_path / "info"
    about_path: Path = project_base_path / "info"
    license_path: Path = project_base_path / "info" 

    paths: dict[str, Path] = {"base":project_base_path,
             "history": user_history_path, 
             "logs": logs_path, 
             "project_data": project_data_path, 
             "help": help_path,
             "about": about_path,
             "license": license_path
             }
    
    try:
        result: Path = paths[get_path]
    except KeyError:
        raise KeyError(f"The key to the dic: '{get_path}' It is invalid. Valid keys: {list(paths.keys())}")
    
    return result


def open_file_with_editor(file_path: Path)-> None:
    """
    Open files in the text editor.

    In the case of Unix-type systems, it will open the file in the nano
    console text editor, which is almost always available. In the case
    of Windows, it will open with the GUI notepad text editor, which is
    usually available. In the case of Nano, it is mandatory to close it
    to continue with the application. In the case of Windows, it is also
    mandatory but not as intuitive, which is why the console indicates
    that it must be closed before continuing.

    Args:
        file_path (Path): The full path of the file to be opened.

    Returns:
        None
    """
    operating_system: str = platform.system()
    if operating_system == "Linux":
        subprocess.run(["nano", "-v", file_path])
    elif operating_system == "Windows":
        subprocess.run(["notepad", file_path])
    elif operating_system == "Darwin":
        subprocess.run(["nano", "-v", file_path])
    else:
        subprocess.run(["nano", "-v", file_path])


class Logs:
    """
    Build and save user records.

    This class and its metodos are here specifically, to build and save all
    user records, we use the application using cli.py, have a personalized
    format with the information that is created for saving, basically keep
    each independent format record in blocks separated from text, Username,
    saved and time, when you enter the application, all the data generated by
    the user's interaction, When you finish using the application, we save
    the application termination record.
    """
    @staticmethod
    def start_of_log()-> None:
        """
        Build and save the initial part of a user record

        Build and save the initial part of a user record. Each user session
        is saved in a log, indicating all the activity that occurred
        during the session. Here, the initial part is built and saved.

        Args:
            None

        Returns:
            None
        """
        file_logs_path: Path = all_paths("logs") / "log.txt"
        with open(file_logs_path, "a") as file_logs:
            file_logs.write(f"{username()}")
            file_logs.write(f"{user_datetime()}")
            file_logs.write(f"\nStarting CLI application...\n")
            file_logs.write(f"Console Cleaning: True\n")

    @staticmethod
    def history_log(option: str, result: str)-> None:
        """
        Build and save the middle part of a user record.

        Build and save, the middle part of a user record. Here, almost all
        of a user's activity is built and saved during a session using
        this application. Most of the data is saved here, that is, all
        of the responses that the application generated based on the
        user's interaction with the application.

        Args:
            option (str): Main menu option that the user chose.
            result (str): Result generated by the application according
                to the actions performed by the user.

        Returns:
            None
        """
        record: str = ""
        file_logs_path: Path = all_paths("logs") / "log.txt"
        with open(file_logs_path, "a") as file_logs:
            match option:
                case "0":
                    record = f"{result}\n"
                case "1":
                    record = f"History viewed.\n"
                case "2":
                    record = f"History deleted.\n"
                case "3":
                    record = f"Revised Help\n"
                case "4":
                    record = f"Revised About\n"
                case "5":
                    record = f"Exit...\n"
                case _:
                    record = f"Invalid option.\n"
            file_logs.write(f"{record}")

    @staticmethod
    def end_of_log()-> None:
        """
        Build and save the final part of a user record.

        Build and save, the final part of a user record, each user session
        is saved in a log, indicating all the activity that occurred
        during the session, here the final part is built and saved.

        Args:
            None

        Returns:
            None
        """
        file_logs_path: Path = all_paths("logs") / "log.txt"
        with open(file_logs_path, "a") as file_logs:
            file_logs.write(f"End CLI application...\n\n")


class UserHistory:
    """
    User history

    This class and its methods are created to build, store, read, and borrow
    the user history when using the application, each history is an
    independent text block, which contains information such as the number
    of users, data and times, and all the correct entries from the user
    with the corresponding valid data. Data in this cantidad of words and
    words encountered, in case of no encotrar words will appear without
    coincidences, it has its personalized format which is created useful.
    """
    @staticmethod
    def save_history(word_length: str, available_letters: str, size: int, matches: str)-> None:
        """
        Build and save user history.

        Builds and saves the user's history. Here, information is only built
        when the input data is correct and a valid output is generated,
        regardless of whether words were found. With this input and output
        information, the history is built and finally saved.

        Args:
            word_length (str): Integer entered by the user that indicates 
                the desired length of each searched word.
            available_letters (str): String of letters entered by the user,
                the words to search for must be formed by these letters,
                although not all letters have to be used, only combinations
                of them.
            size (int): Number of words found.
            matches (str): Words found.

        Returns:
            None
        """
        user_history_file_path: Path = all_paths("history") / "history.txt"
        with open(user_history_file_path, "a") as file_history:
            date:str
            hours:str
            date, hours = user_datetime().split()
            file_history.write(f"{username()}")
            file_history.write(f"Date: {date} Hours: {hours}\n")
            file_history.write(f"Desired length: {word_length}\n")
            file_history.write(f"Set of letters: {available_letters}\n")
            file_history.write(f"Matches found: {size}\n")
            file_history.write(f"List of matches: {matches}\n\n")

    @staticmethod
    def read_history()-> None:
        """
        Open the file containing the user history.

        Open the file containing the user history. It is different from
        the log file, it has a different format and different things
        are saved, here only successful information is saved, that 
        is, when the user's input is correct and words have been
        generated in the output or it shows that there are no matches.

        Args:
            None

        Returns:
            None
        """
        user_history_file_path: Path = all_paths("history") / "history.txt"
        open_file_with_editor(user_history_file_path)

    @staticmethod
    def delete_history()-> None:
        """
        Delete user history.

        Only the information in the file is deleted, not the file itself
        or the folder that contains it.

        Args:
            None

        Returns:
            None
        """
        user_history_file_path: Path = all_paths("history") / "history.txt"
        with open(user_history_file_path, "w"):
            pass

    
def user_help()-> None:
    """
    Open the user help.md file.

    Args:
        None

    Returns:
        None
    """
    help_file: Path = all_paths("help") / "help.md"
    open_file_with_editor(help_file)


def about()-> None:
    """
    Open the about.txt file

    The about.txt file contains the project name, version, author, GitHub,
    project repository, and license.

    Args:
        None

    Returns:
        None
    """
    about_file: Path = all_paths("about") / "about.txt"
    open_file_with_editor(about_file)
    
    

if __name__ == "__main__":
    """
    Tests

    Here we import the test module and run the tests contained in the
    docstring, specifically in 'Examples:'
    """
    import doctest
    doctest.testmod(verbose=True)