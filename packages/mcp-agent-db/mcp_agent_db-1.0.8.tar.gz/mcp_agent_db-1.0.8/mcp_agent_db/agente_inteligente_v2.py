from typing import List, Dict, Any
from langgraph.prebuilt import create_react_agent
from langchain.prompts import PromptTemplate
from langchain.chat_models import init_chat_model
from langchain.tools import tool
from langchain.memory import ConversationBufferMemory
from langgraph.checkpoint.memory import MemorySaver
from langchain_mcp_adapters.client import MultiServerMCPClient
from mcp_servers import MCP_SERVERS_CONFIG
from sql_generator import gerar_sql_da_pergunta
from dotenv import load_dotenv
from consulta_tool import consulta_postgres_tool, consultar_banco_dados
import asyncio
import os
import django
from cache_manager import query_cache
from conversation_memory import conversation_memory
from consulta_tool import consultar_banco_dados
from sql_generator import gerar_sql_da_pergunta

load_dotenv()

# Configurar Django
os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'settings')
django.setup()

# Inicializar componentes globais
model_llm = init_chat_model("gemini-2.5-flash", model_provider="google_genai")
memory = ConversationBufferMemory(memory_key="chat_history")
memory_saver = MemorySaver()


mcp_client = None
agent_executor = None

def validar_schema_ferramenta(tool) -> bool:
    """Valida se o schema da ferramenta √© compat√≠vel com Gemini"""
    try:
        # Lista de ferramentas conhecidas como problem√°ticas
        ferramentas_problematicas = [
            'generate_fishbone_diagram',
            'generate_mind_map', 
            'generate_organization_chart',
            'generate_word_cloud_chart',
            'generate_flow_diagram',
            'generate_network_graph'
        ]
        
        # Rejeitar ferramentas conhecidas como problem√°ticas
        if tool.name in ferramentas_problematicas:
            return False
        
        # Verificar se a ferramenta tem schema
        if not hasattr(tool, 'args_schema') or tool.args_schema is None:
            return True
        
        # Converter schema para dict para an√°lise
        try:
            schema_dict = tool.args_schema.model_json_schema() if hasattr(tool.args_schema, 'model_json_schema') else {}
        except Exception:
            return False
        
        # Verificar se h√° propriedades recursivas problem√°ticas
        def verificar_recursao(obj, profundidade=0):
            if profundidade > 3:  # Limite de profundidade mais restritivo
                return False
            
            if isinstance(obj, dict):
                # Verificar se h√° chave '$schema' problem√°tica
                if '$schema' in obj:
                    return False
                    
                if 'properties' in obj:
                    for prop_name, prop_value in obj['properties'].items():
                        if isinstance(prop_value, dict):
                            # Verificar estruturas recursivas espec√≠ficas
                            if 'items' in prop_value and isinstance(prop_value['items'], dict):
                                if 'properties' in prop_value['items']:
                                    # Verificar se h√° 'children' recursivos
                                    if 'children' in prop_value['items']['properties']:
                                        children_prop = prop_value['items']['properties']['children']
                                        if isinstance(children_prop, dict) and 'items' in children_prop:
                                            return False
                            
                            # Verificar recursivamente
                            if not verificar_recursao(prop_value, profundidade + 1):
                                return False
                                
                if 'items' in obj and isinstance(obj['items'], dict):
                    if not verificar_recursao(obj['items'], profundidade + 1):
                        return False
            
            return True
        
        return verificar_recursao(schema_dict)
        
    except Exception as e:
        print(f"‚ö†Ô∏è Erro ao validar schema da ferramenta {tool.name}: {e}")
        return False

def filtrar_ferramentas_validas(mcp_tools: List) -> List:
    """Filtra ferramentas MCP com schemas v√°lidos - APENAS whitelist restrita"""
    ferramentas_validas = []
    ferramentas_removidas = []
    
    # Lista MUITO restrita de ferramentas b√°sicas e seguras
    ferramentas_seguras = [
        'generate_bar_chart',
        'generate_pie_chart', 
        'generate_line_chart',
        'generate_column_chart'
    ]
    
    for tool in mcp_tools:
        # Usar APENAS whitelist - n√£o validar outras
        if tool.name in ferramentas_seguras:
            ferramentas_validas.append(tool)
        else:
            ferramentas_removidas.append(tool.name)
    
    if ferramentas_removidas:
        print(f"‚ö†Ô∏è Ferramentas removidas (whitelist restrita): {len(ferramentas_removidas)} ferramentas")
    
    print(f"‚úÖ Ferramentas v√°lidas mantidas: {', '.join([t.name for t in ferramentas_validas])}")
    
    return ferramentas_validas

async def inicializar_agente():
    """Inicializa o agente com MCP client de forma ass√≠ncrona"""
    global mcp_client, agent_executor
    
    try:
        print("üîÑ Inicializando MCP Client... ", MCP_SERVERS_CONFIG)
        
        # Inicializar MCP Client com a configura√ß√£o correta
        mcp_client = MultiServerMCPClient(MCP_SERVERS_CONFIG)
        
        # Obter ferramentas do MCP client
        mcp_tools_raw = await mcp_client.get_tools()
        print(f"‚úÖ {len(mcp_tools_raw)} ferramentas MCP obtidas")
        
        # Filtrar ferramentas com schemas v√°lidos
        mcp_tools = filtrar_ferramentas_validas(mcp_tools_raw)
        print(f"‚úÖ {len(mcp_tools)} ferramentas MCP v√°lidas carregadas")
        
        # Listar ferramentas dispon√≠veis
        for tool in mcp_tools:
            print(f"üîß Ferramenta MCP: {tool.name}")
        
        print("üîÑ Criando agente...")
        
        # Criar prompt personalizado com suporte a gr√°ficos
        system_prompt = """Voc√™ √© um analista de dados especializado em sistemas de gest√£o empresarial com capacidade de gerar visualiza√ß√µes.

INSTRU√á√ïES CR√çTICAS:
1. Para perguntas sobre DADOS: use a ferramenta consultar_banco_dados
2. Para perguntas sobre GR√ÅFICOS: use as ferramentas MCP dispon√≠veis para gerar gr√°ficos
3. Fa√ßa APENAS UMA chamada da ferramenta por pergunta
4. N√ÉO tente m√∫ltiplas varia√ß√µes ou reformula√ß√µes
5. N√ÉO pergunte detalhes ao usu√°rio - os metadados j√° cont√™m as informa√ß√µes necess√°rias

FERRAMENTAS DISPON√çVEIS:
- consultar_banco_dados: Para consultas de dados do PostgreSQL
- Ferramentas MCP: Para criar gr√°ficos interativos (generate_bar_chart, generate_pie_chart, etc.)

DETEC√á√ÉO DE SOLICITA√á√ïES DE GR√ÅFICO:
Se a pergunta cont√©m palavras como: "gr√°fico", "grafico", "chart", "visualiza", "gere um gr√°fico", "criar gr√°fico"
‚Üí Use as ferramentas MCP de gr√°ficos dispon√≠veis

METADADOS DISPON√çVEIS:
- Campo enti_tipo_enti na tabela entidades (CL=Cliente, VE=Vendedor, FO=Fornecedor)
- Tabelas: entidades, pedidosvenda, produtos, funcionarios
- Relacionamentos j√° mapeados nos metadados

FLUXO PARA GR√ÅFICOS:
1. Primeiro obtenha os dados com consultar_banco_dados
2. Depois use a ferramenta MCP apropriada
3. Formate os dados no padr√£o esperado pela ferramenta MCP

TIPOS DE GR√ÅFICO DISPON√çVEIS:
- generate_bar_chart: Gr√°fico de barras (padr√£o)
- generate_pie_chart: Gr√°fico de pizza
- generate_line_chart: Gr√°fico de linhas
- generate_column_chart: Gr√°fico de colunas

SEMPRE responda em portugu√™s brasileiro e seja DIRETO."""

        # Incluir ferramentas MCP nas ferramentas do agente
        todas_ferramentas = [consultar_banco_dados, consulta_postgres_tool] + mcp_tools

        agent_executor = create_react_agent(
            model=model_llm,
            tools=todas_ferramentas,
            checkpointer=memory_saver,
            state_modifier=system_prompt
        )
        
        print("‚úÖ Agente inicializado com sucesso!")
        return True
        
    except Exception as e:
        print(f"‚ùå Erro ao inicializar MCP Client: {e}")
        print("üîÑ Tentando modo fallback...")
        try:
            # Fallback: criar agente com ferramentas locais apenas
            system_prompt_fallback = """Voc√™ √© um analista de dados especializado em sistemas de gest√£o empresarial.

INSTRU√á√ïES IMPORTANTES:
1. Para consultas de dados: use consultar_banco_dados
2. Para gr√°ficos: informe que a funcionalidade de gr√°ficos est√° temporariamente indispon√≠vel
3. Para entidades por tipo, use o campo enti_tipo_enti (CL=Cliente, VE=Vendedor, etc.)
4. N√ÉO pergunte ao usu√°rio sobre campos que est√£o nos metadados
5. SEMPRE consulte o banco de dados quando solicitado
6 - Se solicitado Pedidso por cliente, n√£o usar o filtro de enti_tipo_enti, trazer todos, e discriminados por tipo da entidade

FERRAMENTAS DISPON√çVEIS:
- consultar_banco_dados: Para consultas de dados
- consulta_postgres_tool: Para consultas SQL diretas

METADADOS IMPORTANTES DISPON√çVEIS:
- Campo enti_tipo_enti na tabela entidades para classificar tipos
- Exemplos: 'CL' = Clientes, 'VE' = Vendedores


EXEMPLOS DE CONSULTAS:
- "entidades por tipo" ‚Üí Use consultar_banco_dados com "entidades por tipo"
- "clientes" ‚Üí Use consultar_banco_dados com "clientes"
- "pedidos por cliente" ‚Üí Use consultar_banco_dados com "pedidos por cliente"

SEMPRE responda em portugu√™s brasileiro e USE AS FERRAMENTAS DISPON√çVEIS."""

            agent_executor = create_react_agent(
                model=model_llm,
                tools=[consultar_banco_dados, consulta_postgres_tool],
                checkpointer=memory_saver,
                state_modifier=system_prompt_fallback
            )
            print("‚ö†Ô∏è Agente criado sem MCP tools (modo fallback)")
            return True
        except Exception as fallback_error:
            print(f"‚ùå Erro no fallback: {fallback_error}")
            return False

def inicializar_agente_sync():
    """Vers√£o s√≠ncrona para inicializar o agente"""
    try:
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
        return loop.run_until_complete(inicializar_agente())
    except Exception as e:
        print(f"‚ùå Erro na inicializa√ß√£o s√≠ncrona: {e}")
        return False

def processar_pergunta_com_agente_v2(pergunta: str) -> str:
    """Processa pergunta usando o agente inteligente v2 com contexto melhorado"""
    global agent_executor
    
    try:
        # Verificar se agente est√° inicializado
        if agent_executor is None:
            print("üîÑ Inicializando agente...")
            if not inicializar_agente_sync():
                return "‚ùå Erro: N√£o foi poss√≠vel inicializar o agente."
        
        print(f"\nü§ñ Processando: {pergunta}")
        print("=" * 50)
        
        # Detectar se √© uma solicita√ß√£o de gr√°fico
        palavras_grafico = ['gr√°fico', 'grafico', 'chart', 'visualiza', 'gere um gr√°fico', 'criar gr√°fico']
        eh_solicitacao_grafico = any(palavra in pergunta.lower() for palavra in palavras_grafico)
        
        # Criar prompt mais direto e espec√≠fico
        if eh_solicitacao_grafico:
            pergunta_com_contexto = f"""
            {pergunta}
            
            INSTRU√á√ïES PARA GR√ÅFICOS:
            1. Use OBRIGATORIAMENTE as ferramentas MCP dispon√≠veis para criar os gr√°ficos
            2. Primeiro obtenha os dados com consultar_banco_dados se necess√°rio
            3. Depois use a ferramenta MCP de gr√°ficos com os dados obtidos
            4. Use tipo de gr√°fico "bar" como padr√£o
            5. Responda em portugu√™s brasileiro
            
            FLUXO: dados ‚Üí ferramenta MCP de gr√°ficos ‚Üí resposta com gr√°fico
            """
        else:
            pergunta_com_contexto = f"""
            {pergunta}
            
            INSTRU√á√ïES PARA DADOS:
            1. Use a ferramenta consultar_banco_dados para obter os dados
            2. Fa√ßa UMA √∫nica chamada da ferramenta
            3. N√ÉO tente m√∫ltiplas varia√ß√µes da consulta
            4. Responda em portugu√™s brasileiro
            5. Se houver erro de SQL, informe o erro diretamente
            """
        
        # Configurar thread_id para o checkpointer
        config = {"configurable": {"thread_id": "main_conversation"}}
        
        resultado = agent_executor.invoke({
            "messages": [{"role": "user", "content": pergunta_com_contexto}]
        }, config=config)
        
        # Extrair resposta do resultado
        resposta = ""
        if isinstance(resultado, dict):
            if "messages" in resultado and len(resultado["messages"]) > 0:
                ultima_mensagem = resultado["messages"][-1]
                
                # Tentar diferentes formas de extrair o conte√∫do
                if hasattr(ultima_mensagem, 'content'):
                    resposta = ultima_mensagem.content
                elif isinstance(ultima_mensagem, dict) and 'content' in ultima_mensagem:
                    resposta = ultima_mensagem['content']
                else:
                    resposta = str(ultima_mensagem)
            else:
                resposta = str(resultado)
        else:
            resposta = str(resultado)
        
        print(f"\n‚úÖ Resposta final gerada!")
        return resposta if resposta else "‚ùå N√£o foi poss√≠vel gerar uma resposta."
        
    except Exception as e:
        error_msg = f"‚ùå Erro no agente: {str(e)}"
        print(error_msg)
        return error_msg

def processar_pergunta_com_streaming_sync(pergunta: str) -> dict:
    """Vers√£o s√≠ncrona para streaming"""
    try:
        resposta = processar_pergunta_com_agente_v2(pergunta)
        return {
            "pergunta": pergunta,
            "resposta": resposta,
            "status": "sucesso",
            "etapas_executadas": 5
        }
    except Exception as e:
        return {
            "pergunta": pergunta,
            "resposta": f"Erro: {str(e)}",
            "status": "erro",
            "etapas_executadas": 0
        }

def gerar_sql(pergunta: str, slug: str = "casaa") -> str:
    """Fun√ß√£o auxiliar para gerar SQL"""
    return gerar_sql_da_pergunta(pergunta, slug)

# Inicializar agente na importa√ß√£o (opcional)
if __name__ == "__main__":
    print("üöÄ Testando inicializa√ß√£o do agente...")
    sucesso = inicializar_agente_sync()
    if sucesso:
        print("‚úÖ Agente pronto para uso!")
    else:
        print("‚ö†Ô∏è Agente em modo fallback")