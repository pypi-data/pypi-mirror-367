"""Product-related data models for Revenium MCP server.

This module contains all data models related to products, plans, tiers,
and pricing structures in the Revenium platform.
"""


from decimal import Decimal
from enum import Enum
from typing import Any, Dict, List, Optional, Union

from pydantic import Field, field_validator, model_validator

# Import removed enums from original models.py for backward compatibility
from ..models import AggregationType, BillingPeriod, Currency, TrialPeriod
from .base import (
    BaseReveniumModel,
    IdentifierMixin,
    MetadataMixin,
    RatingAggregationType,
    TimestampMixin,
    validate_email_address,
    validate_non_empty_string,
    validate_positive_number,
)

# Product-specific enumerations


class ProductStatus(str, Enum):
    """Product status enumeration."""

    ACTIVE = "active"
    INACTIVE = "inactive"
    DRAFT = "draft"
    ARCHIVED = "archived"


class PlanType(str, Enum):
    """Plan type enumeration for Revenium API."""

    SUBSCRIPTION = "SUBSCRIPTION"  # CHARGE deprecated as of 2024


# Product pricing models


class SetupFee(BaseReveniumModel):
    """Setup fee model for product plans."""

    name: str = Field(..., description="Setup fee name")
    amount: Union[int, float, Decimal] = Field(..., description="Fee amount")
    currency: Currency = Field(..., description="Fee currency")
    description: Optional[str] = Field(None, description="Fee description")
    one_time: bool = Field(True, description="Whether this is a one-time fee")

    @field_validator("amount")
    @classmethod
    def validate_amount(cls, v):
        """Validate amount is non-negative."""
        return validate_positive_number(v, "amount")


class Element(BaseReveniumModel):
    """Metering element model for product plans."""

    metering_element_definition_id: str = Field(..., description="Reference to metering definition")
    name: str = Field(..., description="Element name")
    description: Optional[str] = Field(None, description="Element description")
    unit_of_measure: Optional[str] = Field(None, description="Measurement unit")
    aggregation_type: Optional[AggregationType] = Field(None, description="How usage is aggregated")

    @field_validator("name")
    @classmethod
    def validate_name(cls, v):
        """Validate name is not empty."""
        return validate_non_empty_string(v, "name")


class RatingAggregation(BaseReveniumModel):
    """Rating aggregation model for product plans."""

    name: str = Field(..., description="Aggregation name")
    type: RatingAggregationType = Field(..., description="Aggregation type")
    metering_element_id: str = Field(..., description="Reference to metering element")
    period: Optional[BillingPeriod] = Field(None, description="Aggregation period")
    filters: Optional[Dict[str, Any]] = Field(None, description="Optional filters for aggregation")

    @field_validator("name")
    @classmethod
    def validate_name(cls, v):
        """Validate name is not empty."""
        return validate_non_empty_string(v, "name")


class Tier(BaseReveniumModel):
    """Pricing tier model for product plans."""

    name: str = Field(..., description="Tier name")
    starting_from: Union[int, float, Decimal] = Field(
        0, description="Lower bound of tier range (auto-generated by API)"
    )
    up_to: Optional[Union[int, float, Decimal]] = Field(
        ..., description="Upper bound of tier range (null for unlimited)"
    )
    unit_amount: Optional[Union[int, float, Decimal]] = Field(
        None, description="Price per unit in this tier"
    )
    flat_amount: Optional[Union[int, float, Decimal]] = Field(
        None, description="Flat fee for this tier"
    )

    @field_validator("name")
    @classmethod
    def validate_name(cls, v):
        """Validate name is not empty."""
        return validate_non_empty_string(v, "name")

    @model_validator(mode="after")
    def validate_pricing_fields(self):
        """Validate that either unit_amount or flat_amount is provided."""
        if self.unit_amount is None and self.flat_amount is None:
            raise ValueError("Either unit_amount or flat_amount must be provided")
        return self

    @field_validator("starting_from")
    @classmethod
    def validate_starting_from(cls, v):
        """Validate starting_from is non-negative."""
        if v < 0:
            raise ValueError("starting_from must be non-negative")
        return v

    @field_validator("up_to")
    @classmethod
    def validate_up_to(cls, v, info):
        """Validate up_to is greater than starting_from if provided."""
        if v is not None and "starting_from" in info.data:
            starting_from = info.data["starting_from"]
            if v <= starting_from:
                raise ValueError("up_to must be greater than starting_from")
        return v

    @field_validator("unit_amount")
    @classmethod
    def validate_unit_amount(cls, v):
        """Validate unit_amount is non-negative."""
        if v < 0:
            raise ValueError("unit_amount must be non-negative")
        return v

    @field_validator("flat_amount")
    @classmethod
    def validate_flat_amount(cls, v):
        """Validate flat_amount is non-negative if provided."""
        if v is not None and v < 0:
            raise ValueError("flat_amount must be non-negative")
        return v


class Plan(BaseReveniumModel):
    """Plan model for product pricing structure."""

    type: PlanType = Field(..., description="Plan type (SUBSCRIPTION only - CHARGE deprecated)")
    name: str = Field(..., description="Plan name")
    currency: Currency = Field(..., description="ISO currency code")
    period: Optional[BillingPeriod] = Field(None, description="Billing period")
    period_count: int = Field(1, description="Number of periods")
    trial_period: Optional[TrialPeriod] = Field(None, description="Trial period type")
    trial_period_count: Optional[int] = Field(None, description="Trial period count")
    charge: Union[int, float, Decimal] = Field(0, description="Fixed charge amount")
    graduated: bool = Field(False, description="Boolean for tier graduation")
    pre_pay_all_flat_rates: bool = Field(False, description="Upfront payment flag")
    tiers: List[Tier] = Field(..., description="Array of pricing tiers")
    elements: List[Element] = Field(default_factory=list, description="Array of metering elements")
    setup_fees: List[SetupFee] = Field(default_factory=list, description="Array of setup fees")
    rating_aggregations: List[RatingAggregation] = Field(
        default_factory=list, description="Array of rating aggregations"
    )

    @field_validator("name")
    @classmethod
    def validate_name(cls, v):
        """Validate name is not empty."""
        return validate_non_empty_string(v, "name")

    @field_validator("tiers")
    @classmethod
    def validate_tiers(cls, v):
        """Validate that at least one tier is provided."""
        if not v or len(v) == 0:
            raise ValueError("At least one tier is required")
        return v

    @field_validator("period_count")
    @classmethod
    def validate_period_count(cls, v):
        """Validate period count is positive."""
        if v is not None and v <= 0:
            raise ValueError("period_count must be positive")
        return v

    @field_validator("trial_period_count")
    @classmethod
    def validate_trial_period_count(cls, v):
        """Validate trial period count is positive."""
        if v is not None and v <= 0:
            raise ValueError("trial_period_count must be positive")
        return v

    @field_validator("charge")
    @classmethod
    def validate_charge(cls, v):
        """Validate charge is non-negative."""
        if v < 0:
            raise ValueError("charge must be non-negative")
        return v


class Product(BaseReveniumModel, TimestampMixin, IdentifierMixin, MetadataMixin):
    """Product model representing a Revenium product with enhanced API compatibility."""

    # Core product fields
    name: str = Field(..., description="Product name")
    description: Optional[str] = Field(None, description="Product description")
    status: ProductStatus = Field(ProductStatus.ACTIVE, description="Product status")
    version: str = Field(..., description="Product version")

    # Required API fields
    plan: Plan = Field(..., description="Product pricing plan")

    # Optional API fields
    source_ids: List[str] = Field(default_factory=list, description="Associated source IDs")
    sla_ids: List[str] = Field(default_factory=list, description="Associated SLA IDs")
    custom_pricing_rule_ids: List[str] = Field(
        default_factory=list, description="Custom pricing rule IDs"
    )
    notification_addresses_on_invoice: List[str] = Field(
        default_factory=list, description="Invoice notification addresses"
    )
    tags: List[str] = Field(default_factory=list, description="Product tags")
    terms: List[str] = Field(default_factory=list, description="Product terms")
    metering_models: List[str] = Field(default_factory=list, description="Metering model IDs")
    coming_soon: bool = Field(False, description="Whether product is coming soon")

    @field_validator("name")
    @classmethod
    def validate_name(cls, v):
        """Validate name is not empty."""
        return validate_non_empty_string(v, "name")

    @field_validator("version")
    @classmethod
    def validate_version(cls, v):
        """Validate version format."""
        if not v or not v.strip():
            raise ValueError("Version cannot be empty")
        return v.strip()

    @field_validator("notification_addresses_on_invoice")
    @classmethod
    def validate_notification_addresses(cls, v):
        """Validate email addresses in notification list."""
        for email in v:
            validate_email_address(email)
        return v

    @classmethod
    def create_simple_product(
        cls,
        name: str,
        description: Optional[str] = None,
        version: str = "1.0.0",
        currency: Currency = Currency.USD,
        unit_amount: Union[int, float, Decimal] = 0,
    ) -> "Product":
        """Create a simple product with minimal required structure."""

        # Create a basic tier
        basic_tier = Tier(
            name="Basic Tier",
            starting_from=0,
            up_to=None,
            unit_amount=unit_amount,
            flat_amount=None
        )

        # Create a basic plan
        basic_plan = Plan(
            type=PlanType.SUBSCRIPTION,
            name=f"{name} Plan",
            currency=currency,
            period=None,
            period_count=1,
            trial_period=None,
            trial_period_count=None,
            charge=0,
            graduated=False,
            pre_pay_all_flat_rates=False,
            tiers=[basic_tier]
        )

        return cls(
            name=name,
            description=description or f"Simple product: {name}",
            version=version,
            plan=basic_plan,
            coming_soon=False,
            # Mixin fields with defaults
            metadata=None,
            id=None,
            created_at=None,
            updated_at=None,
            status=ProductStatus.ACTIVE,
        )

    @classmethod
    def create_subscription_product(
        cls,
        name: str,
        description: Optional[str] = None,
        version: str = "1.0.0",
        currency: Currency = Currency.USD,
        monthly_amount: Union[int, float, Decimal] = 0,
        trial_days: Optional[int] = None,
    ) -> "Product":
        """Create a subscription product with monthly billing."""

        # Create a subscription tier
        subscription_tier = Tier(
            name="Monthly Tier",
            starting_from=0,
            up_to=None,
            unit_amount=monthly_amount,
            flat_amount=monthly_amount,
        )

        # Create a subscription plan
        subscription_plan = Plan(
            type=PlanType.SUBSCRIPTION,
            name=f"{name} Subscription",
            currency=currency,
            period=BillingPeriod.MONTH,
            period_count=1,
            trial_period=TrialPeriod.DAY if trial_days else None,
            trial_period_count=trial_days,
            charge=0,
            graduated=False,
            pre_pay_all_flat_rates=False,
            tiers=[subscription_tier],
        )

        return cls(
            name=name,
            description=description or f"Subscription product: {name}",
            version=version,
            plan=subscription_plan,
            coming_soon=False,
            # Mixin fields with defaults
            metadata=None,
            id=None,
            created_at=None,
            updated_at=None,
            status=ProductStatus.ACTIVE,
        )
