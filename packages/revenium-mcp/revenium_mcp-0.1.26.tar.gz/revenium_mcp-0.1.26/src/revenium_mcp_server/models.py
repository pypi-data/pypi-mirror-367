"""Pydantic models for Revenium Platform API data structures.

This module contains data models that represent the structure of data
returned by Revenium's platform API endpoints.
"""

from datetime import datetime
from decimal import Decimal
from enum import Enum
from typing import Any, Dict, List, Literal, Optional, Union

from pydantic import BaseModel, ConfigDict, Field, field_validator, model_validator


class BaseReveniumModel(BaseModel):
    """Base model for all Revenium API responses."""

    model_config = ConfigDict(
        extra="allow",  # Allow extra fields from API
        str_strip_whitespace=True,
        validate_assignment=True,
    )


class ProductStatus(str, Enum):
    """Product status enumeration."""

    ACTIVE = "active"
    INACTIVE = "inactive"
    DRAFT = "draft"
    ARCHIVED = "archived"


# New Product-related Enums for API Compatibility


class PlanType(str, Enum):
    """Plan type enumeration for Revenium API."""

    SUBSCRIPTION = "SUBSCRIPTION"  # CHARGE deprecated as of 2024


class Currency(str, Enum):
    """Currency enumeration for Revenium API."""

    USD = "USD"
    EUR = "EUR"
    GBP = "GBP"
    CAD = "CAD"
    AUD = "AUD"
    JPY = "JPY"
    CNY = "CNY"
    MXN = "MXN"
    COP = "COP"
    ARS = "ARS"
    ZMW = "ZMW"


class BillingPeriod(str, Enum):
    """Billing period enumeration for Revenium API."""

    MONTH = "MONTH"
    YEAR = "YEAR"
    QUARTER = "QUARTER"
    WEEK = "WEEK"
    DAY = "DAY"


class TrialPeriod(str, Enum):
    """Trial period enumeration for Revenium API."""

    DAY = "DAY"
    WEEK = "WEEK"
    MONTH = "MONTH"


class AggregationType(str, Enum):
    """Aggregation type enumeration for metering elements."""

    SUM = "SUM"
    COUNT = "COUNT"
    MAX = "MAX"
    MIN = "MIN"
    AVERAGE = "AVERAGE"
    LAST = "LAST"


class RatingAggregationType(str, Enum):
    """Rating aggregation type enumeration."""

    SUM = "SUM"
    COUNT = "COUNT"
    MAX = "MAX"
    MIN = "MIN"
    AVERAGE = "AVERAGE"


class PaymentSource(str, Enum):
    """Payment source enumeration for Revenium API.

    DOCUMENTED_OPERATIONAL_ENUM: These are system-level configuration values
    with no API discovery endpoint. Exception to no-hardcoding rule is documented
    and justified for operational/infrastructure values.

    Business Meanings:
    - INVOICE_ONLY_NO_PAYMENT: Send invoices, customers pay manually outside system, no payment tracking
    - EXTERNAL_PAYMENT_NOTIFICATION: Send invoices, mark unpaid until external system confirms payment
    """

    INVOICE_ONLY_NO_PAYMENT = "INVOICE_ONLY_NO_PAYMENT"  # Default: Manual invoice payment
    EXTERNAL_PAYMENT_NOTIFICATION = "EXTERNAL_PAYMENT_NOTIFICATION"  # Tracked invoice payment


# New Product-related Models for API Compatibility


class SetupFee(BaseReveniumModel):
    """Setup fee model for product plans."""

    name: str = Field(..., description="Setup fee name")
    amount: Union[int, float, Decimal] = Field(..., description="Fee amount")
    currency: Currency = Field(..., description="Fee currency")
    description: Optional[str] = Field(None, description="Fee description")
    one_time: bool = Field(True, description="Whether this is a one-time fee")


class Element(BaseReveniumModel):
    """Metering element model for product plans."""

    metering_element_definition_id: str = Field(..., description="Reference to metering definition")
    name: str = Field(..., description="Element name")
    description: Optional[str] = Field(None, description="Element description")
    unit_of_measure: Optional[str] = Field(None, description="Measurement unit")
    aggregation_type: Optional[AggregationType] = Field(None, description="How usage is aggregated")


class RatingAggregation(BaseReveniumModel):
    """Rating aggregation model for product plans."""

    name: str = Field(..., description="Aggregation name")
    type: RatingAggregationType = Field(..., description="Aggregation type")
    metering_element_id: str = Field(..., description="Reference to metering element")
    period: Optional[BillingPeriod] = Field(None, description="Aggregation period")
    filters: Optional[Dict[str, Any]] = Field(None, description="Optional filters for aggregation")


class Tier(BaseReveniumModel):
    """Pricing tier model for product plans."""

    name: str = Field(..., description="Tier name")
    up_to: Optional[Union[int, float, Decimal]] = Field(
        ..., description="Upper bound of tier range (null for unlimited)"
    )
    unit_amount: Optional[Union[int, float, Decimal]] = Field(
        None, description="Price per unit in this tier"
    )
    flat_amount: Optional[Union[int, float, Decimal]] = Field(
        None, description="Flat fee for this tier"
    )

    # Note: starting_from is auto-generated by API and should not be included in user input

    @model_validator(mode="after")
    def validate_pricing_fields(self):
        """Validate that either unit_amount or flat_amount is provided."""
        if self.unit_amount is None and self.flat_amount is None:
            raise ValueError("Either unit_amount or flat_amount must be provided")
        return self


class Plan(BaseReveniumModel):
    """Plan model for product pricing structure."""

    type: PlanType = Field(..., description="Plan type (SUBSCRIPTION only - CHARGE deprecated)")
    name: str = Field(..., description="Plan name")
    currency: Currency = Field(..., description="ISO currency code")
    period: Optional[BillingPeriod] = Field(None, description="Billing period")
    period_count: int = Field(1, description="Number of periods")
    trial_period: Optional[TrialPeriod] = Field(None, description="Trial period type")
    trial_period_count: Optional[int] = Field(None, description="Trial period count")
    charge: Union[int, float, Decimal] = Field(0, description="Fixed charge amount")
    graduated: bool = Field(False, description="Boolean for tier graduation")
    pre_pay_all_flat_rates: bool = Field(False, description="Upfront payment flag")
    tiers: List[Tier] = Field(..., description="Array of pricing tiers")
    elements: List[Element] = Field(default_factory=list, description="Array of metering elements")
    setup_fees: List[SetupFee] = Field(default_factory=list, description="Array of setup fees")
    rating_aggregations: List[RatingAggregation] = Field(
        default_factory=list, description="Array of rating aggregations"
    )

    @field_validator("tiers")
    @classmethod
    def validate_tiers(cls, v):
        """Validate that at least one tier is provided."""
        if not v or len(v) == 0:
            raise ValueError("At least one tier is required")
        return v

    @field_validator("period_count")
    @classmethod
    def validate_period_count(cls, v):
        """Validate period count is positive."""
        if v is not None and v <= 0:
            raise ValueError("period_count must be positive")
        return v

    @field_validator("trial_period_count")
    @classmethod
    def validate_trial_period_count(cls, v):
        """Validate trial period count is positive."""
        if v is not None and v <= 0:
            raise ValueError("trial_period_count must be positive")
        return v


class Product(BaseReveniumModel):
    """Product model representing a Revenium product with enhanced API compatibility."""

    # Existing fields
    id: Optional[str] = Field(None, description="Product ID")
    name: str = Field(..., description="Product name")
    description: Optional[str] = Field(None, description="Product description")
    status: ProductStatus = Field(ProductStatus.ACTIVE, description="Product status")
    created_at: Optional[datetime] = Field(None, description="Creation timestamp")
    updated_at: Optional[datetime] = Field(None, description="Last update timestamp")
    metadata: Optional[Dict[str, Any]] = Field(None, description="Additional metadata")

    # New required fields for API compatibility
    plan: Plan = Field(..., description="Product pricing plan")
    version: str = Field(..., description="Product version")
    source_ids: List[str] = Field(default_factory=list, description="Associated source IDs")
    sla_ids: List[str] = Field(default_factory=list, description="Associated SLA IDs")
    custom_pricing_rule_ids: List[str] = Field(
        default_factory=list, description="Custom pricing rule IDs"
    )
    notification_addresses_on_invoice: List[str] = Field(
        default_factory=list, description="Invoice notification addresses"
    )
    tags: List[str] = Field(default_factory=list, description="Product tags")
    terms: List[str] = Field(default_factory=list, description="Product terms")
    metering_models: List[str] = Field(default_factory=list, description="Metering model IDs")
    coming_soon: bool = Field(False, description="Whether product is coming soon")

    @field_validator("version")
    @classmethod
    def validate_version(cls, v):
        """Validate version format."""
        if not v or not v.strip():
            raise ValueError("Version cannot be empty")
        return v.strip()

    @field_validator("notification_addresses_on_invoice")
    @classmethod
    def validate_notification_addresses(cls, v):
        """Validate email addresses in notification list."""
        import re

        email_pattern = re.compile(r"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$")
        for email in v:
            if not email_pattern.match(email):
                raise ValueError(f"Invalid email address: {email}")
        return v

    @classmethod
    def create_simple_product(
        cls,
        name: str,
        description: Optional[str] = None,
        version: str = "1.0.0",
        currency: Currency = Currency.USD,
        unit_amount: Union[int, float, Decimal] = 0,
    ) -> "Product":
        """Create a simple product with minimal required structure."""
        # Create a basic tier
        basic_tier = Tier(name="Basic Tier", up_to=None, unit_amount=unit_amount)

        # Create a basic plan
        basic_plan = Plan(
            type=PlanType.SUBSCRIPTION, name=f"{name} Plan", currency=currency, tiers=[basic_tier]
        )

        return cls(
            name=name,
            description=description or f"Simple product: {name}",
            version=version,
            plan=basic_plan,
            coming_soon=False,
        )

    @classmethod
    def create_subscription_product(
        cls,
        name: str,
        description: Optional[str] = None,
        version: str = "1.0.0",
        currency: Currency = Currency.USD,
        monthly_amount: Union[int, float, Decimal] = 0,
        trial_days: Optional[int] = None,
    ) -> "Product":
        """Create a subscription product with monthly billing."""
        # Create a subscription tier
        subscription_tier = Tier(
            name="Monthly Tier",
            up_to=None,  # Unlimited tier
            unit_amount=monthly_amount,
            flat_amount=monthly_amount,
        )

        # Create a subscription plan
        subscription_plan = Plan(
            type=PlanType.SUBSCRIPTION,
            name=f"{name} Subscription",
            currency=currency,
            period=BillingPeriod.MONTH,
            period_count=1,
            trial_period=TrialPeriod.DAY if trial_days else None,
            trial_period_count=trial_days,
            graduated=False,
            tiers=[subscription_tier],
        )

        return cls(
            name=name,
            description=description or f"Subscription product: {name}",
            version=version,
            plan=subscription_plan,
            coming_soon=False,
        )


class SubscriptionStatus(str, Enum):
    """Subscription status enumeration."""

    ACTIVE = "active"
    INACTIVE = "inactive"
    PENDING = "pending"
    CANCELLED = "cancelled"
    EXPIRED = "expired"


class Subscription(BaseReveniumModel):
    """Subscription model representing a Revenium subscription."""

    id: Optional[str] = Field(None, description="Subscription ID")
    product_id: str = Field(..., description="Associated product ID")
    name: str = Field(..., description="Subscription name")
    description: Optional[str] = Field(None, description="Subscription description")
    status: SubscriptionStatus = Field(SubscriptionStatus.ACTIVE, description="Subscription status")
    start_date: Optional[datetime] = Field(None, description="Subscription start date")
    end_date: Optional[datetime] = Field(None, description="Subscription end date")
    created_at: Optional[datetime] = Field(None, description="Creation timestamp")
    updated_at: Optional[datetime] = Field(None, description="Last update timestamp")
    metadata: Optional[Dict[str, Any]] = Field(None, description="Additional metadata")


class SourceType(str, Enum):
    """Source type enumeration."""

    API = "API"
    DATABASE = "DATABASE"
    FILE = "FILE"
    STREAM = "STREAM"
    WEBHOOK = "WEBHOOK"
    AI = "AI"  # Add AI type found in actual API


class Source(BaseReveniumModel):
    """Source model representing a Revenium data source.

    Note: The Revenium API does not include a status field for sources.
    Sources only have lifecycle timestamps (created/updated).
    """

    id: Optional[str] = Field(None, description="Source ID")
    name: str = Field(..., description="Source name")
    description: Optional[str] = Field(None, description="Source description")
    type: SourceType = Field(..., description="Source type (API, DATABASE, etc.)")
    sourceType: Optional[str] = Field(
        None, description="Source type classification (UNKNOWN, etc.)"
    )
    version: str = Field(..., description="Source version (required by API)")
    configuration: Optional[Dict[str, Any]] = Field(None, description="Source configuration")
    created_at: Optional[datetime] = Field(None, description="Creation timestamp")
    updated_at: Optional[datetime] = Field(None, description="Last update timestamp")
    metadata: Optional[Dict[str, Any]] = Field(None, description="Additional metadata")


class APIResponse(BaseReveniumModel):
    """Generic API response wrapper."""

    success: bool = Field(True, description="Whether the request was successful")
    data: Optional[Union[Dict[str, Any], List[Dict[str, Any]]]] = Field(
        None, description="Response data"
    )
    message: Optional[str] = Field(None, description="Response message")
    error: Optional[str] = Field(None, description="Error message if any")
    total: Optional[int] = Field(None, description="Total count for paginated responses")
    page: Optional[int] = Field(None, description="Current page for paginated responses")
    per_page: Optional[int] = Field(None, description="Items per page for paginated responses")


class ListResponse(BaseReveniumModel):
    """Response model for list operations."""

    items: List[Dict[str, Any]] = Field(default_factory=list, description="List of items")
    total: int = Field(0, description="Total number of items")
    page: int = Field(1, description="Current page number")
    per_page: int = Field(20, description="Items per page")
    has_more: bool = Field(False, description="Whether there are more pages")


# Customer Management Models


class UserStatus(str, Enum):
    """User status enumeration."""

    ACTIVE = "active"
    INACTIVE = "inactive"
    PENDING = "pending"
    SUSPENDED = "suspended"
    DELETED = "deleted"


class UserRole(str, Enum):
    """User role enumeration for Revenium API."""

    ROLE_TENANT_ADMIN = "ROLE_TENANT_ADMIN"
    ROLE_API_CONSUMER = "ROLE_API_CONSUMER"


class User(BaseReveniumModel):
    """User model representing a customer user account."""

    id: Optional[str] = Field(None, description="User ID")
    email: str = Field(..., description="User email address")
    first_name: Optional[str] = Field(None, description="User first name")
    last_name: Optional[str] = Field(None, description="User last name")
    full_name: Optional[str] = Field(None, description="User full name")
    status: UserStatus = Field(UserStatus.ACTIVE, description="User status")
    organization_id: Optional[str] = Field(None, description="Associated organization ID")
    team_id: Optional[str] = Field(None, description="Associated team ID")
    role: Optional[str] = Field(None, description="User role")
    permissions: Optional[List[str]] = Field(default_factory=list, description="User permissions")
    last_login: Optional[datetime] = Field(None, description="Last login timestamp")
    created_at: Optional[datetime] = Field(None, description="Creation timestamp")
    updated_at: Optional[datetime] = Field(None, description="Last update timestamp")
    metadata: Optional[Dict[str, Any]] = Field(None, description="Additional user metadata")


class SubscriberStatus(str, Enum):
    """Subscriber status enumeration."""

    ACTIVE = "active"
    INACTIVE = "inactive"
    TRIAL = "trial"
    EXPIRED = "expired"
    CANCELLED = "cancelled"


class Subscriber(BaseReveniumModel):
    """Subscriber model representing an active subscription holder."""

    id: Optional[str] = Field(None, description="Subscriber ID")
    user_id: Optional[str] = Field(None, description="Associated user ID")
    email: str = Field(..., description="Subscriber email address")
    name: Optional[str] = Field(None, description="Subscriber name")
    status: SubscriberStatus = Field(SubscriberStatus.ACTIVE, description="Subscriber status")
    subscription_ids: Optional[List[str]] = Field(
        default_factory=list, description="Associated subscription IDs"
    )
    organization_id: Optional[str] = Field(None, description="Associated organization ID")
    billing_address: Optional[Dict[str, Any]] = Field(
        None, description="Billing address information"
    )
    payment_method: Optional[Dict[str, Any]] = Field(None, description="Payment method information")
    trial_end_date: Optional[datetime] = Field(None, description="Trial end date")
    subscription_start_date: Optional[datetime] = Field(None, description="Subscription start date")
    last_billing_date: Optional[datetime] = Field(None, description="Last billing date")
    next_billing_date: Optional[datetime] = Field(None, description="Next billing date")
    created_at: Optional[datetime] = Field(None, description="Creation timestamp")
    updated_at: Optional[datetime] = Field(None, description="Last update timestamp")
    metadata: Optional[Dict[str, Any]] = Field(None, description="Additional subscriber metadata")


class OrganizationType(str, Enum):
    """Organization type enumeration."""

    ENTERPRISE = "enterprise"
    BUSINESS = "business"
    STARTUP = "startup"
    INDIVIDUAL = "individual"
    NON_PROFIT = "non_profit"
    GOVERNMENT = "government"


class OrganizationStatus(str, Enum):
    """Organization status enumeration."""

    ACTIVE = "active"
    INACTIVE = "inactive"
    PENDING = "pending"
    SUSPENDED = "suspended"
    DELETED = "deleted"


class Organization(BaseReveniumModel):
    """Organization model representing a customer organization."""

    id: Optional[str] = Field(None, description="Organization ID")
    name: str = Field(..., description="Organization name")
    display_name: Optional[str] = Field(None, description="Organization display name")
    description: Optional[str] = Field(None, description="Organization description")
    type: OrganizationType = Field(OrganizationType.BUSINESS, description="Organization type")
    status: OrganizationStatus = Field(OrganizationStatus.ACTIVE, description="Organization status")
    parent_organization_id: Optional[str] = Field(
        None, description="Parent organization ID for hierarchies"
    )
    website: Optional[str] = Field(None, description="Organization website")
    industry: Optional[str] = Field(None, description="Organization industry")
    size: Optional[str] = Field(None, description="Organization size (e.g., '1-10', '11-50')")
    address: Optional[Dict[str, Any]] = Field(None, description="Organization address")
    contact_info: Optional[Dict[str, Any]] = Field(None, description="Contact information")
    billing_info: Optional[Dict[str, Any]] = Field(None, description="Billing information")
    tags: Optional[List[str]] = Field(default_factory=list, description="Organization tags")
    user_count: Optional[int] = Field(None, description="Number of users in organization")
    team_count: Optional[int] = Field(None, description="Number of teams in organization")
    subscription_count: Optional[int] = Field(None, description="Number of active subscriptions")
    created_at: Optional[datetime] = Field(None, description="Creation timestamp")
    updated_at: Optional[datetime] = Field(None, description="Last update timestamp")
    metadata: Optional[Dict[str, Any]] = Field(None, description="Additional organization metadata")


class TeamStatus(str, Enum):
    """Team status enumeration."""

    ACTIVE = "active"
    INACTIVE = "inactive"
    ARCHIVED = "archived"
    DELETED = "deleted"


class TeamRole(str, Enum):
    """Team role enumeration."""

    OWNER = "owner"
    ADMIN = "admin"
    MEMBER = "member"
    VIEWER = "viewer"
    GUEST = "guest"


class TeamMember(BaseReveniumModel):
    """Team member model."""

    user_id: str = Field(..., description="User ID")
    email: Optional[str] = Field(None, description="User email")
    name: Optional[str] = Field(None, description="User name")
    role: TeamRole = Field(TeamRole.MEMBER, description="Team role")
    joined_at: Optional[datetime] = Field(None, description="Date joined team")
    last_active: Optional[datetime] = Field(None, description="Last activity timestamp")


class Team(BaseReveniumModel):
    """Team model representing a team within an organization."""

    id: Optional[str] = Field(None, description="Team ID")
    name: str = Field(..., description="Team name")
    display_name: Optional[str] = Field(None, description="Team display name")
    description: Optional[str] = Field(None, description="Team description")
    status: TeamStatus = Field(TeamStatus.ACTIVE, description="Team status")
    organization_id: str = Field(..., description="Associated organization ID")
    parent_team_id: Optional[str] = Field(None, description="Parent team ID for hierarchies")
    owner_id: Optional[str] = Field(None, description="Team owner user ID")
    members: Optional[List[TeamMember]] = Field(default_factory=list, description="Team members")
    member_count: Optional[int] = Field(None, description="Number of team members")
    permissions: Optional[List[str]] = Field(default_factory=list, description="Team permissions")
    settings: Optional[Dict[str, Any]] = Field(None, description="Team settings")
    tags: Optional[List[str]] = Field(default_factory=list, description="Team tags")
    created_at: Optional[datetime] = Field(None, description="Creation timestamp")
    updated_at: Optional[datetime] = Field(None, description="Last update timestamp")
    metadata: Optional[Dict[str, Any]] = Field(None, description="Additional team metadata")


# Customer Analytics Models


class CustomerAnalytics(BaseReveniumModel):
    """Customer analytics aggregation model."""

    total_users: int = Field(0, description="Total number of users")
    active_users: int = Field(0, description="Number of active users")
    total_subscribers: int = Field(0, description="Total number of subscribers")
    active_subscribers: int = Field(0, description="Number of active subscribers")
    total_organizations: int = Field(0, description="Total number of organizations")
    active_organizations: int = Field(0, description="Number of active organizations")
    total_teams: int = Field(0, description="Total number of teams")
    active_teams: int = Field(0, description="Number of active teams")
    growth_metrics: Optional[Dict[str, Any]] = Field(None, description="Growth metrics")
    engagement_metrics: Optional[Dict[str, Any]] = Field(None, description="Engagement metrics")
    revenue_metrics: Optional[Dict[str, Any]] = Field(None, description="Revenue metrics")


class CustomerRelationship(BaseReveniumModel):
    """Model representing relationships between customer entities."""

    user_id: Optional[str] = Field(None, description="User ID")
    subscriber_id: Optional[str] = Field(None, description="Subscriber ID")
    organization_id: Optional[str] = Field(None, description="Organization ID")
    team_id: Optional[str] = Field(None, description="Team ID")
    subscription_ids: Optional[List[str]] = Field(
        default_factory=list, description="Related subscription IDs"
    )
    product_ids: Optional[List[str]] = Field(
        default_factory=list, description="Related product IDs"
    )
    source_ids: Optional[List[str]] = Field(default_factory=list, description="Related source IDs")
    relationship_type: str = Field(..., description="Type of relationship")
    strength: Optional[float] = Field(None, description="Relationship strength score")
    created_at: Optional[datetime] = Field(None, description="Relationship creation timestamp")
    updated_at: Optional[datetime] = Field(None, description="Last update timestamp")


# AI Anomaly and Alert Management Models


class AnomalyStatus(str, Enum):
    """AI Anomaly status enumeration."""

    ACTIVE = "active"
    INACTIVE = "inactive"
    ARCHIVED = "archived"
    DRAFT = "draft"


class AlertSeverity(str, Enum):
    """Alert severity enumeration."""

    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    CRITICAL = "critical"


class AlertStatus(str, Enum):
    """Alert status enumeration."""

    OPEN = "open"
    ACKNOWLEDGED = "acknowledged"
    INVESTIGATING = "investigating"
    RESOLVED = "resolved"
    CLOSED = "closed"
    FALSE_POSITIVE = "false_positive"


# New enums for correct API structure
class AlertType(str, Enum):
    """Alert type enumeration for Revenium API."""

    THRESHOLD = "THRESHOLD"
    CUMULATIVE_USAGE = "CUMULATIVE_USAGE"
    RELATIVE_CHANGE = "RELATIVE_CHANGE"


class MetricType(str, Enum):
    """Metric type enumeration for Revenium API - User validated metrics only.

    These metrics have been validated by users and confirmed to work with the Revenium API.
    This enum serves as the single source of truth for supported alert metrics.
    """

    TOTAL_COST = "TOTAL_COST"
    COST_PER_TRANSACTION = "COST_PER_TRANSACTION"
    TOKEN_COUNT = "TOKEN_COUNT"
    INPUT_TOKEN_COUNT = "INPUT_TOKEN_COUNT"
    OUTPUT_TOKEN_COUNT = "OUTPUT_TOKEN_COUNT"
    TOKENS_PER_MINUTE = "TOKENS_PER_MINUTE"
    REQUESTS_PER_MINUTE = "REQUESTS_PER_MINUTE"
    ERROR_RATE = "ERROR_RATE"
    ERROR_COUNT = "ERROR_COUNT"


class OperatorType(str, Enum):
    """Operator type enumeration for Revenium API."""

    GREATER_THAN = "GREATER_THAN"
    LESS_THAN = "LESS_THAN"
    GREATER_THAN_OR_EQUAL = "GREATER_THAN_OR_EQUAL"
    LESS_THAN_OR_EQUAL = "LESS_THAN_OR_EQUAL"
    EQUAL = "EQUAL"
    NOT_EQUAL = "NOT_EQUAL"
    CONTAINS = "CONTAINS"
    NOT_CONTAINS = "NOT_CONTAINS"


class PeriodDuration(str, Enum):
    """Period duration enumeration for Revenium API."""

    ONE_MINUTE = "ONE_MINUTE"
    FIVE_MINUTES = "FIVE_MINUTES"
    FIFTEEN_MINUTES = "FIFTEEN_MINUTES"
    THIRTY_MINUTES = "THIRTY_MINUTES"
    ONE_HOUR = "ONE_HOUR"
    TWELVE_HOURS = "TWELVE_HOURS"
    TWENTY_FOUR_HOURS = "TWENTY_FOUR_HOURS"
    SEVEN_DAYS = "SEVEN_DAYS"
    THIRTY_DAYS = "THIRTY_DAYS"
    DAILY = "DAILY"
    WEEKLY = "WEEKLY"
    MONTHLY = "MONTHLY"
    QUARTERLY = "QUARTERLY"


class GroupByDimension(str, Enum):
    """Group by dimension enumeration for Revenium API."""

    ORGANIZATION = "ORGANIZATION"
    CREDENTIAL = "CREDENTIAL"
    PRODUCT = "PRODUCT"
    MODEL = "MODEL"
    PROVIDER = "PROVIDER"
    AGENT = "AGENT"
    SUBSCRIBER = "SUBSCRIBER"


class TriggerDuration(str, Enum):
    """Trigger persistence duration enumeration for Revenium API."""

    ONE_MINUTE = "ONE_MINUTE"
    FIVE_MINUTES = "FIVE_MINUTES"
    FIFTEEN_MINUTES = "FIFTEEN_MINUTES"
    THIRTY_MINUTES = "THIRTY_MINUTES"
    ONE_HOUR = "ONE_HOUR"
    TWELVE_HOURS = "TWELVE_HOURS"
    TWENTY_FOUR_HOURS = "TWENTY_FOUR_HOURS"
    SEVEN_DAYS = "SEVEN_DAYS"
    THIRTY_DAYS = "THIRTY_DAYS"
    DAILY = "DAILY"
    WEEKLY = "WEEKLY"
    MONTHLY = "MONTHLY"
    QUARTERLY = "QUARTERLY"


# Advanced Configuration Models


class AlertFilter(BaseReveniumModel):
    """Model for alert filter configuration."""

    field: str = Field(..., description="Field name to filter on")
    operator: str = Field(..., description="Filter operator (equals, contains, etc.)")
    value: Union[str, int, float, bool] = Field(..., description="Filter value")

    @field_validator("field")
    @classmethod
    def validate_field(cls, v):
        """Validate filter field name."""
        allowed_fields = [
            "organization",
            "credential",
            "product",
            "model",
            "provider",
            "agent",
            "subscriber",
            "cost",
            "usage",
        ]
        if v not in allowed_fields:
            raise ValueError(f"Invalid filter field. Allowed: {', '.join(allowed_fields)}")
        return v

    @field_validator("operator")
    @classmethod
    def validate_operator(cls, v):
        """Validate filter operator."""
        allowed_operators = [
            "equals",
            "not_equals",
            "contains",
            "greater_than",
            "less_than",
            "starts_with",
            "ends_with",
        ]
        if v not in allowed_operators:
            raise ValueError(f"Invalid filter operator. Allowed: {', '.join(allowed_operators)}")
        return v


class SlackConfiguration(BaseReveniumModel):
    """Model for Slack notification configuration."""

    webhook_url: str = Field(..., description="Slack webhook URL")
    channel: Optional[str] = Field(None, description="Slack channel name")
    username: Optional[str] = Field(None, description="Bot username")
    icon_emoji: Optional[str] = Field(None, description="Bot icon emoji")

    @field_validator("webhook_url")
    @classmethod
    def validate_webhook_url(cls, v):
        """Validate Slack webhook URL."""
        if not v.startswith("https://hooks.slack.com/"):
            raise ValueError("Invalid Slack webhook URL format")
        return v


class WebhookConfiguration(BaseReveniumModel):
    """Model for webhook notification configuration."""

    url: str = Field(..., description="Webhook URL")
    method: str = Field(default="POST", description="HTTP method")
    headers: Optional[Dict[str, str]] = Field(default_factory=dict, description="Custom headers")
    auth_token: Optional[str] = Field(None, description="Authentication token")

    @field_validator("url")
    @classmethod
    def validate_url(cls, v):
        """Validate webhook URL."""
        if not v.startswith(("http://", "https://")):
            raise ValueError("Webhook URL must start with http:// or https://")
        return v

    @field_validator("method")
    @classmethod
    def validate_method(cls, v):
        """Validate HTTP method."""
        allowed_methods = ["GET", "POST", "PUT", "PATCH"]
        if v.upper() not in allowed_methods:
            raise ValueError(f"Invalid HTTP method. Allowed: {', '.join(allowed_methods)}")
        return v.upper()


class AdvancedAlertConfiguration(BaseReveniumModel):
    """Model for advanced alert configuration options."""

    filters: List[AlertFilter] = Field(default_factory=list, description="Alert filters")
    group_by: Optional[GroupByDimension] = Field(None, description="Grouping dimension")
    slack_configs: List[SlackConfiguration] = Field(
        default_factory=list, description="Slack configurations"
    )
    webhook_configs: List[WebhookConfiguration] = Field(
        default_factory=list, description="Webhook configurations"
    )
    trigger_duration: Optional[TriggerDuration] = Field(
        None, description="Trigger persistence duration"
    )
    is_percentage: Optional[bool] = Field(None, description="Whether threshold is a percentage")

    def to_api_format(self) -> Dict[str, Any]:
        """Convert to API format for anomaly creation."""
        api_data = {}

        # Convert filters to API format
        if self.filters:
            api_data["filters"] = [
                {"field": f.field, "operator": f.operator, "value": f.value} for f in self.filters
            ]
        else:
            api_data["filters"] = []

        # Convert groupBy
        if self.group_by:
            api_data["groupBy"] = self.group_by.value

        # Convert Slack configurations
        if self.slack_configs:
            api_data["slackConfigurations"] = [config.webhook_url for config in self.slack_configs]
        else:
            api_data["slackConfigurations"] = []

        # Convert webhook configurations
        if self.webhook_configs:
            api_data["webhook_enabled"] = [config.url for config in self.webhook_configs]
        else:
            api_data["webhook_enabled"] = []

        # Convert trigger duration
        if self.trigger_duration:
            api_data["triggerAfterPersistsDuration"] = self.trigger_duration.value

        # Convert percentage flag
        if self.is_percentage is not None:
            api_data["isPercentage"] = self.is_percentage

        return api_data


class DetectionRule(BaseReveniumModel):
    """Detection rule model for AI anomalies."""

    rule_type: str = Field(
        ..., description="Type of detection rule (e.g., 'threshold', 'pattern', 'statistical')"
    )
    metric: str = Field(..., description="Metric to monitor (e.g., 'cost', 'usage', 'latency')")
    operator: str = Field(..., description="Comparison operator (e.g., '>', '<', '>=', '<=', '==')")
    value: Union[float, int, str] = Field(..., description="Threshold value for comparison")
    time_window: Optional[str] = Field(
        None, description="Time window for evaluation (e.g., '5m', '1h', '1d')"
    )
    aggregation: Optional[str] = Field(
        None, description="Aggregation method (e.g., 'avg', 'sum', 'max', 'min')"
    )
    conditions: Optional[List[str]] = Field(
        default_factory=list, description="Additional conditions"
    )


class ThresholdViolation(BaseReveniumModel):
    """Threshold violation model for alerts."""

    metric: str = Field(..., description="Metric that violated threshold")
    threshold_value: Union[float, int, str] = Field(..., description="Expected threshold value")
    actual_value: Union[float, int, str] = Field(
        ..., description="Actual value that triggered violation"
    )
    operator: str = Field(..., description="Comparison operator used")
    violation_time: datetime = Field(..., description="When the violation occurred")
    duration: Optional[str] = Field(None, description="How long the violation lasted")


class AIAnomalyRequest(BaseReveniumModel):
    """AI Anomaly request model for creating anomalies via Revenium API.

    This model matches the exact structure expected by the Revenium API
    as documented in the API specification.
    """

    # Required fields per API specification
    name: str = Field(..., min_length=1, max_length=255, description="The name of the model")
    label: str = Field(..., min_length=1, max_length=255, description="The label of the model")
    teamId: str = Field(..., description="The team ID")
    alertType: str = Field(..., description="The alert type tracked by this monitor")
    metricType: str = Field(..., description="The ai metric tracked by this monitor")
    operatorType: str = Field(
        ..., description="The operator type used to make the comparison between the threshold value"
    )
    threshold: Union[float, int] = Field(
        ..., description="The number threshold that triggers the alert"
    )
    notificationAddresses: List[str] = Field(..., description="The email addresses of the alert")
    slackConfigurations: List[str] = Field(..., description="The slack addresses of the alert")
    periodDuration: str = Field(
        ...,
        description="Value that determines when the frequency of checks made to this alert monitor",
    )
    enabled: bool = Field(..., description="Disables the monitor without deleting it from db")
    filters: List[Dict[str, Any]] = Field(
        ..., description="The filters applied to limit the anomalies scope"
    )
    webhookConfigurations: List[str] = Field(
        ..., description="Webhook configurations for the anomaly to dispatch to"
    )

    # Optional fields per API specification
    isPercentage: Optional[bool] = Field(
        None, description="If the threshold represents a threshold"
    )
    description: Optional[str] = Field(None, description="The description of the alert monitor")
    groupBy: Optional[str] = Field(
        None, description="The group by dimension used to group the anomalies"
    )
    triggerAfterPersistsDuration: Optional[str] = Field(
        None, description="The duration after which the anomaly is triggered"
    )
    percentage: Optional[bool] = Field(None, description="Percentage flag")
    links: Optional[Dict[str, Any]] = Field(None, description="Links object", alias="_links")

    @field_validator("name")
    @classmethod
    def validate_name(cls, v):
        """Validate anomaly name."""
        if not v or not v.strip():
            raise ValueError("Anomaly name cannot be empty")
        if len(v.strip()) > 255:
            raise ValueError("Anomaly name cannot exceed 255 characters")
        return v.strip()

    @field_validator("teamId")
    @classmethod
    def validate_team_id(cls, v):
        """Validate team ID."""
        if not v or not v.strip():
            raise ValueError("Team ID is required and cannot be empty")
        return v.strip()

    @field_validator("threshold")
    @classmethod
    def validate_threshold(cls, v):
        """Validate threshold value."""
        if v is None:
            raise ValueError("Threshold value is required")
        if not isinstance(v, (int, float)):
            raise ValueError("Threshold must be a number")
        if v < 0:
            raise ValueError("Threshold cannot be negative")
        return v

    @field_validator("notificationAddresses")
    @classmethod
    def validate_notification_addresses(cls, v):
        """Validate notification email addresses."""
        if not v:
            raise ValueError("At least one notification address is required")

        import re

        email_pattern = re.compile(r"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$")

        for email in v:
            if not email or not email.strip():
                raise ValueError("Email addresses cannot be empty")
            if not email_pattern.match(email.strip()):
                raise ValueError(f"Invalid email address: {email}")

        return [email.strip() for email in v]

    @field_validator("slackConfigurations")
    @classmethod
    def validate_slack_configurations(cls, v):
        """Validate slack configurations."""
        # For now, just ensure it's a list - API expects array of strings
        if not isinstance(v, list):
            raise ValueError("Slack configurations must be a list")
        return v

    @field_validator("webhookConfigurations")
    @classmethod
    def validate_webhook_configurations(cls, v):
        """Validate webhook configurations."""
        # For now, just ensure it's a list - API expects array of strings
        if not isinstance(v, list):
            raise ValueError("Webhook configurations must be a list")
        return v

    @field_validator("filters")
    @classmethod
    def validate_filters(cls, v):
        """Validate filters array."""
        if not isinstance(v, list):
            raise ValueError("Filters must be a list")
        return v


class AIAnomaly(BaseReveniumModel):
    """AI Anomaly model representing the full anomaly response from Revenium API.

    This model represents the complete anomaly object as returned by the API,
    including both the request fields and additional response fields.
    """

    # Response-specific fields
    id: Optional[str] = Field(None, description="Anomaly ID")
    resourceType: Optional[str] = Field(None, description="Resource type")
    label: Optional[str] = Field(None, description="Anomaly label")
    created: Optional[datetime] = Field(None, description="Creation timestamp")
    updated: Optional[datetime] = Field(None, description="Last update timestamp")

    # Core anomaly fields (matching request structure)
    name: str = Field(..., description="The name of the model")
    label: Optional[str] = Field(None, description="The label of the model")
    teamId: Optional[str] = Field(None, description="The team ID")
    alertType: str = Field(..., description="The alert type tracked by this monitor")
    metricType: str = Field(..., description="The ai metric tracked by this monitor")
    operatorType: str = Field(
        ..., description="The operator type used to make the comparison between the threshold value"
    )
    threshold: Union[float, int] = Field(
        ..., description="The number threshold that triggers the alert"
    )
    notificationAddresses: List[str] = Field(
        default_factory=list, description="The email addresses of the alert"
    )
    slackConfigurations: List[str] = Field(
        default_factory=list, description="The slack addresses of the alert"
    )
    periodDuration: str = Field(
        ...,
        description="Value that determines when the frequency of checks made to this alert monitor",
    )
    enabled: bool = Field(True, description="Disables the monitor without deleting it from db")
    filters: List[Dict[str, Any]] = Field(
        default_factory=list, description="The filters applied to limit the anomalies scope"
    )
    webhookConfigurations: List[str] = Field(
        default_factory=list, description="Webhook configurations for the anomaly to dispatch to"
    )

    # Optional fields
    isPercentage: Optional[bool] = Field(
        None, description="If the threshold represents a threshold"
    )
    description: Optional[str] = Field(None, description="The description of the alert monitor")
    groupBy: Optional[str] = Field(
        None, description="The group by dimension used to group the anomalies"
    )
    triggerAfterPersistsDuration: Optional[str] = Field(
        None, description="The duration after which the anomaly is triggered"
    )
    percentage: Optional[bool] = Field(None, description="Percentage flag")

    # Additional response fields
    firing: Optional[bool] = Field(None, description="Whether anomaly is currently firing")
    team: Optional[Dict[str, Any]] = Field(None, description="Associated team information")
    links: Optional[Dict[str, Any]] = Field(None, description="API links", alias="_links")


# Legacy model for backward compatibility
class AIAnomalyLegacy(BaseReveniumModel):
    """Legacy AI Anomaly model (kept for backward compatibility)."""

    id: Optional[str] = Field(None, description="Anomaly ID")
    name: str = Field(..., min_length=1, max_length=255, description="Anomaly name")
    description: Optional[str] = Field(None, max_length=1000, description="Anomaly description")
    status: AnomalyStatus = Field(AnomalyStatus.ACTIVE, description="Anomaly status")
    detection_rules: List[DetectionRule] = Field(
        ..., min_length=1, description="Detection rules for the anomaly"
    )
    thresholds: Dict[str, Union[float, int, str]] = Field(
        ..., description="Threshold configurations"
    )
    conditions: Optional[List[str]] = Field(
        default_factory=list, description="Additional conditions"
    )
    team_id: str = Field(..., description="Associated team ID")
    enabled: bool = Field(True, description="Whether the anomaly detection is enabled")
    notification_settings: Optional[Dict[str, Any]] = Field(
        None, description="Notification configuration"
    )
    tags: Optional[List[str]] = Field(default_factory=list, description="Anomaly tags")
    created_at: Optional[datetime] = Field(None, description="Creation timestamp")
    updated_at: Optional[datetime] = Field(None, description="Last update timestamp")
    metadata: Optional[Dict[str, Any]] = Field(None, description="Additional anomaly metadata")


class AIAlert(BaseReveniumModel):
    """AI Alert model representing a triggered alert from anomaly detection."""

    id: Optional[str] = Field(None, description="Alert ID")
    anomaly_id: str = Field(..., description="Associated anomaly ID")
    anomaly_name: Optional[str] = Field(None, description="Associated anomaly name")
    trigger_timestamp: datetime = Field(..., description="When the alert was triggered")
    severity: AlertSeverity = Field(..., description="Alert severity level")
    status: AlertStatus = Field(AlertStatus.OPEN, description="Alert status")
    title: Optional[str] = Field(None, description="Alert title")
    message: Optional[str] = Field(None, description="Alert message")
    resolution_details: Optional[str] = Field(None, description="Details about alert resolution")
    affected_metrics: Dict[str, Any] = Field(..., description="Metrics that triggered the alert")
    threshold_violations: List[ThresholdViolation] = Field(
        default_factory=list, description="Threshold violations"
    )
    investigation_notes: Optional[str] = Field(None, description="Investigation notes")
    assigned_to: Optional[str] = Field(None, description="User ID assigned to investigate")
    resolved_by: Optional[str] = Field(None, description="User ID who resolved the alert")
    resolved_at: Optional[datetime] = Field(None, description="When the alert was resolved")
    team_id: str = Field(..., description="Associated team ID")
    tags: Optional[List[str]] = Field(default_factory=list, description="Alert tags")
    created_at: Optional[datetime] = Field(None, description="Creation timestamp")
    updated_at: Optional[datetime] = Field(None, description="Last update timestamp")
    metadata: Optional[Dict[str, Any]] = Field(None, description="Additional alert metadata")

    @field_validator("status")
    @classmethod
    def validate_status_transitions(cls, v):
        """Validate alert status is valid."""
        # Note: More complex validation (like checking resolved_at/resolved_by)
        # would be better handled in a model_validator that has access to all fields
        if not v:
            raise ValueError("Alert status is required")
        return v

    @field_validator("severity")
    @classmethod
    def validate_severity(cls, v):
        """Validate alert severity is appropriate."""
        if not v:
            raise ValueError("Alert severity is required")
        return v


# Pagination and Filtering Models


class SortOrder(str, Enum):
    """Sort order enumeration."""

    ASC = "asc"
    DESC = "desc"


class SortField(BaseReveniumModel):
    """Sort field configuration."""

    field: str = Field(..., description="Field name to sort by")
    order: SortOrder = Field(SortOrder.ASC, description="Sort order")


class PaginationParams(BaseReveniumModel):
    """Pagination parameters for list operations."""

    page: int = Field(0, ge=0, description="Page number (0-based)")
    size: int = Field(20, ge=1, le=1000, description="Number of items per page")
    sort: Optional[List[SortField]] = Field(default_factory=list, description="Sort configuration")
    cursor: Optional[str] = Field(None, description="Cursor for cursor-based pagination")

    @field_validator("size")
    @classmethod
    def validate_page_size(cls, v):
        """Validate page size is reasonable."""
        if v > 1000:
            raise ValueError("Page size cannot exceed 1000 items")
        return v


class FilterOperator(str, Enum):
    """Filter operator enumeration."""

    EQUALS = "eq"
    NOT_EQUALS = "ne"
    GREATER_THAN = "gt"
    GREATER_THAN_OR_EQUAL = "gte"
    LESS_THAN = "lt"
    LESS_THAN_OR_EQUAL = "lte"
    CONTAINS = "contains"
    NOT_CONTAINS = "not_contains"
    STARTS_WITH = "starts_with"
    ENDS_WITH = "ends_with"
    IN = "in"
    NOT_IN = "not_in"
    IS_NULL = "is_null"
    IS_NOT_NULL = "is_not_null"
    BETWEEN = "between"


class FilterCondition(BaseReveniumModel):
    """Individual filter condition."""

    field: str = Field(..., description="Field name to filter on")
    operator: FilterOperator = Field(..., description="Filter operator")
    value: Optional[Union[str, int, float, bool, List[Any]]] = Field(
        None, description="Filter value"
    )
    values: Optional[List[Any]] = Field(None, description="Multiple values for IN/NOT_IN operators")

    @field_validator("value", "values")
    @classmethod
    def validate_filter_values(cls, v, info):
        """Validate filter values based on operator."""
        operator = info.data.get("operator")

        if operator in [FilterOperator.IN, FilterOperator.NOT_IN]:
            if "values" not in info.data or not info.data["values"]:
                raise ValueError(f"Operator '{operator}' requires 'values' field")
        elif operator in [FilterOperator.IS_NULL, FilterOperator.IS_NOT_NULL]:
            # These operators don't need values
            pass
        elif operator == FilterOperator.BETWEEN:
            if "values" not in info.data or len(info.data.get("values", [])) != 2:
                raise ValueError("BETWEEN operator requires exactly 2 values")
        else:
            if v is None and "value" not in info.data:
                raise ValueError(f"Operator '{operator}' requires a value")

        return v


class FilterParams(BaseReveniumModel):
    """Filter parameters for list operations."""

    conditions: List[FilterCondition] = Field(default_factory=list, description="Filter conditions")
    logic: Literal["AND", "OR"] = Field(
        "AND", description="Logic operator for combining conditions"
    )

    # Quick filters for common use cases
    status: Optional[str] = Field(None, description="Quick filter by status")
    team_id: Optional[str] = Field(None, description="Quick filter by team ID")
    created_after: Optional[datetime] = Field(
        None, description="Quick filter by creation date (after)"
    )
    created_before: Optional[datetime] = Field(
        None, description="Quick filter by creation date (before)"
    )
    search: Optional[str] = Field(None, description="Quick text search across searchable fields")
    tags: Optional[List[str]] = Field(default_factory=list, description="Quick filter by tags")

    def to_query_params(self) -> Dict[str, Any]:
        """Convert filter parameters to API query parameters."""
        params = {}

        # Add quick filters
        if self.status:
            params["status"] = self.status
        if self.team_id:
            params["team_id"] = self.team_id
        if self.created_after:
            params["created_after"] = self.created_after.isoformat()
        if self.created_before:
            params["created_before"] = self.created_before.isoformat()
        if self.search:
            params["search"] = self.search
        if self.tags:
            params["tags"] = ",".join(self.tags)

        # Add complex filter conditions
        if self.conditions:
            filter_expressions = []
            for condition in self.conditions:
                if condition.operator == FilterOperator.EQUALS:
                    filter_expressions.append(f"{condition.field}:{condition.value}")
                elif condition.operator == FilterOperator.NOT_EQUALS:
                    filter_expressions.append(f"{condition.field}!:{condition.value}")
                elif condition.operator == FilterOperator.GREATER_THAN:
                    filter_expressions.append(f"{condition.field}>:{condition.value}")
                elif condition.operator == FilterOperator.GREATER_THAN_OR_EQUAL:
                    filter_expressions.append(f"{condition.field}>=:{condition.value}")
                elif condition.operator == FilterOperator.LESS_THAN:
                    filter_expressions.append(f"{condition.field}<:{condition.value}")
                elif condition.operator == FilterOperator.LESS_THAN_OR_EQUAL:
                    filter_expressions.append(f"{condition.field}<=:{condition.value}")
                elif condition.operator == FilterOperator.CONTAINS:
                    filter_expressions.append(f"{condition.field}~:{condition.value}")
                elif condition.operator == FilterOperator.NOT_CONTAINS:
                    filter_expressions.append(f"{condition.field}!~:{condition.value}")
                elif condition.operator == FilterOperator.STARTS_WITH:
                    filter_expressions.append(f"{condition.field}^:{condition.value}")
                elif condition.operator == FilterOperator.ENDS_WITH:
                    filter_expressions.append(f"{condition.field}$:{condition.value}")
                elif condition.operator == FilterOperator.IN:
                    values_str = ",".join(str(v) for v in condition.values or [])
                    filter_expressions.append(f"{condition.field}@:[{values_str}]")
                elif condition.operator == FilterOperator.NOT_IN:
                    values_str = ",".join(str(v) for v in condition.values or [])
                    filter_expressions.append(f"{condition.field}!@:[{values_str}]")
                elif condition.operator == FilterOperator.IS_NULL:
                    filter_expressions.append(f"{condition.field}:null")
                elif condition.operator == FilterOperator.IS_NOT_NULL:
                    filter_expressions.append(f"{condition.field}!:null")
                elif condition.operator == FilterOperator.BETWEEN:
                    if condition.values and len(condition.values) == 2:
                        filter_expressions.append(
                            f"{condition.field}><:[{condition.values[0]},{condition.values[1]}]"
                        )

            if filter_expressions:
                params["filter"] = f" {self.logic} ".join(filter_expressions)

        return params


class PaginationMetadata(BaseReveniumModel):
    """Pagination metadata for responses."""

    current_page: int = Field(..., description="Current page number (0-based)")
    page_size: int = Field(..., description="Number of items per page")
    total_items: int = Field(..., description="Total number of items")
    total_pages: int = Field(..., description="Total number of pages")
    has_previous: bool = Field(..., description="Whether there is a previous page")
    has_next: bool = Field(..., description="Whether there is a next page")
    previous_cursor: Optional[str] = Field(None, description="Cursor for previous page")
    next_cursor: Optional[str] = Field(None, description="Cursor for next page")

    @classmethod
    def from_response(
        cls,
        page: int,
        size: int,
        total: int,
        items_count: int,
        next_cursor: Optional[str] = None,
        prev_cursor: Optional[str] = None,
    ) -> "PaginationMetadata":
        """Create pagination metadata from response data."""
        total_pages = (total + size - 1) // size if total > 0 else 0

        return cls(
            current_page=page,
            page_size=size,
            total_items=total,
            total_pages=total_pages,
            has_previous=page > 0,
            has_next=(page + 1) * size < total,
            previous_cursor=prev_cursor,
            next_cursor=next_cursor,
        )


class PaginatedResponse(BaseReveniumModel):
    """Generic paginated response model."""

    items: List[Dict[str, Any]] = Field(default_factory=list, description="List of items")
    pagination: PaginationMetadata = Field(..., description="Pagination metadata")
    filters_applied: Optional[FilterParams] = Field(None, description="Filters that were applied")
    sort_applied: Optional[List[SortField]] = Field(
        default_factory=list, description="Sort configuration applied"
    )

    @classmethod
    def create(
        cls,
        items: List[Dict[str, Any]],
        page: int,
        size: int,
        total: int,
        filters: Optional[FilterParams] = None,
        sort: Optional[List[SortField]] = None,
        next_cursor: Optional[str] = None,
        prev_cursor: Optional[str] = None,
    ) -> "PaginatedResponse":
        """Create a paginated response."""
        pagination = PaginationMetadata.from_response(
            page=page,
            size=size,
            total=total,
            items_count=len(items),
            next_cursor=next_cursor,
            prev_cursor=prev_cursor,
        )

        return cls(
            items=items, pagination=pagination, filters_applied=filters, sort_applied=sort or []
        )


# Export all public classes and enums for import *
# New Entity Detection Models
class NewEntityIntroduction(BaseReveniumModel):
    """New cost source detection result."""

    entity_name: str = Field(..., description="Name of the new entity (e.g., 'AnalyticsAgent_v3.0')")
    entity_type: str = Field(..., description="Type of entity: 'agent', 'api_key', 'provider' (models and customers not supported in Phase 1)")
    introduction_period: str = Field(..., description="Human-readable period when entity was introduced")
    first_appearance_index: int = Field(..., description="Time index when first detected")
    first_active_date: str = Field(..., description="ISO date when entity was first active (YYYY-MM-DD)")
    periods_active: int = Field(..., description="Number of periods entity was active during analysis")
    period_type: str = Field(..., description="Type of periods: 'daily' or 'monthly'")
    total_cost_impact: float = Field(..., description="Total cost impact of the new entity")
    average_daily_cost: float = Field(..., description="Average daily cost of the new entity")
    introduction_type: str = Field(..., description="Type of introduction: 'new_entity' or 'activation'")
    cost_periods: List[float] = Field(..., description="List of cost values across time periods")
    context: str = Field(..., description="Human-readable explanation of the detection")


class EntityTypeGroup(BaseReveniumModel):
    """Grouped new entities by type with summary statistics."""

    entities: List[NewEntityIntroduction] = Field(..., description="List of entities of this type")
    count: int = Field(..., description="Number of entities in this group")
    total_cost_impact: float = Field(..., description="Sum of cost impact for this type")
    summary: str = Field(..., description="Human-readable summary of the group")


__all__ = [
    # Base classes
    "BaseReveniumModel",
    # Product-related enums and models
    "ProductStatus",
    "PlanType",
    "Currency",
    "BillingPeriod",
    "TrialPeriod",
    "AggregationType",
    "RatingAggregationType",
    "SetupFee",
    "Element",
    "RatingAggregation",
    "Tier",
    "Plan",
    "Product",
    # Subscription models
    "SubscriptionStatus",
    "Subscription",
    # Source models
    "SourceType",
    "Source",
    # Response models
    "APIResponse",
    "ListResponse",
    # Customer models
    "UserStatus",
    "UserRole",
    "User",
    "SubscriberStatus",
    "Subscriber",
    "OrganizationType",
    "OrganizationStatus",
    "Organization",
    "TeamStatus",
    "TeamRole",
    "TeamMember",
    "Team",
    "CustomerAnalytics",
    "CustomerRelationship",
    # Alert models
    "AnomalyStatus",
    "AlertSeverity",
    "AlertStatus",
    "AlertType",
    "MetricType",
    "OperatorType",
    "PeriodDuration",
    "GroupByDimension",
    "TriggerDuration",
    "FilterOperator",
    "AlertFilter",
    "SlackConfiguration",
    "WebhookConfiguration",
    "AdvancedAlertConfiguration",
    "DetectionRule",
    "ThresholdViolation",
    "AIAnomalyRequest",
    "AIAnomaly",
    "AIAnomalyLegacy",
    "AIAlert",
    # New entity detection models
    "NewEntityIntroduction",
    "EntityTypeGroup",
    # Pagination and filtering models
    "SortOrder",
    "SortField",
    "PaginationParams",
    "FilterCondition",
    "FilterParams",
    "PaginationMetadata",
    "PaginatedResponse",
]
