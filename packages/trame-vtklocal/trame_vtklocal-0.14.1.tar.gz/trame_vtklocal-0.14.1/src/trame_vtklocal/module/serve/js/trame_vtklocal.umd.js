(function(v,S){typeof exports=="object"&&typeof module<"u"?S(exports,require("vue")):typeof define=="function"&&define.amd?define(["exports","vue"],S):(v=typeof globalThis<"u"?globalThis:v||self,S(v.trame_vtklocal={},v.Vue))})(this,function(v,S){"use strict";const H=[],k={};function E(){let t,e;return{promise:new Promise((n,r)=>{t=n,e=r}),resolve:t,reject:e}}function B(t){return t!=null&&t.Id?t:JSON.parse(t)}function J(t){return t!=null&&t.Id?JSON.stringify(t):t}function q(t,e){return t.rendering===e.rendering&&t.exec===e.exec}function P(t){return(t==null?void 0:t.rendering)==="webgpu"?(console.log("WASM use WebGPU"),{preRun:[function(e){e.ENV.VTK_GRAPHICS_BACKEND="WEBGPU"}]}):(console.log("WASM use WebGL2"),{})}function U(t){return k[t]||(k[t]=new Promise(function(e,s){if(H.indexOf(t)===-1){H.push(t);var n=document.createElement("script");n.type="module",n.src=t,n.onload=e,n.onerror=s,document.body.appendChild(n)}else e(!1)})),k[t]}class L{constructor(){this.loaded=!1,this.loadingPending=null,this.wasm=null,this.config={},this.runtimes=[]}async load(e,s={rendering:"webgl",exec:"sync"},n="vtk"){var r,o;if(this.config=s,!this.loaded)if(this.loadingPending)await this.loadingPending;else{const{promise:c,resolve:h}=E();if(this.loadingPending=c,((r=this.config)==null?void 0:r.rendering)==="webgpu"&&(this.config.exec="async"),!window.createVTKWASM){let a=null;document.querySelectorAll("script").forEach(f=>{if(f.src.includes(`${n}WebAssembly`)){const{promise:i,resolve:u}=E();f.onload=u,a=i}}),a&&await a}if(!window.createVTKWASM){let a=null,f=null;a=`${e}/${n}WebAssembly${((o=this.config)==null?void 0:o.exec)==="async"?"Async":""}.mjs`;const i=await fetch(a);if(i.ok&&(await i.text())[0]!=="<"&&(f=a),!f){a=`${e}/vtkWasmSceneManager.mjs`;const u=await fetch(a);u.ok&&(await u.text())[0]!=="<"&&(f=a)}if(!f)throw new Error(`Could not fetch wasm bundle from ${e}`);console.log("WASM use",f),await U(f)}window.createVTKWASM&&(this.wasm=await window.createVTKWASM(P(this.config))),this.loaded=!0,h()}}async createRemoteSession(e){var n;if(this.wasm)if((n=this.wasm)!=null&&n.isAsync&&this.wasm.isAsync()){if(!e||q(this.config,e))return console.log("(Main runtime in async)"),new this.wasm.vtkRemoteSession;{console.log("(New in async)");const r=await window.createVTKWASM(P(e||this.config));return new r.vtkRemoteSession}}else{console.log("(New in sync)");const r=await window.createVTKWASM(P(e||this.config));return new r.vtkRemoteSession}const s=await window.createVTKWasmSceneManager();return s.initialize(),s}createStandaloneSession(){if(!this.wasm)throw new Error("Current WASM version does not support standalone mode");return new this.wasm.vtkStandaloneSession}createStateDecorator(){return this.wasm?B:J}}function x(t){return`${t.charAt(0).toLowerCase()}${t.slice(1)}`}function D(t){return`${t.charAt(0).toUpperCase()}${t.slice(1)}`}function F(t){const e={};return Object.entries(t).forEach(([s,n])=>{e[D(s)]=n}),e}function _(t){const e={};return Object.entries(t).forEach(([s,n])=>{e[x(s)]=n}),e}function X(t,e,s){if(!t.get)return{};const n=t.get(s),r={};return Object.keys(n).forEach(o=>{r[x(o)]=()=>e.decorateResult(t.get(s)[o])}),r}function Q(t,e,s){if(!t.get)return{};const n=t.get(s),r={};return Object.keys(n).forEach(o=>{r[x(o)]=c=>t.set(s,e.decorateKwargs({[o]:c}))}),r}function O(t,e,s,n,r){if(s.has(r)&&s.get(r).deref())return s.get(r).deref();const o=[];function c(b){return t.set(r,n.decorateKwargs(F(b)))}function h(b,g){const p=t.observe(r,b,g);return o.push(p),p}function a(b){const g=o.indexOf(b);return g!==-1&&o.splice(g,1),t.unObserve(r,b)}function f(){for(;o.length;)a(o.pop())}const i=X(t,n,r),u=Q(t,n,r),m={id:r,obj:{Id:r},set:c,observe:h,unObserve:a,unObserveAll:f},y=new Proxy(m,{get(b,g,p){if(g==="then")return p;if(g==="state")return t.get?_(t.get(r)):(t.updateStateFromObject(r),_(t.getState(r)));if(g==="delete"){const W=t.destroy(r);if(W){const z=s.delete(r);e.delete(z)}return W}return i[g]?i[g]():(b[g]||(b[g]=async(...W)=>n.decorateResult(await t.invoke(r,D(g),n.decorateArgs(W)))),b[g])},set(b,g,p){return u[g]&&u[g](p),p}});return s.set(r,new WeakRef(y)),e.set(y,!0),y}function Y(t,e,s){function n(i){return e.has(i)}function r(i){const u={};return Object.entries(i).forEach(([m,y])=>{e.has(y)?u[m]=y.obj:u[m]=y}),u}function o(i){return i.map(u=>e.has(u)?u.obj:u)}const c={isVtkObject:n,decorateKwargs:r,decorateArgs:o};function h(i){return i==null?i:i!=null&&i.Id?O(t,e,s,c,i.Id):i}c.decorateResult=h;function a(i){return O(t,e,s,c,i.Id||i)}function f(i,u){const m=t.create(i);return u&&t.set(m,r(F(u))),O(t,e,s,c,m)}return new Proxy({getVtkObject:a},{get(i,u,m){return u==="then"?m:(i[u]||(i[u]=y=>f(u,y)),i[u])}})}async function Z(t,e={},s="vtk"){const n=new WeakMap,r=new Map,o=new L;await o.load(t,e,s);const c=o.createStandaloneSession();return Y(c,n,r)}const{promise:ee,resolve:te,reject:ne}=E(),R=document.querySelector("#vtk-wasm");if(R){const t=R.dataset.url||".",e=JSON.parse(R.dataset.config||"{}");window.vtkReady=ee,Z(t,e).then(s=>{window.vtk=s,te(s)})}else ne('No script with id="vtk-wasm"');const C={};class K{constructor(){this.sceneManager=null,this.loaded=!1,this.updateInProgress=0,this.currentMTime=1,this.stateMTimes={},this.hashesMTime={},this.pendingArrays={},this.networkFetchState=null,this.networkFetchHash=null,this.networkFetchStatus=null,this.cameraIds=new Set,this.stateCache={},this.renderWindowIds=new Set,this.renderWindowIdToInteractorId=new Map,this.renderWindowSizes={},this.vtkProxyCache=new WeakMap,this.idToRef=new Map,this.internalWrapMethods={},this.internalWrapMethods.isVtkObject=e=>this.vtkProxyCache.has(e),this.internalWrapMethods.decorateKwargs=e=>{const s={};return Object.entries(e).forEach(([n,r])=>{this.vtkProxyCache.has(r)?s[n]=r.obj:s[n]=r}),s},this.internalWrapMethods.decorateArgs=e=>e.map(s=>this.vtkProxyCache.has(s)?s.obj:s),this.internalWrapMethods.decorateResult=e=>e==null?e:e!=null&&e.Id?O(this.sceneManager,this.vtkProxyCache,this.idToRef,this.internalWrapMethods,e.Id):e,this.offlineCanvasContainer=document.createElement("div"),this.offlineCanvasContainer.setAttribute("class","unused-canvas"),document.body.appendChild(this.offlineCanvasContainer)}async load(e,s,n){C[e]||(C[e]=new L),await C[e].load(e,s,n),this.sceneManager=await C[e].createRemoteSession(s),this.stateDecorator=C[e].createStateDecorator(),this.loaded=!0,this.sceneManager.skipProperty&&(this.sceneManager.skipProperty("vtkRenderWindow","Size"),["vtkWin32OpenGLRenderWindow","vtkXOpenGLRenderWindow","vtkCocoaRenderWindow","vtkWebAssemblyOpenGLRenderWindow"].forEach(r=>this.sceneManager.skipProperty(r,"Size")))}bindNetwork(e,s,n){this.networkFetchState=e,this.networkFetchHash=s,this.networkFetchStatus=n}freeMemory(e=0){const s=this.sceneManager.getTotalBlobMemoryUsage(),n=Number(e);if(s>n){const r={};let o=this.currentMTime;for(Object.entries(this.hashesMTime).forEach(([c,h])=>{h<o&&(o=h);const a=h.toString();r[a]?r[a].push(c):r[a]=[c]});this.sceneManager.getTotalBlobMemoryUsage()>n;){const c=r[o];if(c)for(let h=0;h<c.length;h++)this.sceneManager.unRegisterBlob(c[h]),delete this.hashesMTime[c[h]];o++}}}async fetchState(e){const s=await this.networkFetchState(e);return this.patchState(s)}patchState(e){var s;if(e.length>0){const n=JSON.parse(e),{Id:r,MTime:o}=n;if(this.stateMTimes[r]=o,!this.sceneManager.skipProperty||!this.sceneManager.bindRenderWindow){if(this.renderWindowIds.has(r)&&((s=n==null?void 0:n.Interactor)!=null&&s.Id))return this.renderWindowIdToInteractorId.set(n.Interactor.Id,r),n.CanvasSelector=this.getCanvasSelector(r),delete n.Size,this.renderWindowSizes[r]&&(n.Size=this.renderWindowSizes[r]),n.ClassName="vtkCocoaRenderWindow",JSON.stringify(n);if(this.renderWindowIdToInteractorId.has(r))return n.CanvasSelector=this.getCanvasSelector(this.renderWindowIdToInteractorId.get(r)),JSON.stringify(n)}return e}}async fetchHash(e){if(this.pendingArrays[e]){await this.pendingArrays[e],this.hashesMTime[e]=this.currentMTime,delete this.pendingArrays[e];return}const s=await this.networkFetchHash(e);return this.sceneManager.registerBlob(e,s),this.hashesMTime[e]=this.currentMTime,s}pushHash(e,s){return this.pendingArrays[e]=new Promise(n=>{s.arrayBuffer?s.arrayBuffer().then(r=>{this.sceneManager.registerBlob(e,new Uint8Array(r)),this.hashesMTime[e]=this.currentMTime,n()}):(this.sceneManager.registerBlob(e,s),this.hashesMTime[e]=this.currentMTime,n())}),this.pendingArrays[e]}async update(e,s=!1){if(this.renderWindowIds.add(e),this.updateInProgress++,this.updateInProgress===1)try{const n=await this.networkFetchStatus(e),r=[],o=[],c=n.force_push||[];for(let a=0;a<c.length;a++)delete this.stateMTimes[c[a]];n.ids.forEach(([a,f])=>{(!this.stateMTimes[a]||this.stateMTimes[a]<f)&&o.push(this.fetchState(a))}),n.hashes.forEach(a=>{this.hashesMTime[a]||r.push(this.fetchHash(a)),this.hashesMTime[a]=this.currentMTime}),n.cameras.forEach(a=>this.cameraIds.add(Number(a))),n.ignore_ids.forEach(a=>this.sceneManager.unRegisterState(a)),await Promise.all(r),await Promise.all(Object.values(this.pendingArrays));const h=await Promise.all(o);for(this.currentMTime++;h.length;){const a=h.pop();a&&this.sceneManager.registerState(this.stateDecorator(a))}try{this.sceneManager.updateObjectsFromStates();const[a,f]=this.renderWindowSizes[e]||[10,10];this.sceneManager.setSize(e,a,f),s&&this.sceneManager.bindRenderWindow&&this.sceneManager.bindRenderWindow(e,this.getCanvasSelector(e)),await this.sceneManager.render(e)}catch(a){console.error("WASM update failed"),console.log(a)}}catch(n){console.error("Error in update",n)}finally{this.updateInProgress--,this.updateInProgress&&(this.updateInProgress=0,await this.update(e))}}getState(e,s=!1){const n=Number(e);return s&&this.stateCache[n]?this.stateCache[n]:this.sceneManager.get?this.sceneManager.get(n):(this.sceneManager.updateStateFromObject(n),this.sceneManager.getState(n))}clearStateCache(){this.stateCache={}}getStateValue(e,s=!1){const n=Array.isArray(e)?e:[e];let r=null;for(let o=0;o<n.length;o++){const c=n[o];o===0?r=this.getState(c,s):(r=r[c],r.Id&&(r=this.getState(r.Id,s)))}return r}getCanvasSelector(e){return`.vtk-wasm-${e}`}bindCanvasToDOM(e,s){const n=this.getCanvasSelector(e);let r=this.offlineCanvasContainer.querySelector(n);return r||(r=document.createElement("canvas"),r.setAttribute("class",n.substring(1)),r.setAttribute("tabindex","0")),s.appendChild(r),n}unbindCanvasToDOM(e){const s=this.getCanvasSelector(e),n=document.querySelector(s);n&&this.offlineCanvasContainer.appendChild(n)}async setSize(e,s,n){this.renderWindowSizes[e]=[s,n];const r=this.getCanvasSelector(e),o=document.querySelector(r);o&&(o.width=s,o.height=n,this.sceneManager.setSize(e,s,n),await this.sceneManager.render(e))}getVtkObject(e){return O(this.sceneManager,this.vtkProxyCache,this.idToRef,this.internalWrapMethods,e)}}const A={};function V(t,e,s){return function(){e.clearStateCache();for(const[n,r]of Object.entries(s)){const o={};for(const[c,h]of Object.entries(r))o[c]=e.getStateValue(h,!0);t.state.set(n,o)}e.clearStateCache()}}const $={VtkLocal:{emits:["updated","memory-vtk","memory-arrays","camera","invoke-response"],props:{useHandler:{type:String},renderWindow:{type:Number},eagerSync:{type:Boolean,default:!1},cacheSize:{type:Number,default:1e8},wsClient:{type:Object},verbosity:{type:Object,default:()=>({objectManager:null,invoker:null,deserializer:null,serializer:null})},config:{type:Object,default:()=>({rendering:"webgl",exec:"sync"})},listeners:{type:Object}},setup(t,{emit:e}){t.useHandler&&!A[t.useHandler]&&(A[t.useHandler]=new K);const s=S.inject("trame"),n=s.state.get("__trame_vtklocal_wasm_url"),r=s.state.get("__trame_vtklocal_wasm_base_name"),o=[],c=[],h=S.ref(null),a=t.wsClient||(s==null?void 0:s.client),f=S.toRef(t,"listeners"),i=t.useHandler?A[t.useHandler]:new K;let u=null;async function m(d){return await a.getConnection().getSession().call("vtklocal.get.state",[d])}async function y(d){const w=await a.getConnection().getSession().call("vtklocal.get.hash",[d]);return w.arrayBuffer?new Uint8Array(await w.arrayBuffer()):w}async function b(d){return await a.getConnection().getSession().call("vtklocal.get.status",[d])}function g([d]){d.type==="state"&&i.pushState(d.content),d.type==="blob"&&i.pushHash(d.hash,d.content)}async function p(){const d=a.getConnection().getSession();u=d.subscribe("vtklocal.subscriptions",g),await d.call("vtklocal.subscribe.update",[t.renderWindow,1])}async function W(){const d=a.getConnection().getSession();u&&(d.unsubscribe(u),u=null),await d.call("vtklocal.subscribe.update",[t.renderWindow,-1])}async function z(){const{width:d,height:l}=h.value.getBoundingClientRect(),w=Math.floor(d*window.devicePixelRatio+.5),M=Math.floor(l*window.devicePixelRatio+.5);await i.setSize(t.renderWindow,w,M)}let T=new ResizeObserver(z);function re(){i.freeMemory(t.cacheSize),e("memory-vtk",i.sceneManager.getTotalVTKDataObjectMemoryUsage()),e("memory-arrays",i.sceneManager.getTotalBlobMemoryUsage())}async function G(d=!1){i.loaded&&(await i.update(t.renderWindow,d),e("updated"),re())}function ie(d){i.sceneManager.resetCamera(d),i.sceneManager.render(t.renderWindow)}async function ae(d,l,w){const M=await i.sceneManager.invoke(d,l,w);return M.Id&&M.Success&&(M.Value=i.getState(M.Id)),e("invoke-response",M),M}function oe(){i.sceneManager.printSceneManagerInformation()}S.onMounted(async()=>{i.bindNetwork(m,y,b),i.loaded||await i.load(n,t.config,r);const d=i.bindCanvasToDOM(t.renderWindow,S.unref(h));S.unref(h).querySelector(d).setAttribute("style","position: absolute; left: 0; top: 0; width: 100%; height: 100%;"),t.eagerSync&&p(),T&&T.observe(S.unref(h)),S.watchEffect(()=>{const l=t.verbosity;l.objectManager&&i.sceneManager.setObjectManagerLogVerbosity&&i.sceneManager.setObjectManagerLogVerbosity(l.objectManager),l.invoker&&i.sceneManager.setInvokerLogVerbosity&&i.sceneManager.setInvokerLogVerbosity(l.invoker),l.deserializer&&i.sceneManager.setDeserializerLogVerbosity&&i.sceneManager.setDeserializerLogVerbosity(l.deserializer),l.serializer&&i.sceneManager.setSerializerLogVerbosity&&i.sceneManager.setSerializerLogVerbosity(l.serializer)}),await G(!0),i.sceneManager.addObserver?i.cameraIds.forEach(l=>{o.push([l,i.sceneManager.addObserver(l,"ModifiedEvent",()=>{e("camera",i.getState(l))})])}):i.cameraIds.forEach(l=>{o.push([l,i.sceneManager.observe(l,"ModifiedEvent",()=>{e("camera",i.getState(l))})])}),S.watchEffect(()=>{if(i.sceneManager.removeObserver){for(;c.length;){const[l,w]=c.pop();i.sceneManager.removeObserver(l,w)}for(const[l,w]of Object.entries(f.value||{})){const M=Number(l);for(const[N,I]of Object.entries(w||{})){const j=V(s,i,I);c.push([M,i.sceneManager.addObserver(M,N,j)]),j()}}}else{for(;c.length;){const[l,w]=c.pop();i.sceneManager.unObserve(l,w)}for(const[l,w]of Object.entries(f.value||{})){const M=Number(l);for(const[N,I]of Object.entries(w||{})){const j=V(s,i,I);c.push([M,i.sceneManager.observe(M,N,j)]),j()}}}}),i.sceneManager.startEventLoop(t.renderWindow)||console.error("Could not startEventLoop for",t.renderWindow)}),S.onBeforeUnmount(()=>{u&&W();const d=i.sceneManager.removeObserver?"removeObserver":"unObserve";for(;o.length;){const[l,w]=o.pop();i.sceneManager[d](l,w)}for(;c.length;){const[l,w]=c.pop();i.sceneManager[d](l,w)}i.sceneManager.stopEventLoop(t.renderWindow),T&&(T.disconnect(),T=null),i.unbindCanvasToDOM(t.renderWindow)});function ce(d){V(s,i,d)()}function le(d){return i.getVtkObject(d)}function de(){t.useHandler&&A[t.useHandler]&&delete A[t.useHandler]}return{container:h,update:G,resetCamera:ie,evalStateExtract:ce,invoke:ae,printSceneManagerInformation:oe,detachHandler:de,getVtkObject:le}},template:'<div ref="container" style="position: relative; width: 100%; height: 100%;"></div>'}};function se(t){Object.keys($).forEach(e=>{t.component(e,$[e])})}v.install=se,Object.defineProperty(v,Symbol.toStringTag,{value:"Module"})});
