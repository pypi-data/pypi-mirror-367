
import requests
from packaging.specifiers import SpecifierSet
from packaging.version import parse as parse_version

from ..core.base_validator import BaseValidator
from ..utils.vulnerability_db import VulnerabilityDB
from typing import Dict, Any, List


class VulnerabilityValidator(BaseValidator):
    """
    Validator that checks for known vulnerabilities in packages using the OSV API.
    """
    OSV_API_URL = "https://api.osv.dev/v1/query"

    def __init__(self, pkg_name: str, metadata: Dict[str, Any]):
        super().__init__(pkg_name, metadata)
        self.db = VulnerabilityDB()
        self.timeout = 30

    def _validate(self) -> None:
        osv_api_url = "https://api.osv.dev/v1/query"
        # FIX: Get the canonical package name from the metadata, not from a direct attribute.
        # This makes the validator self-contained and consistent with others.
        pkg_name = self.get_metadata_field("name")
        version = self.get_metadata_field("version")

        if not pkg_name:
            self.add_warning("Could not determine package name from metadata, skipping vulnerability check.")
            return
        if not version:
            self.add_warning(f"Could not determine version for '{pkg_name}', skipping vulnerability check.")
            return

        query = {"version": version, "package": {"name": pkg_name.lower(), "ecosystem": "PyPI"}}

        try:
            # Use a reasonable timeout for the API call
            response = requests.post(osv_api_url, json=query, timeout=15)
            response.raise_for_status()
            data = response.json()

            if not data or not data.get("vulns"):
                self.add_info("Vulnerability Scan (OSV)", f"No known vulnerabilities found for v{version}.")
                return

            # Report each vulnerability as a distinct error for clarity.
            for vuln in data.get("vulns", []):
                vuln_id = vuln.get("id", "N/A")
                summary = vuln.get("summary", "No summary available.").strip()
                self.add_error(f"Vulnerability found: {vuln_id} - {summary}")

        except requests.exceptions.Timeout:
            self.add_warning("Vulnerability check timed out while contacting the OSV database.")
        except requests.exceptions.RequestException as e:
            self.add_warning(f"Could not query the OSV vulnerability database: {e}")

    def _check_vulnerabilities(self) -> None:
        """
        Validates the package by checking for vulnerabilities.
        """
        if self.metadata.get("version") == 'latest':
            # We cannot check vulnerabilities without a specific version
            return

        with self.db:
            vulnerabilities = self.db.get_vulnerability(self.pkg_name)

            if vulnerabilities is None:
                vulnerabilities = self._fetch_vulnerabilities(self.pkg_name)
                self.db.update_vulnerability(self.pkg_name, vulnerabilities)

            if not vulnerabilities or not vulnerabilities.get("vulns"):
                return  # No vulnerabilities found

            for vuln in vulnerabilities["vulns"]:
                if self._is_version_affected(self.metadata.get("version"), vuln.get("affected", [])):
                    summary = vuln.get('summary', 'No summary available.')
                    osv_id = vuln.get('id', 'N/A')
                    self.add_error(
                        f"Vulnerability Found: {osv_id} - {summary}"
                    )

    def _fetch_vulnerabilities(self, package_name: str) -> Dict[str, Any]:
        """
        Fetches vulnerabilities from the OSV API.
        """
        query = {
            "package": {
                "name": package_name,
                "ecosystem": "PyPI"
            }
        }
        try:
            response = requests.post(self.OSV_API_URL, json=query, timeout=self.timeout)
            response.raise_for_status()
            return response.json()
        except requests.exceptions.RequestException as e:
            print(f"Warning: Could not fetch vulnerability data for {package_name}: {e}")
            return {}

    def _is_version_affected(self, package_version_str: str, affected_ranges: List[Dict[str, Any]]) -> bool:
        """
        Checks if a package version is within the affected ranges from OSV.
        """
        try:
            package_version = parse_version(package_version_str)
        except Exception:
            return False # Cannot parse version, assume not affected

        for affected in affected_ranges:
            for range_info in affected.get("ranges", []):
                if range_info["type"] == "ECOSYSTEM":
                    events = range_info.get("events", [])
                    # Sort events: introduced versions first, then fixed versions
                    events.sort(key=lambda e: list(e.keys())[0] != 'introduced')
                    
                    affected_specifiers = []
                    is_affected = False

                    for event in events:
                        if 'introduced' in event:
                            version = event['introduced']
                            if version != "0": # "0" means all prior versions are affected
                                affected_specifiers.append(f">={version}")
                            is_affected = True

                        if 'fixed' in event:
                            version = event['fixed']
                            affected_specifiers.append(f"<{version}")
                            is_affected = False # No longer affected after this version
                    
                    if is_affected and not affected_specifiers:
                         # Affected from the start and never fixed
                         return True

                    if affected_specifiers:
                        spec_str = ",".join(affected_specifiers)
                        spec = SpecifierSet(spec_str)
                        if package_version in spec:
                            return True
        return False

