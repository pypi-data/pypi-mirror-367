#!/usr/bin/env python3
"""Mock tests for Colab integration that don't require real infrastructure."""

import pytest
from unittest.mock import Mock, patch, MagicMock
import time

from flow._internal.integrations.jupyter import JupyterIntegration, JupyterConnection
from flow.progress import ColabLaunchProgress, TaskStatusProvider, StatusInfo


class TestJupyterIntegrationMocked:
    """Test Colab integration with mocked Flow client."""
    
    def test_generate_session_id(self):
        """Test session ID generation."""
        mock_flow = Mock()
        integration = JupyterIntegration(mock_flow)
        
        session_id = integration.generate_session_id()
        
        assert session_id.startswith("flow-session-")
        assert len(session_id) > 20
        print(f"✓ Generated session ID: {session_id}")
    
    def test_launch_async(self):
        """Test async launch functionality."""
        mock_flow = Mock()
        integration = JupyterIntegration(mock_flow)
        
        # Mock the launch method to avoid actual API calls
        with patch.object(integration, 'launch') as mock_launch:
            mock_launch.return_value = JupyterConnection(
                url="http://localhost:8888",
                task_id="task-123",
                session_id="flow-session-test",
                instance_type="a100",
                startup_time=30.0,
                ssh_command="ssh -L 8888:localhost:8888 ubuntu@1.2.3.4"
            )
            
            session_id = integration.launch_async(
                instance_type="a100",
                hours=1.0
            )
            
            assert session_id.startswith("flow-session-")
            
            # Give the thread time to start
            time.sleep(0.5)
            
            # Check operation was tracked
            assert session_id in integration._operations
            operation = integration._operations[session_id]
            assert operation.instance_type == "a100"
            print(f"✓ Async launch started: {session_id}")
    
    def test_resolve_session_id(self):
        """Test partial session ID resolution."""
        mock_flow = Mock()
        integration = JupyterIntegration(mock_flow)
        
        # Add test sessions
        full_id = "flow-session-12345-abcdef"
        integration._operations[full_id] = Mock()
        
        # Test exact match
        assert integration.resolve_session_id(full_id) == full_id
        
        # Test prefix match
        assert integration.resolve_session_id("flow-session-12345") == full_id
        
        # Test short prefix
        assert integration.resolve_session_id("flow-sess") == full_id
        
        # Test non-existent
        with pytest.raises(Exception) as exc:
            integration.resolve_session_id("nonexistent")
        assert "no session found" in str(exc.value).lower()
        
        print("✓ Session ID resolution works")
    
    def test_status_provider(self):
        """Test status provider abstraction."""
        mock_flow = Mock()
        mock_flow.status.return_value = "running"
        mock_flow.logs.return_value = "Kernel starting...\nLoading modules...\nReady"
        
        provider = TaskStatusProvider(mock_flow, task_id="task-123")
        status = provider.get_status()
        
        assert status.status == "running"
        assert status.message == "Instance starting, setting up environment..."
        assert "Ready" in status.details
        assert status.task_id == "task-123"
        
        print("✓ Status provider returns real status")
    
    def test_list_sessions(self):
        """Test listing sessions."""
        mock_flow = Mock()
        integration = JupyterIntegration(mock_flow)
        
        # Mock session manager's list_sessions method
        mock_sessions = [
            Mock(session_id="session-1", notebook_name="train.ipynb"),
            Mock(session_id="session-2", notebook_name="analyze.ipynb")
        ]
        integration.session_manager.list_sessions = Mock(return_value=mock_sessions)
        
        sessions = integration.list_sessions()
        
        assert len(sessions) == 2
        assert sessions[0].session_id == "session-1"
        print(f"✓ Listed {len(sessions)} sessions")
    
    def test_progress_display_lifecycle(self):
        """Test progress display lifecycle."""
        from rich.console import Console
        console = Console()
        
        # Test with mock status provider
        mock_provider = Mock(spec=TaskStatusProvider)
        mock_provider.get_status.return_value = StatusInfo(
            status="running",
            message="Test is running",
            details="Mock details"
        )
        
        with ColabLaunchProgress(
            console, 
            "test-session", 
            detached=False,
            status_provider=mock_provider
        ) as progress:
            # Should start without error
            assert progress.start_time is not None
            
            # Update should call provider
            progress.update()
            mock_provider.get_status.assert_called()
        
        print("✓ Progress display lifecycle works")
    
    def test_error_handling(self):
        """Test error handling in integration."""
        mock_flow = Mock()
        # Mock list_volumes to return empty list (no existing volumes)
        mock_flow.list_volumes.return_value = []
        # Mock create_volume to return a volume with proper ID
        mock_volume = Mock()
        mock_volume.volume_id = "vol-test-123"
        mock_flow.create_volume.return_value = mock_volume
        # Mock run to raise API error
        mock_flow.run.side_effect = Exception("API Error: Quota exceeded")
        
        integration = JupyterIntegration(mock_flow)
        
        with pytest.raises(Exception) as exc:
            integration.launch(instance_type="h100", hours=1.0)
        
        assert "API Error" in str(exc.value)
        print("✓ Error handling works correctly")


if __name__ == "__main__":
    pytest.main([__file__, "-v", "-s"])