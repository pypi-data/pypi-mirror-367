# AUTOGENERATED FILE! PLEASE DON'T EDIT HERE. EDIT THE SOURCE NOTEBOOKS INSTEAD
import k1lib, dill, numpy as np, pprint, html, math, time; k1 = k1lib; requests = k1.dep("requests"); cli = k1.cli
from io import BytesIO; from PIL import Image
import matplotlib.pyplot as plt
__all__ = ["optimalZoom", "dist", "area", "polyArea", "tile", "elevMatrix", "sat", "elev", "satElev"]
def tilesCb(s,v): fetch_tile.cacheObj.fn = v                                     # tilesCb
k1.settings.add("kgis", k1.Settings()                                            # tilesCb
    .add("tiles", k1.Settings()                                                  # tilesCb
        .add("prefix", "https://mt0.google.com/vt/lyrs=s", "the string '&x={x}&y={y}&z={z}' will be added to this prefix to create a url to query tile images") # tilesCb
        .add("sqliteFile", "tiles.db", "sqlite file path to cache google maps tile images to", cb=tilesCb) # tilesCb
    , "gg maps tiles docs")                                                      # tilesCb
, "kgis-related module")                                                         # tilesCb
settings = k1.settings.kgis; settings                                            # tilesCb
TILE_SIZE = 256                                                                  # tilesCb
def latlon_to_tile_xy(lat:float, lon:float, zoom:int): lat_rad = math.radians(lat); n = 2 ** zoom; xtile = int((lon + 180.0) / 360.0 * n); ytile = int((1.0 - math.log(math.tan(lat_rad) + 1 / math.cos(lat_rad)) / math.pi) / 2.0 * n); return xtile, ytile # latlon_to_tile_xy
def tile_xy_to_pixel_xy(x, y): return x * TILE_SIZE, y * TILE_SIZE               # tile_xy_to_pixel_xy
def latlon_to_pixel_xy(lat, lon, zoom): lat_rad = math.radians(lat); n = 2 ** zoom; x = (lon + 180.0) / 360.0 * n * TILE_SIZE; y = (1.0 - math.log(math.tan(lat_rad) + 1 / math.cos(lat_rad)) / math.pi) / 2.0 * n * TILE_SIZE; return int(x), int(y) # latlon_to_pixel_xy
@k1.cache(timeout=0, maxsize=100_000, fn=settings.tiles.sqliteFile, pickle=(cli.toBytes(), cli.toImg())) # latlon_to_pixel_xy
def fetch_tile(x, y, z): response = requests.get(f"{settings.tiles.prefix}&x={x}&y={y}&z={z}"); response.raise_for_status(); return Image.open(BytesIO(response.content)) # fetch_tile
def tile(x, y, z):                                                               # tile
    """Grabs google maps tiles"""                                                # tile
    return fetch_tile(x,y,z)                                                     # tile
def get_satellite_image(top_left, bottom_right, target_width_px=1000, zoom=None): # get_satellite_image
    """Grabs satellite image of terrain"""                                       # get_satellite_image
    if zoom is None: zoom = optimalZoom(top_left, bottom_right, target_width_px) # get_satellite_image
    xtile_min, ytile_min = latlon_to_tile_xy(top_left[0], top_left[1], zoom); xtile_max, ytile_max = latlon_to_tile_xy(bottom_right[0], bottom_right[1], zoom) # get_satellite_image
    width = (xtile_max - xtile_min + 1) * TILE_SIZE; height = (ytile_max - ytile_min + 1) * TILE_SIZE; stitched = Image.new("RGB", (width, height)) # get_satellite_image
    for x in range(xtile_min, xtile_max + 1):                                    # get_satellite_image
        for y in range(ytile_min, ytile_max + 1): tile = fetch_tile(x, y, zoom); stitched.paste(tile, ( (x - xtile_min) * TILE_SIZE, (y - ytile_min) * TILE_SIZE )) # get_satellite_image
    pixel_min = latlon_to_pixel_xy(top_left[0], top_left[1], zoom); pixel_max = latlon_to_pixel_xy(bottom_right[0], bottom_right[1], zoom) # get_satellite_image
    left = pixel_min[0] - xtile_min * TILE_SIZE; upper = pixel_min[1] - ytile_min * TILE_SIZE; right = pixel_max[0] - xtile_min * TILE_SIZE; lower = pixel_max[1] - ytile_min * TILE_SIZE # get_satellite_image
    return stitched.crop((left, upper, right, lower))                            # get_satellite_image
def optimalZoom(top_left, bottom_right, target_width_px=1000):                   # optimalZoom
    """Calculates what's the optimal zoom to request elevation tiles. Subtract 2 to get nice display zoom""" # optimalZoom
    lon_diff = abs(bottom_right[1] - top_left[1]); center_lat = (top_left[0] + bottom_right[0]) / 2.0 # optimalZoom
    for z in range(1, 22):                                                       # optimalZoom
        n = 2 ** z; pixel_width = lon_diff * (n * TILE_SIZE / 360.0); pixel_width *= math.cos(math.radians(center_lat)) # Adjust for latitude distortion in Mercator projection # optimalZoom
        if pixel_width > target_width_px: return z - 1 if z > 1 else 1           # optimalZoom
    return 21  # fallback to max zoom                                            # optimalZoom
def correctCoords(top_left, bottom_right): latMin = min(top_left[0], bottom_right[0]); latMax = max(top_left[0], bottom_right[0]); lngMin = min(top_left[1], bottom_right[1]); lngMax = max(top_left[1], bottom_right[1]); return (latMax, lngMin), (latMin, lngMax) # correctCoords
def dist(top_left:"(float, float)", bottom_right:"(float, float)") -> float:     # dist
    """Calculates haversine distance in meters between 2 points"""               # dist
    (lat1, lon1), (lat2, lon2) = correctCoords(top_left, bottom_right)           # dist
    R = 6371000; lat1_rad, lat2_rad = math.radians(lat1), math.radians(lat2); delta_lat = lat2_rad - lat1_rad; delta_lon = math.radians(lon2 - lon1) # dist
    a = math.sin(delta_lat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(delta_lon / 2) ** 2; return 2 * R * math.asin(math.sqrt(a)) # dist
def area(top_left:"(float, float)", bottom_right:"(float, float)") -> float:     # area
    """Grab area in m2 of the specified region"""                                # area
    (lat1, lon1), (lat2, lon2) = correctCoords(top_left, bottom_right); height = dist((lat1, lon1), (lat2, lon1)); width = dist((lat1, lon1), (lat1, lon2)); return width * height # area
def polyArea(latlng_points):                                                     # polyArea
    """Approximates the area of a polygon on Earth using the spherical excess formula.""" # polyArea
    if len(latlng_points) < 3: return 0.0  # Not a polygon                       # polyArea
    def deg2rad(deg): return deg * math.pi / 180                                 # polyArea
    R = 6371000; total = 0.0                                                     # polyArea
    for i in range(len(latlng_points)):                                          # polyArea
        lat1, lon1 = latlng_points[i - 1]; lat2, lon2 = latlng_points[i]         # polyArea
        lat1 = deg2rad(lat1); lat2 = deg2rad(lat2); lon1 = deg2rad(lon1); lon2 = deg2rad(lon2) # polyArea
        total += (lon2 - lon1) * (2 + math.sin(lat1) + math.sin(lat2))           # polyArea
    return abs(total) * (R ** 2) / 2                                             # polyArea
def elevCb(s,v): get_tile_elevation.cacheObj.fn = v                              # elevCb
settings.add("elev", k1.Settings()                                               # elevCb
             .add("gpxzApiKey", "fillInHere", "api key to use https://www.gpxz.io/'s service", env="GPXZ_API_KEY", sensitive=True) # elevCb
             .add("prod", True, "whether to actually call the api or just return some dummy elevation data instead") # elevCb
             .add("sqliteFile", "elevs.db", "sqlite file path to cache elevation calls", cb=elevCb) # elevCb
, "all settings related to getting elevations of a particular area")             # elevCb
def _elevationFunc(latlngs:"list[(float, float)]") -> list[float]: # can swap with different implementation # _elevationFunc
    if settings.elev.prod:                                                       # _elevationFunc
        ans = []                                                                 # _elevationFunc
        for a in latlngs | ~cli.apply(lambda x,y: f"{x},{y}") | cli.batched(512, True) | cli.join("|").all(): # _elevationFunc
            res = requests.post('https://api.gpxz.io/v1/elevation/points', headers={'x-api-key': settings.elev.gpxzApiKey}, data={'latlons': a}) # _elevationFunc
            res.raise_for_status(); ans.extend([x["elevation"] for x in res.json()["results"]]); time.sleep(1) # _elevationFunc
        return ans                                                               # _elevationFunc
    else: freq = 100; return [math.cos(lat*freq) + math.sin(lng*freq) for lat,lng in latlngs] # _elevationFunc
elevationFunc = [_elevationFunc]; elevations = {} # maps from (int,int,int) -> float # _elevationFunc
def registerElevationFunc(f): elevationFunc[0] = f # there's this function that's supposed to be exposed, but too lazy to explain everything, so just leave this mechanism private # registerElevationFunc
def tile_to_latlon(x, y, z): n = 2.0 ** z; lon = x / n * 360.0 - 180.0; lat_rad = math.atan(math.sinh(math.pi * (1 - 2 * y / n))); lat = math.degrees(lat_rad); return lat, lon # tile_to_latlon
def latlon_to_tile_xy(lat, lon, zoom): lat_rad = math.radians(lat); n = 2 ** zoom; xtile = int((lon + 180.0) / 360.0 * n); ytile = int((1.0 - math.log(math.tan(lat_rad) + 1 / math.cos(lat_rad)) / math.pi) / 2.0 * n); return xtile, ytile # latlon_to_tile_xy
@k1.cache(timeout=0, maxsize=10_000_000, fn=settings.elev.sqliteFile)            # latlon_to_tile_xy
def get_tile_elevation(x,y,z):                                                   # get_tile_elevation
    key = (x,y,z)                                                                # get_tile_elevation
    if key in elevations: return elevations[key]                                 # get_tile_elevation
    else: return get_tile_elevations([(x,y,z)])[0]                               # get_tile_elevation
def get_tile_elevations(xyzs:"list[(int, int, int)]") -> "list[float]":          # get_tile_elevations
    latlngs = [[i, (x,y,z), tile_to_latlon(x, y, z)] for i,[x,y,z] in enumerate(xyzs)] # get_tile_elevations
    hasKeys = [[i,get_tile_elevation(*key)] for i,key,latlng in latlngs if get_tile_elevation.cacheObj.hasKey(*key)] # get_tile_elevations
    noKeys  = [[i,latlng] for i,key,latlng in latlngs if not get_tile_elevation.cacheObj.hasKey(*key)]; noKeysI = [i for i,latlng in noKeys] # get_tile_elevations
    res = sorted([*hasKeys, *zip(noKeysI, elevationFunc[0]([latlng for i,latlng in noKeys]))], key=lambda x: x[0]) # get_tile_elevations
    for xyz,[i,elev] in zip(xyzs, res): elevations[xyz] = elev                   # get_tile_elevations
    [get_tile_elevation(*key) for i,key,latlng in latlngs if not get_tile_elevation.cacheObj.hasKey(*key)]; return [elev for i,elev in res] # get_tile_elevations
def elevMatrix(top_left, bottom_right, zoom):                                    # elevMatrix
    """Generates elevation matrix of area"""                                     # elevMatrix
    xtile_min, ytile_min = latlon_to_tile_xy(top_left[0], top_left[1], zoom)     # elevMatrix
    xtile_max, ytile_max = latlon_to_tile_xy(bottom_right[0], bottom_right[1], zoom) # elevMatrix
    width = xtile_max - xtile_min + 1; height = ytile_max - ytile_min + 1; ir = [] # elevMatrix
    for y in range(ytile_min, ytile_max + 1):                                    # elevMatrix
        for x in range(xtile_min, xtile_max + 1): ir.append((x,y,zoom))          # elevMatrix
    return np.array(get_tile_elevations(ir) | cli.batched(xtile_max-xtile_min+1) | cli.deref()) # elevMatrix
def _satElev(top_left, bottom_right, alpha=0):                                   # _satElev
    mat = elevMatrix(top_left, bottom_right, optimalZoom(top_left, bottom_right)+4); im = sat(top_left, bottom_right); # _satElev
    height, width = mat.shape; X, Y = np.meshgrid(np.linspace(0, im.width, width), np.linspace(0, im.height, height)) # _satElev
    with k1.mplLock:                                                             # _satElev
        plt.imshow(im, alpha=1-alpha)                                            # _satElev
        cs = plt.contourf(X, Y, mat, levels=15, cmap='viridis', alpha=alpha); plt.colorbar(cs, alpha=1, label="Elevation (m)") # _satElev
        plt.axis('off'); plt.title(f"top_left: {top_left}\nbottom_right: {bottom_right}"); plt.tight_layout(); return plt.gcf() | cli.toImg() # _satElev
def sat(top_left:"(float, float)", bottom_right:"(float, float)"):               # sat
    """Grabs PIL image of satellite image of an area"""                          # sat
    return get_satellite_image(*correctCoords(top_left, bottom_right))           # sat
def satElev(top_left:"(float, float)", bottom_right:"(float, float)", alpha=0.4): # satElev
    """Grabs PIL image of satellite image overlayed with elevation plot of an area""" # satElev
    return _satElev(*correctCoords(top_left, bottom_right), alpha)               # satElev
def elev(top_left:"(float, float)", bottom_right:"(float, float)"):              # elev
    """Grabs PIL image of elevation plot of an area"""                           # elev
    return _satElev(*correctCoords(top_left, bottom_right), 1)                   # elev
