# This file is automatically generated by pyo3_stub_gen
# ruff: noqa: E501, F401

import builtins
import typing
from enum import Enum

class DTT:
    r"""
    ## immutable "global" values
    A DTT struct stores channels used to communicate with the user.
    The user owns the struct and merely drops it when done.
    The entire core will shut down at that point.
    Most public API is called on this structure.

    Applications should use the init_...() functions to create this structure.
    """

    ...

class MessageJob:
    def get_tag(self) -> builtins.str:
        r"""
        Helps with sorting messages without having to match on them first
        """
    class SetMessage(MessageJob):
        __match_args__ = (
            "tag",
            "msg",
        )
        @property
        def tag(self) -> builtins.str: ...
        @property
        def msg(self) -> UserMessage: ...
        def __new__(
            cls, tag: builtins.str, msg: UserMessage
        ) -> MessageJob.SetMessage: ...

    class ClearMessage(MessageJob):
        __match_args__ = ("tag",)
        @property
        def tag(self) -> builtins.str: ...
        def __new__(cls, tag: builtins.str) -> MessageJob.ClearMessage: ...

class PipDuration:
    def __sub__(self, other: PipDuration) -> PipDuration: ...
    def __add__(self, other: typing.Any) -> typing.Any:
        r"""
        Add a duration to get a combined duration
        or Add a instant to get a new instant
        """
    def __mul__(self, other: typing.Any) -> typing.Any:
        r"""
        Multiply by a number to get a scaled duration
        """
    def __rmul__(self, other: typing.Any) -> typing.Any: ...
    def __truediv__(self, other: typing.Any) -> typing.Any:
        r"""
        Divide by a float or number to get a scaled duration
        Divide by a duration to get a ratio.
        """
    def __floordiv__(self, other: typing.Any) -> typing.Any:
        r"""
        Divide by a float or number to get a scaled duration
        Divide by a duration to get a ratio
        """
    def __mod__(self, other: typing.Any) -> typing.Any:
        r"""
        Get the remainder from an equivalent integer division
        """
    def __neg__(self) -> typing.Any: ...
    def __pos__(self) -> typing.Any: ...
    def __abs__(self) -> typing.Any: ...
    @staticmethod
    def freq_hz_to_period(rate_hz: builtins.float) -> PipDuration:
        r"""
        Convert a frequency as Hz into a duration that represents the corresponding period.
        """
    def period_to_freq_hz(self) -> builtins.float:
        r"""
        Convert a duration that represents a period into the corresponding frequency as Hz.
        """
    @staticmethod
    def from_seconds(seconds: builtins.float) -> PipDuration:
        r"""
        Create a duration given the length in seconds.
        """
    def to_seconds(self) -> builtins.float:
        r"""
        Return the length of the duration as seconds.
        """
    @staticmethod
    def from_sec(seconds: builtins.int) -> PipDuration:
        r"""
        Create a duration given the length in seconds.
        """
    def to_sec(self) -> builtins.int:
        r"""
        Round the duration to the nearest second.

        Return 0 for negative durations.
        """
    @staticmethod
    def from_nanoseconds(nanoseconds: builtins.int) -> PipDuration:
        r"""
        Create a duration given the length in nanoseconds.
        """
    def to_nanoseconds(self) -> builtins.int:
        r"""
        Return the length to the nearest nanosecond,
        but return zero if the duration is negative.
        """
    def to_seconds_nanoseconds(self) -> tuple[builtins.int, builtins.int]:
        r"""
        Return the length as seconds and nanoseconds
        """
    @staticmethod
    def from_pips(pips: builtins.int) -> PipDuration:
        r"""
        Create  a duration object from a numerical value of the same units.
        """
    @staticmethod
    def from_seconds_nanoseconds(
        seconds: builtins.int, nano: builtins.int
    ) -> PipDuration:
        r"""
        Create a duration given the length as seconds and nanoseconds
        """
    def to_pips(self) -> builtins.int:
        r"""
        Return duration in units of the type..
        """
    def is_empty(self) -> builtins.bool:
        r"""
        True if the length of the duration is zero.
        """
    def abs(self) -> PipDuration:
        r"""
        Return a non-negative duration of the same magnitude.
        """
    def snap_to_step(self, step: PipDuration) -> PipDuration:
        r"""
        Snap to the nearest integer multiple of a step size.
        """
    def snap_down_to_step(self, step: PipDuration) -> PipDuration:
        r"""
        Snap to the largest integer <= self that's a multiple of a step size.

        Like snap_to_step, but takes the floor rather than the nearest.
        """
    def snap_up_to_step(self, step: PipDuration) -> PipDuration:
        r"""
        Snap to the smallest integer >= self that's a multiple of a step size.

        Like snap_to_step, but takes the ceiling rather than the nearest.
        """
    @staticmethod
    def rate_hz() -> builtins.int:
        r"""
        Return the rate of the units in Hz
        """

class PipInstant:
    def __add__(self, other: PipDuration) -> PipInstant: ...
    def __sub__(self, other: typing.Any) -> typing.Any:
        r"""
        Subtract a duration to get an instant,
        or subtract a instant to get the difference as a duration.
        """
    def to_gpst_pips(self) -> builtins.int:
        r"""
        Return the number of steps since the GPS epoch.
        """
    def to_gpst_seconds_nanoseconds(self) -> tuple[builtins.int, builtins.int]:
        r"""
        Return the nearest nanosecond since the GPS epoch.
        """
    def to_gpst_nanoseconds(self) -> builtins.int:
        r"""
        If positive, return nanoseconds since the GPS epoch, otherwise zero.
        """
    def to_gpst_sec(self) -> builtins.int:
        r"""
        Return the seconds since GPS epoch rounded down to the latest second
        earlier than or coincident with the instant.

        Returns 0 for instants before the GPS epoch.
        """
    def to_gpst_seconds(self) -> builtins.float:
        r"""
        Return the number of seconds since the GPS epoch.
        """
    @staticmethod
    def from_gpst_seconds_nanoseconds(
        seconds: builtins.int, nano: builtins.int
    ) -> PipInstant:
        r"""
        Create an instant given seconds + nanoseconds since the GPS epoch.
        """
    @staticmethod
    def from_gpst_nanoseconds(nano: builtins.int) -> PipInstant:
        r"""
        Create an instant given nanoseconds since the GPS epoch.
        """
    @staticmethod
    def from_gpst_seconds(seconds: builtins.float) -> PipInstant:
        r"""
        Create an instant given seconds since the GPS epoch.
        """
    @staticmethod
    def gpst_epoch() -> PipInstant:
        r"""
        Create an instant at Midnight UTC, Jan 6 1980,
        the reference epoch for the GPS time system.
        """
    @staticmethod
    def from_gpst_sec(seconds: builtins.int) -> PipInstant:
        r"""
        Create an instant given whole seconds since the GPS epoch.
        """
    @staticmethod
    def from_gpst_pips(pips: builtins.int) -> PipInstant:
        r"""
        Create an instant given steps since the GPS epoch.
        """
    def snap_to_step(self, step: PipDuration) -> PipInstant:
        r"""
        Snap to the nearest integer multiple of a step size.
        """
    def snap_down_to_step(self, step: PipDuration) -> PipInstant:
        r"""
        Snap to the largest integer <= self that's a multiple of a step size.

        Like snap_to_step, but takes the floor rather than the nearest.
        """
    def snap_up_to_step(self, step: PipDuration) -> PipInstant:
        r"""
        Snap to the smallest integer >= self that's a multiple of a step size.

        Like snap_to_step, but takes the ceiling rather than the nearest.
        """
    @staticmethod
    def rate_hz() -> builtins.int:
        r"""
        Return the rate of the units in Hz
        """

class ThumpDuration:
    def __sub__(self, other: ThumpDuration) -> ThumpDuration: ...
    def __add__(self, other: typing.Any) -> typing.Any:
        r"""
        Add a duration to get a combined duration
        or Add a instant to get a new instant
        """
    def __mul__(self, other: typing.Any) -> typing.Any:
        r"""
        Multiply by a number to get a scaled duration
        """
    def __rmul__(self, other: typing.Any) -> typing.Any: ...
    def __truediv__(self, other: typing.Any) -> typing.Any:
        r"""
        Divide by a float or number to get a scaled duration
        Divide by a duration to get a ratio.
        """
    def __floordiv__(self, other: typing.Any) -> typing.Any:
        r"""
        Divide by a float or number to get a scaled duration
        Divide by a duration to get a ratio
        """
    def __mod__(self, other: typing.Any) -> typing.Any:
        r"""
        Get the remainder from an equivalent integer division
        """
    def __neg__(self) -> typing.Any: ...
    def __pos__(self) -> typing.Any: ...
    def __abs__(self) -> typing.Any: ...
    @staticmethod
    def freq_hz_to_period(rate_hz: builtins.float) -> ThumpDuration:
        r"""
        Convert a frequency as Hz into a duration that represents the corresponding period.
        """
    def period_to_freq_hz(self) -> builtins.float:
        r"""
        Convert a duration that represents a period into the corresponding frequency as Hz.
        """
    @staticmethod
    def from_seconds(seconds: builtins.float) -> ThumpDuration:
        r"""
        Create a duration given the length in seconds.
        """
    def to_seconds(self) -> builtins.float:
        r"""
        Return the length of the duration as seconds.
        """
    @staticmethod
    def from_sec(seconds: builtins.int) -> ThumpDuration:
        r"""
        Create a duration given the length in seconds.
        """
    def to_sec(self) -> builtins.int:
        r"""
        Round the duration to the nearest second.

        Return 0 for negative durations.
        """
    @staticmethod
    def from_nanoseconds(nanoseconds: builtins.int) -> ThumpDuration:
        r"""
        Create a duration given the length in nanoseconds.
        """
    def to_nanoseconds(self) -> builtins.int:
        r"""
        Return the length to the nearest nanosecond,
        but return zero if the duration is negative.
        """
    def to_seconds_nanoseconds(self) -> tuple[builtins.int, builtins.int]:
        r"""
        Return the length as seconds and nanoseconds
        """
    @staticmethod
    def from_thumps(thumps: builtins.int) -> ThumpDuration:
        r"""
        Create  a duration object from a numerical value of the same units.
        """
    @staticmethod
    def from_seconds_nanoseconds(
        seconds: builtins.int, nano: builtins.int
    ) -> ThumpDuration:
        r"""
        Create a duration given the length as seconds and nanoseconds
        """
    def to_thumps(self) -> builtins.int:
        r"""
        Return duration in units of the type..
        """
    def is_empty(self) -> builtins.bool:
        r"""
        True if the length of the duration is zero.
        """
    def abs(self) -> ThumpDuration:
        r"""
        Return a non-negative duration of the same magnitude.
        """
    def snap_to_step(self, step: ThumpDuration) -> ThumpDuration:
        r"""
        Snap to the nearest integer multiple of a step size.
        """
    def snap_down_to_step(self, step: ThumpDuration) -> ThumpDuration:
        r"""
        Snap to the largest integer <= self that's a multiple of a step size.

        Like snap_to_step, but takes the floor rather than the nearest.
        """
    def snap_up_to_step(self, step: ThumpDuration) -> ThumpDuration:
        r"""
        Snap to the smallest integer >= self that's a multiple of a step size.

        Like snap_to_step, but takes the ceiling rather than the nearest.
        """
    @staticmethod
    def rate_hz() -> builtins.int:
        r"""
        Return the rate of the units in Hz
        """

class ThumpInstant:
    def __add__(self, other: ThumpDuration) -> ThumpInstant: ...
    def __sub__(self, other: typing.Any) -> typing.Any:
        r"""
        Subtract a duration to get an instant,
        or subtract a instant to get the difference as a duration.
        """
    def to_gpst_thumps(self) -> builtins.int:
        r"""
        Return the number of steps since the GPS epoch.
        """
    def to_gpst_seconds_nanoseconds(self) -> tuple[builtins.int, builtins.int]:
        r"""
        Return the nearest nanosecond since the GPS epoch.
        """
    def to_gpst_nanoseconds(self) -> builtins.int:
        r"""
        If positive, return nanoseconds since the GPS epoch, otherwise zero.
        """
    def to_gpst_sec(self) -> builtins.int:
        r"""
        Return the seconds since GPS epoch rounded down to the latest second
        earlier than or coincident with the instant.

        Returns 0 for instants before the GPS epoch.
        """
    def to_gpst_seconds(self) -> builtins.float:
        r"""
        Return the number of seconds since the GPS epoch.
        """
    @staticmethod
    def from_gpst_seconds_nanoseconds(
        seconds: builtins.int, nano: builtins.int
    ) -> ThumpInstant:
        r"""
        Create an instant given seconds + nanoseconds since the GPS epoch.
        """
    @staticmethod
    def from_gpst_nanoseconds(nano: builtins.int) -> ThumpInstant:
        r"""
        Create an instant given nanoseconds since the GPS epoch.
        """
    @staticmethod
    def from_gpst_seconds(seconds: builtins.float) -> ThumpInstant:
        r"""
        Create an instant given seconds since the GPS epoch.
        """
    @staticmethod
    def gpst_epoch() -> ThumpInstant:
        r"""
        Create an instant at Midnight UTC, Jan 6 1980,
        the reference epoch for the GPS time system.
        """
    @staticmethod
    def from_gpst_sec(seconds: builtins.int) -> ThumpInstant:
        r"""
        Create an instant given whole seconds since the GPS epoch.
        """
    @staticmethod
    def from_gpst_thumps(thumps: builtins.int) -> ThumpInstant:
        r"""
        Create an instant given steps since the GPS epoch.
        """
    def snap_to_step(self, step: ThumpDuration) -> ThumpInstant:
        r"""
        Snap to the nearest integer multiple of a step size.
        """
    def snap_down_to_step(self, step: ThumpDuration) -> ThumpInstant:
        r"""
        Snap to the largest integer <= self that's a multiple of a step size.

        Like snap_to_step, but takes the floor rather than the nearest.
        """
    def snap_up_to_step(self, step: ThumpDuration) -> ThumpInstant:
        r"""
        Snap to the smallest integer >= self that's a multiple of a step size.

        Like snap_to_step, but takes the ceiling rather than the nearest.
        """
    @staticmethod
    def rate_hz() -> builtins.int:
        r"""
        Return the rate of the units in Hz
        """

class UserMessage:
    @property
    def severity(self) -> Severity: ...
    @property
    def message(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...

class Severity(Enum):
    Debug = ...
    Notice = ...
    ConfigurationWarning = ...
    Warning = ...
    Error = ...
    ConfigurationError = ...
    FatalError = ...
    SystemError = ...
